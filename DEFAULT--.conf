# conf file for DEFAULT-- flight script by TheGreatSardini
# Modified from DEFAULT ++ by Jeronimo

name: (Pilot) DEFAULT--v0.9.9

slots:
 core:
  class: CoreUnit
 gyro:
  class: GyroUnit
 DB:
  class: DataBankUnit
  select: manual
 shield:
  class: ShieldGeneratorUnit
 radar:
  class: RadarPVPUnit
  select: manual
 antigrav:
  class: AntiGravityGeneratorUnit
 warpdrive:
  class: WarpDriveUnit
 atmofueltank:
  class: AtmoFuelContainer
  select: manual
 spacefueltank:
  class: SpaceFuelContainer
  select: manual
 rocketfueltank:
  class: RocketFuelContainer
  select: manual
 switch:
  class: ManualSwitchUnit
  select: manual
 telemeter:
  class: TelemeterUnit
 vBooster:
  class: VerticalBooster
 hover:
  class: Hovercraft
handlers:
 unit:
  onStart:
   lua: |
    if #switch ~= 0 then switch_1.activate() end
    --q = q
    P = {
     w_title = "MAIN MENU",
     w_pos = {x=0, y=0},
     w_open = false,
     [1] = 'MS',
     [2] = 'ES',
     [3] = 'AS',
     [4] = 'WS',
     [5] = 'KP',
     [6] = 'Widgets_Custom',
     MS = {
      w_title = "MENU SETTINGS",
      w_pos = {x=5, y=50},
      w_open = true,
      [1] = 'TC',
      [2] = 'TCA',
      [3] = 'TTC',
      [4] = 'separator',
      [5] = 'WC',
      [6] = 'WCA',
      [7] = 'WTC',
      [8] = 'separator',
      [9] = 'BC',
      [10] = 'BBC',
      [11] = 'BCA',
      [12] = 'BTC',
      [13] = 'separator',
      [14] = 'wTC',
      [15] = 'wAC',
      [16] = 'WFC',
      [17] = 'separator',
      [18] = 'PRESET',
      [19] = 'separator',
      [20] = 'HELP_MENU',
      TC = {name = "TITLE COLOR", value = "white", range = {}, q = false},
      TCA = {name = "TITLE ALPHA", value = 1, range = {0,1}, step = {0.1, 0.05}, increment = 0.1, q = false},
      TTC = {name = "TITLE TEXT COLOR", value = "black", range = {}, q = false},
      WC = {name = "WINDOW COLOR", value = "midnightblue", range = {}, q = false},
      WCA = {name = "WINDOW ALPHA", value = 0.4, range = {0,1}, step = {0.1, 0.05}, increment = 0.1, q = false},
      WTC = {name = "WINDOW TEXT COLOR", value = "skyblue", range = {}, q = false},
      BC = {name = "BUTTON COLOR", value = "white", range = {}, q = false},
      BBC = {name = "BUTTON BORDER COLOR", value = "lightgray", range = {}, q = false},
      BCA = {name = "BUTTON ALPHA", value = 0.1, range = {0,1}, step = {0.1, 0.05}, increment = 0.1, q = false},
      BTC = {name = "BUTTON TEXT COLOR", value = "white", range = {}, q = false},
      wTC = {name = "WIDGET TEXT COLOR", value = "skyblue", range = {}, q = false},
      wAC = {name = "WIDGET SVG COLOR1", value = "red", range = {}, q = false},
      WFC = {name = "WIDGET SVG COLOR2", value = "white", range = {}, q = false},
      PRESET = {name = "COLOR PRESETS", value = "preset1", range = {"preset0","preset1","preset2","preset3","preset4","preset5"}, q = true},
      HELP_MENU = {name = "HELP MENU", value = function() P.help_menu.w_open = not P.help_menu.w_open end, q = false},
     },
     ES = {
      w_title = "ENGINE SETTINGS",
      w_pos = {x=270, y=50},
      w_open = true,
      [1] = 'pSF',
      [2] = 'ySF',
      [3] = 'rSF',
      [4] = 'anD',
      [5] = 'separator',
      [6] = 'loF',
      [7] = 'laF',
      [8] = 'vtF',
      [9] = 'separator',
      [10] = 'loB',
      [11] = 'laB',
      [12] = 'vtB',
      [13] = 'spB',
      [14] = 'separator',
      [15] = 'gyr',
      [16] = 'pAd',
      [17] = 'rAd',
      [18] = 'separator',
      [19] = 'hov',
      [20] = 'hoM',
      [21] = 'hoA',
      [22] = 'agA',
      [23] = 'separator',
      [24] = 'eng',
      [25] = 'aMS',
      [26] = 'separator',
      [27] = 'dCA',
      [28] = 'dSA',
      pSF = {name = "PITCH FACTOR", value = 1, range = {0,1}, step = {0.01, 0.1, 0.5}, increment = 0.1, q = false},
      ySF = {name = "YAW FACTOR", value = 1, range = {0,1}, step = {0.01, 0.1, 0.5}, increment = 0.1, q = false},
      rSF = {name = "ROLL FACTOR", value = 1, range = {0,1}, step = {0.01, 0.1, 0.5}, increment = 0.1, q = false},
      anD = {name = "ANGULAR DAMPING", value = 0.2, range = {0,1}, step = {0.01, 0.1, 0.5}, increment = 0.1, q = false},
      loF = {name = "LONG FACTOR", value = 1, range = {0,1}, step = {0.01, 0.1, 0.5}, increment = 0.1, q = false},
      laF = {name = "LAT FACTOR", value = 1, range = {0,1}, step = {0.01, 0.1, 0.5}, increment = 0.1, q = false},
      vtF = {name = "VERT FACTOR", value = 1, range = {0,1}, step = {0.01, 0.1, 0.5}, increment = 0.1, q = false},
      loB = {name = "LONG BRAKE FACTOR", value = 1, range = {0,10}, step = {0.01, 0.1, 0.5}, increment = 0.1, q = false},
      laB = {name = "LAT BRAKE FACTOR", value = 1, range = {0,10}, step = {0.01, 0.1, 0.5}, increment = 0.1, q = false},
      vtB = {name = "VERT BRAKE FACTOR", value = 1, range = {0,10}, step = {0.01, 0.1, 0.5}, increment = 0.1, q = false},
      spB = {name = "SPACE BRAKE INTENSITY", value = 1, range = {0,10}, step = {0.01, 0.1, 0.5}, increment = 0.1, q = false},
      gyr = {name = "GYRO AXIS", value = "OFF", range = {"ON","CROSS","OFF"}, q = false},
      pAd = {name = "PITCH TILTING", value = 0, range = {-90,90}, step = {1, 45, 90}, increment = 1, q = false},
      rAd = {name = "ROLL TILTING", value = 0, range = {-90,90}, step = {1, 45, 90}, increment = 1, q = false},
      hov = {name = "HOVERS ON/OFF", value = "ON", range = {"ON","OFF"}, q = false},
      hoM = {name = "HOVERS MODE", value = "DYNAMIC", range = {"DYNAMIC","STATIC"}, q = true},
      hoA = {name = "HOVERS ALTITUDE", value = 5, range = {0,80}, step = {0.1, 1, 5}, increment = 1, q = true},
      agA = {name = "AGG ALTITUDE", value = 1000, range = {1000,500000}, step = {1, 10, 100, 1000, 10000}, increment = 100, q = false},
      eng = {name = "ENGINES ON/OFF", value = "AUTO", range = {"ON","OFF","AUTO"}, q = false},
      aMS = {name = "ATMO MAX SPEED", value = math.floor(construct.getFrictionBurnSpeed()*3.6), range = {-1,29999}, step = {1, 10, 100}, increment = 10, q = false},
      dCA = {name = "DRONE CRUISE ANGLE", value = 22, range = {1,88}, step = {1, 5, 10}, increment = 1, q = false},
      dSA = {name = "DRONE SHIFT ANGLE", value = 60, range = {1,88}, step = {1, 5, 10}, increment = 1, q = false}
     },
     AS = {
      w_title = "AUTO-ASSIST SETTINGS",
      w_pos = {x=535, y=50},
      w_open = true,
      [1] = 'aBS',
      [2] = 'separator',
      [3] = 'stA',
      [4] = 'auR',
      [5] = 'tuA',
      [6] = 'tAR',
      [7] = 'tAP',
      [8] = 'separator',
      [9] = 'auP',
      [10] = 'aPA',
      [11] = 'atS',
      [12] = 'anS',
      [13] = 'separator',
      [14] = 'iAB',
      [15] = 'aAD',
      [16] = 'sAD',
      [17] = 'aPG',
      [18] = 'aOS',
      [19] = 'separator',
      [20] = 'rMS',
      [21] = 'separator',
      [22] = 'dok',
      [23] = 'separator',
      [24] = 'bBu',
      [25] = 'aLR',
      [26] = 'grO',
      aBS = {name = "AUTO BRAKE SPEED", value = 100, range = {0,1000}, step = {1, 5, 10}, increment = 1, q = false},
      stA = {name = "AUTO LEVEL ALT. MAX", value = 200000, range = {-2000,500000}, step = {100, 1000, 10000}, increment = 100, q = false},
      auR = {name = "ROLL STABILISATION", value = true, q = false},
      tuA = {name = "TURN ASSIST", value = false, q = true},
      tAR = {name = "TURN ASSIST MIN ROLL", value = 3, range = {1,90}, step = {1, 5, 10}, increment = 1, q = false},
      tAP = {name = "TURN ASSIST MAX PITCH", value = 45, range = {1,90}, step = {1, 5, 10}, increment = 1, q = false},
      auP = {name = "PITCH STABILISATION", value = true, q = false},
      aPA = {name = "AUTO PITCH AMPLITUDE", value = 2, range = {1,90}, step = {0.5, 1, 5}, increment = 1, q = false},
      atS = {name = "ALTITUDE STABILISATION", value = true, q = false},
      anS = {name = "ATMO ANTI-STALL", value = false, q = false},
      iAB = {name = "INERTIA AUTO BRAKE", value = true, q = true},
      aAD = {name = "ATMO INERTIA FACTOR", value = 0.95, range = {0,1}, step = {0.001, 0.01, 0.1}, increment = 0.01, q = false},
      sAD = {name = "SPACE INERTIA FACTOR", value = 0.60, range = {0,1}, step = {0.001, 0.01, 0.1}, increment = 0.01, q = false},
      aPG = {name = "SPACE AUTO PROGRADE", value = false, q = false},
      aOS = {name = "AUTO ORBIT SPEED", value = false, q = false},
      rMS = {name = "ROCKETS MAX SPEED", value = 1200, range = {-1,29999}, step = {1, 10, 100}, increment = 10, q = false},
      dok = {name = "DOCKING PARENT", value = "MANUAL", range = {"MANUAL","OWNER","CLOSEST"}, q = false},
      bBu = {name = "BACK BURN", value = false, q = false},
      aLR = {name = "AUTO LAND FACTOR", value = 0.7, range = {0,1.1}, step = {0.001, 0.01, 0.1}, increment = 0.1, q = false},
      grO = {name = "GROUND OFFSET", value = 3, range = {0,50}, step = {0.1, 1}, increment = 1, q = false},
     },
     WS = {
      w_title = "WIDGETS",
      w_pos = {x=800, y=50},
      w_open = true,
      [1] = 'w_hud',
      [2] = 'w_info',
      [3] = 'w_platform',
      [4] = 'w_speedometer',
      [5] = 'w_gyro',
      [6] = 'w_fuel',
      [7] = 'separator',
      [8] = 'w_core',
      [9] = 'w_agg',
      [10] = 'w_warp',
      [11] = 'w_parenting',
      [12] = 'w_cstress',
      [13] = 'w_shield',
      [14] = 'separator',
      [15] = 'w_periscope',
      [16] = 'w_radar',
      [17] = 'w_refresh',
      w_hud = {name = "HUD", value = "Default --", range = {"Default --","None"}, q = false},
      w_info = {name = "INFO", value = "Default --", range = {"Default --","None"}, q = false},
      w_platform = {name = "PLATFORM HUD", value = "None", range = {"Default --","None"}, q = false},
      w_speedometer = {name = "SPEEDOMETER", value = "None", range = {"Default", "None"}, q = false},
      w_gyro = {name = "GYROSCOPE", value = "None", range = {"Default", "None"}, q = false},
      w_fuel = {name = "FUEL TANKS", value = "None", range = {"Default", "None"}, q = false},
      w_core = {name = "CORE", value = "None", range = {"Default", "ALT", "None"}, q = false},
      w_agg = {name = "AGG", value = "None", range = {"Default", "ALT", "None"}, q = false},
      w_warp = {name = "WARP DRIVE", value = "None", range = {"Default", "ALT", "Auto", "None"}, q = false},
      w_parenting = {name = "PARENTING", value = "None", range = {"Default", "ALT", "None"}, q = false},
      w_cstress = {name = "COMBAT STRESS", value = "None", range = {"Default", "ALT", "None"}, q = false},
      w_shield = {name = "SHIELD", value = "None", range = {"Default", "ALT", "None"}, q = false},
      w_periscope = {name = "PERISCOPE", value = "None", range = {"Default", "ALT", "None"}, q = false},
      w_radar = {name = "RADAR", value = "None", range = {"Default", "ALT", "None"}, q = false},
      w_refresh = {name = "GUI REFRESH RATE", value = 0.01, range = {0.001,1}, step = {0.001, 0.01, 0.1}, increment = 0.001, q = false},
     },
     KP = {
      w_title = "KEYBIND PARAMETERS",
      w_pos = {x=1065, y=50},
      w_open = true,
      [1] = 'flM',
      [2] = 'pkM',
      [3] = 'pMS',
      [4] = 'separator',
      [5] = 'iCo',
      [6] = 'mCI',
      [7] = 'kWU',
      [8] = 'dTT',
      [9] = 'shL',
      [10] = 'geL',
      [11] = 'bTM',
      [12] = 'separator',
      [13] = 'mvL',
      [14] = 'viL',
      [15] = 'separator',
      [16] = 'moC',
      [17] = 'mCS',
      [18] = 'separator',
      [19] = 'flightModeKB',
      [20] = 'mouseControlKB',
      [21] = 'movementLockKB',
      [22] = 'altitudeAP',
      [23] = 'viewLockKB',
      [24] = 'speedLockKB',
      [25] = 'showScreenKB',
      flM = {name = "FLIGHT MODE", value = "TRAVEL", range = {"CRUISE","TRAVEL","PLATFORM","DRONE"}, q = true},
      pkM = {name = "PARKING MODE", value = "PLATFORM", range = {"PLATFORM","DRONE","OFF"}, q = true},
      pMS = {name = "PARKING MAX SPEED", value = 50, range = {0,29999}, step = {1, 10, 100}, increment = 1, q = false},
      iCo = {name = "QE/AD INVERT", value = false, q = false},
      mCI = {name = "Y Axis Invert", value = false, q = false},
      kWU = {name = "KEYPRESS WARMUP", value = 0.1, range = {0.1,10.0}, step = {0.1, 1}, increment = 0.1, q = false},
      dTT = {name = "DOUBLE TAP TIME", value = 0.25, range = {0.01,1}, step = {0.01, 0.1}, increment = 0.01, q = false},
      shL = {name = "SHIFT LOCK", value = false, q = false},
      geL = {name = "G TOGGLES PARKING", value = false, q = false},
      bTM = {name = "BRAKE TOGGLE MODE", value = false, q = false},
      mvL = {name = "FREEZE MOVEMENT", value = false, q = false},
      viL = {name = "FREEZE VIEW", value = false, q = false},
      moC = {name = "MOUSE CONTROL", value = false, q = false},
      mCS = {name = "M-C SENSITIVITY", value = 0.3, range = {0.01,10}, step = {0.01,0.1, 1}, increment = 0.1, q = false},
      flightModeKB = {name = "FLIGHT MODE KB", value = "ALT+3", range = {"ALT+3","ALT+4","ALT+5","ALT+6","ALT+7","ALT+8","ALT+9", "None"}, q = false},
      mouseControlKB = {name = "MOUSE CONTROL KB", value = "ALT+4", range = {"ALT+3","ALT+4","ALT+5","ALT+6","ALT+7","ALT+8","ALT+9", "None"}, q = false},
      movementLockKB = {name = "MOVEMENT FREEZE KB", value = "ALT+5", range = {"ALT+3","ALT+4","ALT+5","ALT+6","ALT+7","ALT+8","ALT+9", "None"}, q = false},
      altitudeAP = {name = "10％ Atmo KB", value = "ALT+6", range = {"ALT+3","ALT+4","ALT+5","ALT+6","ALT+7","ALT+8","ALT+9", "None"}, q = false},
      viewLockKB = {name = "VIEW FREEZE KB", value = "ALT+7", range = {"ALT+3","ALT+4","ALT+5","ALT+6","ALT+7","ALT+8","ALT+9", "None"}, q = false},
      speedLockKB = {name = "ATMO SPEED LOCK KB", value = "ALT+8", range = {"ALT+3","ALT+4","ALT+5","ALT+6","ALT+7","ALT+8","ALT+9", "None"}, q = false},
      showScreenKB = {name = "SHOW HUDS KB", value = "ALT+9", range = {"ALT+3","ALT+4","ALT+5","ALT+6","ALT+7","ALT+8","ALT+9", "None"}, q = false},
     },
     Widgets_Custom = {
      w_title = "CUSTOM WIDGETS",
      w_pos = {x=1330, y=50},
      w_open = true,
     },
     Widget_Info = {
      w_title = "INFO",
      w_pos = {x=0, y=0},
      w_open = true,
      w_scale = 1,
     },
     QuickToolBar = {
      w_title = "QUICK TOOL BAR",
      w_pos = {x=770, y=500},
      w_open = false
     },
     help_menu = {
      w_title = "HELP",
      w_pos = {x=720, y=580},
      w_open = false,
      w_html = "INSTRUCTION MANUAL",
      [1] = 'separator',
      [2] = 'Info_Page',
      [3] = 'separator',
      [4] = 'separator',
      [5] = 'MS',
      [6] = 'separator',
      [7] = 'ES',
      [8] = 'separator',
      [9] = 'AS',
      [10] = 'separator',
      [11] = 'WS',
      [12] = 'separator',
      [13] = 'KP',
      [14] = 'separator',
      [15] = 'QuickToolBar',
      [16] = 'separator',
      [17] = 'separator',
      Info_Page = {name = "INSTRUCTION MANUAL", html = ""},
      MS = {name = "MENU SETTINGS", html = ""},
      ES = {name = "ENGINES SETTINGS", html = ""},
      AS = {name = "AUTOPILOT SETTINGS", html = ""},
      WS = {name = "WIDGET SETTINGS", html = ""},
      KP = {name = "KEYBIND PARAMS", html = ""},
      QuickToolBar = {name = "QUICK TOOL BAR", html = ""}
     }
    }
    script = {}
    script = {
     version = "v0.9.9",
     start = function()
      system.print("Script initialisation started")
      onStartParams()
      system.print("On start P loaded")
      getGlobals()
      system.print("Globals loaded")
      system.print("Closest planet: "..Helios[closestPlanetIndex].name[1])
      script.onTickData()
      setParamsFuelTanks()
      system.print("Fuel tanks loaded: "..#fuelTanksData)
      loadParamsFromDB()
      previousPreset = P.MS.PRESET.value
      loadColorPreset()
      updateHelpMenu()
      system.print("Help menu updated")
      paramsSetColorsRange()
      system.print("Color range updated")
      WindowLib:winlibCSSUpdate()
      system.print("Winlibcss updated")
      if P.w_open == true then windowsShow() else windowsHide() end
      system.print("Widgets display updated")
      WindowLib:update()
      system.print("Winlib updated")
      updateParams()
      updateEngines()
      system.print("Params updated")
      if P.ES.eng.value == "ON" then enginesToggle() end
      system.print("Script initialisation successfull")
      hasFinishedLoading = true
      --help.print(system)
      unit.setTimer("DATA",0.5)
      unit.setTimer("SCREEN",P.WS.w_refresh.value)
      unit.setTimer("FPS",1)
      unit.setTimer("BACKUP",30)
     end,

     stop = function()
      system.print("Saving parameters into Databank")
      if reset == false and hasFinishedLoading == true then setParams2DB() end 
      reset = false
      windowsHide()
      system.showScreen(0)
      if #switch ~= 0 then switch_1.deactivate() end
     end,

     onUpdate = function()
      if ALT == false and P.w_open == false and P.QuickToolBar.w_open == false then--and Engines == true then
       Nav:throttleUpdate()
      end
      if ALT == true or P.w_open == true or P.QuickToolBar.w_open == true then WindowLib:update() end
      if WindowLib.wlib_drag == true then WindowLib:performDrag() end
      
      if P.KP.moC.value == true and P.w_open == false and ALT == false then
       mouseControlUpdate()
      end
      if P.w_open == true or P.QuickToolBar.w_open == true then
       system.lockView(1)
      elseif P.KP.moC.value == true and ALT == true then
       system.lockView(0)
      end
      currentTime = system.getArkTime()
      uCount = uCount + 1
      updateGyro()
      updateGear()
      unitData.maxBrake = construct.getMaxBrake()
      unitData.currentBrake = construct.getCurrentBrake()
     end,

     onTickData = function()
      local ind = 1
      local function decodeJSON(json)
       local decodedInput = string.gsub(json, "%\\u(%x%x%x%x)", function(a) return utf8.char(tonumber(a,16))end)
       return load('return ' .. decodedInput:gsub('[[]', '{'):gsub('[]]', '}'):gsub('"(%w+)":', '["%1"]='))()
      end
      getGlobals()
      fuelTanksData = {}
      if fueltanks then
       for i , v in ipairs(fueltanks) do
        fuelTanksData[i] = {}
        local decodeFT = decodeJSON(v.getWidgetData())
        fuelTanksData[i].name = decodeFT.name or "LOADING"
        fuelTanksData[i].percentage = decodeFT.percentage or 0.01
        fuelTanksData[i].timeLeft = decodeFT.timeLeft ~= "n/a" and decodeFT.timeLeft or 0.01
       end
      end
      if DB_1 ~= nil and DB_1.getStringValue("fueltanks") and DB_1.getStringValue("fueltanks") ~= "" then
       local function merge(t1, t2)
        if type(t1) ~= "table" or type(t2)~= "table" then return nil end
        local newT = t1
        for k,v in pairs(t2) do
         newT[ind] = v
         ind = ind + 1
        end 
        return newT
       end
       fuelTanksData = merge(fuelTanksData,Data:deserialize(DB_1.getStringValue("fueltanks"))) or fuelTanksData
      end
      local ftdl = #fuelTanksData
      if ftdl ~= 0 then table.sort(fuelTanksData, function(a,b) return a.name < b.name end) end
      if prevFTD ~= ftdl and ftdl ~= 0 then
       setParamsFuelTanks()
      end
      prevFTD = ftdl
      local decodeCU = decodeJSON(unit.getWidgetData())
      unitData.acceleration = decodeCU.acceleration or 0
      unitData.maxBrake = construct.getMaxBrake()
      unitData.currentBrake = construct.getCurrentBrake()
      unitData.atmoThrust = decodeCU.atmoThrust or 0
      unitData.spaceThrust = decodeCU.spaceThrust or 0
      unitData.unitOverLoad = decodeCU.showOverload or 0
      local gMS = construct.getMaxSpeedPerAxis()
      unitData.maxSpeedMPS = math.max(gMS[1],math.abs(gMS[2]),gMS[3],math.abs(gMS[4]),gMS[5],math.abs(gMS[6]))
      unitData.maxSpeedkph = unitData.maxSpeedMPS * 3.6
      Nav:updateMaxSpeed(unitData.maxSpeedkph)
      if antigrav then
       local decodeAGG = decodeJSON(antigrav.getWidgetData())
       aggData.Power = decodeAGG.antiGPower ~= nil and math.floor(decodeAGG["antiGPower"]*100) or 0
       aggData.Field = decodeAGG.antiGravityField ~= nil and math.floor(decodeAGG["antiGravityField"]*100).."Es" or "LOADING"
       aggData.Compensation = math.floor(antigrav.getCompensationRate()*1000)/10 .."％" or "N/A"
       aggData.Altitude = decodeAGG.baseAltitude ~= nil and decodeAGG.baseAltitude or 0
       aggData.State = antigrav.isActive() == true and "ON" or "OFF"
      end
      if warpdrive then
       local decodeW = decodeJSON(warpdrive.getWidgetData())
       warpData.Info = decodeW.buttonMsg or "LOADING"
       warpData.Cells = decodeW.cellCount or 0
       warpData.Destination = decodeW.destination or "LOADING"
       warpData.Distance = decodeW.distance or "LOADING"
      end
      local dockingmode = 1
      if P.AS.dok.value == "CLOSEST" then dockingmode = 2 elseif P.AS.dok.value == "OWNER" then dockingmode = 3 end
      if construct.getDockingMode() ~= dockingmode then construct.setDockingMode(dockingmode) end
     end,

     onTickScreen = function()
      if ALT == false and P.w_open == false and P.QuickToolBar.w_open == false then WindowLib:update() end
     end,

     luaInput = function(text)
      if string.sub(text,1,5) == "reset" then
       if #DB == 0 then
        system.print("No DB Detected, Attach Databank and re-load flight script from file.")
        return
       end
       if text:lower() == "reset all" then
        Data:ResetAll()
        system.print("Databank has been reset, please re-join the piloting controller.") 
        reset = true 
        unit.exit()
       elseif string.sub(text,1,11) == "reset other"  then
        WipeAndReSave()
       else
        ResetUser()
       end
      elseif string.sub(text,1,6) == "::pos{" then
       local px, py, pz = convertToWorldCoordinates(text)
       system.print(px.." : "..py.." : "..pz)
      elseif text:lower() == "help" then 
       help.print(system) 
      end
      
      for i, widget in ipairs(customWidgets) do
       if type(customWidgets[i].onInputText) == 'function' then
        local _ = processPcall(pcall(function() return customWidgets[i]:onInputText(text) end))
       end
      end

     end,

     receive = function(channel,message)
     end,

     onActionStart = function(action)
      keyBindsOnStartControl(action)
     end,

     onActionStop = function(action)
      keyBindsOnStopControl(action)
     end,

     onActionLoop = function(action)
      keyBindsOnLoopControl(action)
     end,
    }
    script.start()

  onStop:
   lua: |
    script.stop()

  onTimer:
   args: ["DATA"]
   lua: |
    script.onTickData()

  onTimer:
   args: ["SCREEN"]
   lua: |
    script.onTickScreen()

  onTimer:
   args: ["FPS"]
   lua: |
    fps = uCount
    uCount = 0

  onTimer:
   args: ["BACKUP"]
   lua: |
    if reset == false and hasFinishedLoading == true then setParams2DB() end

 system:
  onUpdate:
   lua: |
    script.onUpdate()
  onFlush:
   lua: |
    thrustManager()
    
  onActionStart(action):
   lua: |
    script.onActionStart(action)
    
  onActionStop(action):
   lua: |
    script.onActionStop(action)
     
  onActionLoop(action):
   lua: |
    script.onActionLoop(action)
    
  onInputText(text):
   lua: |
    script.luaInput(text)
    
  onActionStart:
   args: [booster]
   lua: |
    unit.setEngineThrust('rocket_engine',1)
    system.print("boosters on")
    if Nav:getMasterMode() == "CRUISE" then
     PreviousMasterMode = "CRUISE"
     Nav:setMasterMode("TRAVEL")
    end
    boosterInput = 1
    Nav:setThrottleValue(1)
    
  onActionStop:
   args: [booster]
   lua: |
    boosterInput = 0
    unit.setEngineThrust('rocket_engine',0)
    if PreviousMasterMode == "CRUISE" then Nav:setMasterMode("CRUISE") end
    system.print("boosters off")
    
  onActionLoop:
   args: [booster]
   lua: |
    if xyzSpeedKPH > P.AS.rMS.value and inAtmo and boosterInput == 1 then
     unit.setEngineThrust('rocket_engine',0)
     if PreviousMasterMode == "CRUISE" then Nav:setMasterMode("CRUISE") end
     boosterInput = 0
     system.print("boosters off")
    end


 library:
  onStart:
   lua: |
    -- Data --
    dtbk = {}
    dtbk.__index = dtbk;
    function dtbk.new(bank)
     local self = setmetatable({}, dtbk)
     self.DB = bank
     self.concat = table.concat
     return self
    end
    function dtbk.getString(self,tag)
     return self.DB.getStringValue(tag)
    end
    function dtbk.setString(self,tag,value)
     self.DB.setStringValue(tag,value)
    end
    function dtbk.setData(self,tag,value)
     local str = self:serialize(value)
     self.DB.setStringValue(tag,str)
    end
    function dtbk.remove(self,key)
     self.DB.clearValue(key)
    end
    function dtbk.getData(self,tag)
     local str = self:deserialize(self.DB.getStringValue(tag))
     return str
    end

    function dtbk.getLen(self,user)
     user = user==nil and 0 or user
     --system.print("user="..tostring(user))
     if not self.DB then return end
     local dbKeys = self.DB.getKeyList()
     local dbs = {}
     for i,v in ipairs(dbKeys) do
      local s = self.DB.getStringValue(v)
      --system.print(v.."="..user.."="..tostring(v==user))
      if v ~= user then dbs[#dbs+1] = v.."="..s.."," end
     end
     return #table.concat(dbs)
    end

    function dtbk.ResetAll(self)
     self.DB.clear()
    end

    function dtbk.internalSerialize(self,table, tC, t)
     t[tC] = "{"
     tC = tC + 1
     if #table == 0 then
      local hasValue = false
      for key, value in pairs(table) do
       hasValue = true
       local keyType = type(key)
       if keyType == "string" then t[tC] = key .. "="
       elseif keyType == "number" then t[tC] = "[" .. key .. "]="
       elseif keyType == "boolean" then t[tC] = "[" .. tostring(key) .. "]="
       else t[tC] = "notsupported="
       end
       tC = tC + 1
       local check = type(value)
       if check == "table" then tC = self:internalSerialize(value, tC, t)
       elseif check == "string" then t[tC] = '"' .. value .. '"'
       elseif check == "number" then t[tC] = value
       elseif check == "boolean" then t[tC] = tostring(value)
       else t[tC] = '"Not Supported by Deserializer"'
       end
       t[tC + 1] = ","
       tC = tC + 2
      end
      if hasValue then
       tC = tC - 1
      end
     else
      for i = 1, #table do
       local value = table[i]
       local check = type(value)
       if check == "table" then tC = self:internalSerialize(value, tC, t)
       elseif check == "string" then t[tC] = '"' .. value .. '"'
       elseif check == "number" then t[tC] = value
       elseif check == "boolean" then t[tC] = tostring(value)
       else t[tC] = '"Not Supported by Deserializer"'
       end
       t[tC + 1] = ","
       tC = tC + 2
      end
      tC = tC - 1
     end
     t[tC] = "}"
     return tC
    end
    function dtbk.serialize(self,value)
     local t = {}
     local check = type(value)
     if check == "table" then
      self:internalSerialize(value, 1, t)
     elseif check == "string" then
      return '"' .. value .. '"'
     elseif check == "number" then
      return value
     elseif check == "boolean" then
      return tostring(value)
     else
      return '"Not Supported by Deserializer"'
     end
     return self.concat(t)
    end
    function dtbk.deserialize(self,s)
     return load("return " .. s)()
    end

    function ResetUser()
     local user = player.getId()
     local masterUser = Data:getData("masterUserID")
     Data:remove(tostring(user))
     if masterUser and masterUser == user then
      Data:remove("masterUserID")
     end
     system.print("Player: "..system.getPlayerName(user).."'s data has been reset") 
     reset = true 
     unit.exit()
    end

    function WipeAndReSave()
     Data:ResetAll()
     setParams2DB()
     system.print("current user is now the only profile on databank")
    end

    function checkMasterUser()
     if not Data:getData("masterUserID") then system.print("Setting Master user"); Data:setData("masterUserID",player.getId()) end
     return Data:getData("masterUserID")
    end

    local function currentUser()
     local masterUser = checkMasterUser()
     local userID = player.getId()
     local userName = player.getName()
     if not PerUserSaves and masterUser and masterUser ~= userID then --perUserSaves turned off, and I'm not master user
      local d2L = Data:getData(tostring(player.getId()))
      if not d2L or type(d2L) ~= "table" then --if my data not found then I'm now "Other" user
       userID = 0
       userName = "Other"
      end
     end
     return userID, userName, masterUser
    end

    local function tableLen(t)
     local l = 0; 
     if type(t) == "table" then for _ in pairs(t) do l=l+1 end end
     return l
    end


    dP = {} -- params duplicate
    dC = {} -- colorPresets duplicate
    PerUserSaves = true --export: Save ALL users separately false = other users share one profile
    function setParams2DB()
     if #DB ~= 0 then
      local cP2S = {}
      for i, v in pairs(colorPresets) do
       local preset = {}
       for k, l in pairs(colorPresets[i]) do
        if l ~= dC[i][k] then preset[tostring(k)] = l end
       end
       if tableLen(preset) > 0 then cP2S[tostring(i)] = preset end
      end

      local data2Save = {
      ["V"] = script.version,
      ["CP"] = cP2S,
      }
      local function cAs(k,a,b) --compare and save
       sa,sb = a,b
       if k == "MSWCA_v" then system.print(sa.."="..sb) end
       if type(a) == "table" then sa=Data:serialize(a); sb=Data:serialize(b) end
       if sa ~= sb then data2Save[tostring(k)] = a end
      end
      cAs("MBP",P.w_pos,dP.w_pos)
      cAs("QMP",P.QuickToolBar.w_pos,dP.QuickToolBar.w_pos)
      cAs("MBO",P.w_open,dP.w_open)
      cAs("HMP",P.help_menu.w_pos,dP.help_menu.w_pos)
      cAs("HMO",P.help_menu.w_open,dP.help_menu.w_open)

      for i, v in ipairs(P) do
       if P[v].w_pos ~= nil then
        if Data:serialize(P[v].w_pos) ~= Data:serialize(dP[v].w_pos) then data2Save[tostring(v).."_w_p"] = P[v].w_pos end
        if P[v].w_open ~= dP[v].w_open then data2Save[tostring(v).."_w_o"] = P[v].w_open end
       end
       for k, l in ipairs(P[v]) do
        if P[v][l] then
         if P[v][l].value ~= nil then
          if type(P[v][l].value) ~= "function" and P[v][l].value ~= dP[v][l].value then
           data2Save[tostring(v)..tostring(l).."_v"] = P[v][l].value
          end
          if P[v][l].q ~= dP[v][l].q then data2Save[tostring(v)..tostring(l).."_q"] = P[v][l].q end
         end
        end
       end
      end
      for k, v in pairs(P) do
       if string.sub (tostring(k),1,7) == "Widget_" then
        cAs(tostring(k).."_w_p",P[k].w_pos,dP[k].w_pos)
        cAs(tostring(k).."_w_o",P[k].w_open,dP[k].w_open)
        cAs(tostring(k).."_w_s",P[k].w_scale,dP[k].w_scale)
       end
      end
      cAs("E",Engines,false)
      cAs("CT",Nav:getThrottleValue(),0)

      local userId, userName, _ = currentUser()
      local id = tostring(userId)
      local dblen = Data:getLen(id)
      local len = string.len(id.."="..Data:serialize(data2Save))
      if len+dblen > 29900 then system.print("Databank too full to save more data")
      else
       Data:setData(id,data2Save)
       --system.print(userName.."'s data saved: "..len.." characters")
      end

      --Custom Widget Saving
      for i, widget in ipairs(customWidgets) do
       if type(customWidgets[i].saveData) == 'function' then
        local _ = processPcall(pcall(function() return customWidgets[i]:saveData() end))
       end
      end

     end
    end

    local function deep_copy(original)
     local copy = {}
     for key, value in pairs(original) do
      if type(value) == "table" then
       copy[key] = deep_copy(value)
      else
       copy[key] = value
      end
     end
     return copy
    end

    local masterDataID = true --export: will use owner's data as default for new users
    function loadParamsFromDB()
     dP = deep_copy(P)
     dC = deep_copy(colorPresets)
     local SP = system.print
     local PE = function(t) SP(t.." data corrupted: using default parameter") end --print error message
     if #DB ~= 0 then
      SP("Initiating Databank loading")
      local userId, userName, masterUser = currentUser()
      local d2L = Data:getData(tostring(userId))

      local nU = false --new User using master profile
      if not d2L and masterDataID == true then
       nU = true 
       d2L = Data:getData(tostring(masterUser))
      end

      if d2L and type(d2L) == "table" then
       SP("Loading parameters from Databank")
       if nU == false then
        val = d2L["MBP"]
        if type(val) == "table" then
         P.w_pos = vec2(val)
        end
        val = d2L["QMP"]
        if type(val) == "table" then
         P.QuickToolBar.w_pos = vec2(val)
        end
        val = d2L["MBO"]
        if type(val) == "boolean" then
         P.w_open = val
        end
        val = d2L["CP"]
        if type(val) == "table" then
         for i, v in pairs(val) do
          for k, l in pairs(v) do
           if val[i][k] then
            colorPresets[i][k] = l
           end
          end
         end
        end
        val = d2L["HMP"]
        if type(val) == "table" then
         P.help_menu.w_pos = vec2(val)
        end
        val = d2L["HMO"]
        if type(val) == "boolean" then
         P.help_menu.w_open = val
        end
       end
       for i, v in ipairs(P) do
        if P[v].w_pos ~= nil then
         if type(d2L[tostring(v).."_w_p"]) == "table" and nU == false then
          P[v].w_pos = vec2(d2L[tostring(v).."_w_p"])
         end
         if type(d2L[tostring(v).."_w_o"]) == "boolean" and nU == false then
          P[v].w_open = d2L[tostring(v).."_w_o"]
         end
        end
        for k, l in ipairs(P[v]) do
         if P[v][l] then
          if P[v][l].value ~= nil then
           if type(P[v][l].value) ~= "function" then
            val = d2L[tostring(v)..tostring(l).."_v"]
            if type(val) == type(P[v][l].value) then
             P[v][l].value = val
            end
           end
           val = d2L[tostring(v)..tostring(l).."_q"]
           if type(val) == "boolean" then
            P[v][l].q = val
           end
          end
         end
        end
       end
       for i, v in pairs(P) do
        if string.sub(tostring(i),1,7) == "Widget_" then
         val = d2L[tostring(i).."_w_p"]
         if type(val) == "table" and nU == false then
          P[i].w_pos = vec2(val)
         end
         val = d2L[tostring(i).."_w_o"]
         if type(val) == "boolean" then
          P[i].w_open = val
         end
         val = d2L[tostring(i).."_w_s"]
         if type(val) == "number" and nU == false then
          P[i].w_scale = val
         end
        end
       end
       val = d2L["CT"]
       if type(val) == "number" then
        Nav:setThrottleValue(val)
       end
       val = d2L["E"]
       if type(val) == "boolean" then
        Engines = val
       end
       val = nil
       d2L = nil
       SP(userName.."'s data loaded successful.")

      else SP("No data found for player: "..userName.."! Loading default paramters")
      end
     end
    end
  onStart:
   lua: | 
    -- Widgets --
    local utils = require("cpml/utils")
    local abs, floor, format, sub, acos, sqrt, cos, sin, deg, ceil, clamp ,sign= math.abs, math.floor, string.format, string.sub, math.acos, math.sqrt, math.cos, math.sin, math.deg, math.ceil, utils.clamp, utils.sign
    local widget_font = "Play"

    WidgetsPlusPlus = {}
    WidgetsPlusPlus.__index = WidgetsPlusPlus

    function WidgetsPlusPlus.new()
     local self = setmetatable({}, WidgetsPlusPlus)
     self.width = system.getScreenWidth()
     self.height = system.getScreenHeight()
     -- HUD Setup -- 
     self.hudSVGSize = {x=1600,y=1000}
     P.Widget_HUD = {
      w_title = "HUD",
      w_pos = {x=self.width/2 -self.hudSVGSize.x/2, y=self.height/2 -self.hudSVGSize.y/2},
      w_size = self.hudSVGSize,
      w_open = true,
      w_scale = 1
     }
     -- Platform HUD Setup -- 
     self.platSVGSize = {x=204,y=104}
     local scale = 2
     P.Widget_Platform = {
      w_title = "Platform",
      w_pos = {x=self.width/2 -(self.platSVGSize.x*scale)/2, y=self.height*0.9 -(self.platSVGSize.y*scale)},
      w_size = self.platSVGSize,
      w_open = false,
      w_scale = scale
     }
     return self
    end

    local function toSu(v)
     return v == nil and 0 or v <= 10000 and format("%.0f",v).."m" or v > 10000 and format("%.1f",v/1000).."km" or v > 50000 and format("%.2f",v/200000).."su" or 0
    end
    local function altF(v)
     return alt < 200000 and toSu(v) or "space"
    end

    -- HUD Widget --
    local SVGfuelText = {}
    local SVGfuelTextBool = {}
    local fuelCounter = 1

    function WidgetsPlusPlus.HUD_Update(self)
     local WFC = P.MS.WFC.value
     local WTC = P.MS.wTC.value
     local WAC = P.MS.wAC.value
     local WCA = P.MS.WCA.value
     local WC = P.MS.WC.value
     local temp1 = [[ font-family="]]..widget_font..[[" alignment-baseline="middle" stroke-width="0" fill="]]..WTC..[[">]]
     local SVGfinal = ""
     local SVGfixed = [[
      <clipPath id="clipcircle400"><rect x="0" y="300" width="1600" height="400" /></clipPath>
      <circle cx="800" cy="500" r="600" stroke-width="2" stroke="]]..WFC..[[" fill="none" clip-path="url(#clipcircle400)"/>
      <line id="bar1600" x1="235" y1="300" x2="214" y2= "300" stroke-width="2" stroke="]]..WFC..[["/>
      <use xlink:href="#bar1600" transform="rotate(180 800 500)"/>
      <line id="bar2600" x1="235" y1="700" x2="214" y2= "700" stroke-width="2" stroke="]]..WFC..[["/>
      <use xlink:href="#bar2600" transform="rotate(180 800 500)"/>
      <line x1="200" y1="500" x2="180" y2= "500" stroke-width="2" stroke="]]..WFC..[["/>
      <polygon id="triangle600" points="200 500, 201 505, 212 500, 201 495" stroke-width="0" fill="]]..WFC..[["/>
      <use xlink:href="#triangle600" transform="rotate(180 800 500)"/>
      <line x1="770" y1="500" x2="790" y2= "500" stroke-width="2" stroke="]]..WFC..[["/>
      <line x1="810" y1="500" x2="830" y2= "500" stroke-width="2" stroke="]]..WFC..[["/>
      <line x1="800" y1="470" x2="800" y2= "490" stroke-width="2" stroke="]]..WFC..[["/>
      <line x1="800" y1="510" x2="800" y2= "530" stroke-width="2" stroke="]]..WFC..[["/>
      <polygon points="800 897.5, 807 887.5, 793 887.5" stroke-width="0" fill="]]..WFC..[["/>
     ]]
     
     local st = 'width="120" height="40" stroke="none" fill="'..WC..'" fill-opacity="'..WCA..'"'
     local p0 = '<rect x="215" y="480" '..st..'/><rect x="1265" y="480" '..st..'/>'

     local b1, b2, b3 = 'stroke:', ';stroke-dasharray: 4, 4; stroke-dashoffset: ', 'px;'
     local p1 = [[<g fill="none" style="]]
     local p2 = [[;">
      <polyline points="215,480 335,480 335,520 215,520 215,480 "/>
      <polyline points="1265,480 1385,480 1385,520 1265,520 1265,480 "/>
     </g>]]
     local SVGrecindicator = p0..p1..'stroke:'..WFC..';'..p2
     if Engines == false then
      SVGrecindicator = p0..p1..b1..'red'..b2.. 2 ..b3..p2..p1..b1..'black'..b2.. 6 ..b3..p2
     elseif brakeInput == 1 then
      SVGrecindicator = p0..p1..b1..'red'..b2.. 2 ..b3..p2
     end

     local SVGaltitude = [[
      <text x="275" y="500" font-size="20" text-anchor="middle"]]..temp1..altF(alt)..[[</text>
     ]]
     local throttleText = 0
     if MM == "TRAVEL" then 
      throttleText = clamp(ThrottlePos,-100,100)
      throttleText = format("%.0f", throttleText*100).."％"
     else 
      throttleText = clamp(ThrottlePos,-unitData.maxSpeedkph,unitData.maxSpeedkph)
      throttleText = format("%.0f", throttleText).." km/h"
     end
     local xyzSpeedText = format("%.0f", xyzSpeedKPH).." km/h"
     if xyzSpeedKPH > 50000 then xyzSpeedText = "FTL" end
     local throttleClipY = 0
     local tPos = 0
     if MM == "TRAVEL" then
      tPos = clamp(ThrottlePos,-1,1)
      throttleClipY = 700 - 400 * floor(abs(tPos)*100)/100
     else tPos = clamp(ThrottlePos,-unitData.maxSpeedkph,unitData.maxSpeedkph)
      throttleClipY = 700 - 400 * abs(tPos)/unitData.maxSpeedkph
     end
     local currentThrust = 0
     if inspace == 0 then currentThrust = unitData.atmoThrust
     else currentThrust = unitData.spaceThrust
     end
     local forwardEnginesForce = Nav:maxForceForward()

     -- Brake Distance Hud
     local fBD, bBD = brakingCalculation()
     fBD = toSu(fBD)

     -- Flight Mode/SubMode
     local fM = ""
     if parkingEligible() then
      local fMMs, fPMs = "",""
      if pkM then 
       fMMs = [[class="strike"]]
       fPMs = [[class="bold"]]
      else
       fMMs = [[class="bold"]]
       fPMs = [[class="strike"]]
      end
      fM = [[<text x="1400" y="690" font-size="20" ]]..fMMs..[[ text-anchor="start"]]..temp1..P.KP.flM.value..[[</text>
      
      <text x="1420" y="710" font-size="14" ]]..fPMs..[[ text-anchor="start"]]..temp1..P.KP.pkM.value..[[</text>]]
     else
      fM = [[<text x="1400" y="700" font-size="20" text-anchor="start"]]..temp1..MM..[[</text>]]
     end

     local altLock = ""
     if HoldAltitude then 
      altLock = [[<text x="1325" y="550" font-size="12" text-anchor="middle" font-family="]]..widget_font..[[" alignment-baseline="middle" stroke-width="0" fill="red">Alt locked: ]]..HoldAltitude..[[</text>]]
     end

     local brakeClipY = 200 * unitData.currentBrake/unitData.maxBrake
     local accelClipY = 500 - 200 * currentThrust/forwardEnginesForce
     local SVGspeedo = [[
      <clipPath id="clipthrottle">
      <rect x="800" y="]]..throttleClipY..[[" width="800" height="]].. 700 - throttleClipY..[[" />
      </clipPath>
      
      <clipPath id="clipbrake">
      <rect x="0" y="500" width="800" height="]]..brakeClipY..[[" />
      </clipPath>
      
      <clipPath id="clipaccel">
      <rect x="0" y="]]..accelClipY..[[" width="800" height="]].. 500 - accelClipY..[[" />
      </clipPath>
      
      <text x="1325" y="500" font-size="20" text-anchor="middle"]]..temp1..xyzSpeedText..[[</text>
      <text x="1425" y="500" font-size="15" text-anchor="start"]]..temp1..throttleText..[[</text>
      ]]..altLock..[[
      
      <text x="170" y="500" font-size="15" text-anchor="end"]]..temp1..format("%.0f", abs(planetVertSpeedMPS))*sign(planetVertSpeedMPS).." km/h"..[[</text>
      
      ]]..fM..[[
      <text x="1395" y="300" font-size="15" text-anchor="start"]]..temp1..fBD..[[</text>

      <circle cx="800" cy="500" r="610" stroke-width="20" stroke="]]..WAC..[[" fill="none" stroke-opacity="]].. 0.25 ..[[" clip-path="url(#clipthrottle)"/>
      
      <circle cx="800" cy="500" r="610" stroke-width="20" stroke="]]..WAC..[[" fill="none" stroke-opacity="]].. 0.25 ..[[" clip-path="url(#clipbrake)"/>
      <text x="205" y="700" font-size="12" text-anchor="end"]]..temp1..format("%.0f", unitData.currentBrake/1000).." / "..format("%.0f", unitData.maxBrake/1000).."kn"..[[</text>
     
      <circle cx="800" cy="500" r="610" stroke-width="20" stroke="]]..WAC..[[" fill="none" stroke-opacity="]].. 0.25 ..[[" clip-path="url(#clipaccel)"/>
      <text x="205" y="300" font-size="12" text-anchor="end"]]..temp1..format("%.0f", currentThrust/1000).." / "..format("%.0f", forwardEnginesForce/1000).."kn"..[[</text>
     ]]
     local b10,b11 = [[<use xlink:href="]],[[" transform="rotate(]]
     local b20,b21 = b10.."#bankthick"..b11,b10.."#bankthin"..b11
     local SVGbank = [[
      <clipPath id="clipbankcircle400">
      <rect x="0" y="300" width="1600" height="400"/>
      </clipPath>
      <circle cx="800" cy="500" r="400" stroke-width="5" stroke="]]..WFC..[[" fill="none" clip-path="url(#clipbankcircle400)" transform="rotate(]]..Ay0..[[ 800 500)"/>
      <polygon id="triangle400" points="400 500, 402 505, 412 500, 402 495" stroke-width="0" fill="]]..WFC..[[" transform="rotate(]]..Ay0..[[ 800 500)"/>
      <use xlink:href="#triangle400" transform="rotate(180 800 500)"/>
      
      <line id="bankthick" x1="800" y1="97.5" x2="800" y2= "102.5" stroke-width="5" stroke="]]..WFC..[["/>
      ]]..b20..[[10 800 500)"/>
      ]]..b20..[[20 800 500)"/>
      ]]..b20..[[30 800 500)"/>
      
      ]]..b20..[[-10 800 500)"/>
      ]]..b20..[[-20 800 500)"/>
      ]]..b20..[[-30 800 500)"/>
      
      <polygon id="banktriangle" points="800 97.5, 807 87.5, 793 87.5" stroke-width="0" fill="]]..WFC..[[" transform="rotate(]]..Ay0..[[ 800 500)"/>
      <use xlink:href="#banktriangle" transform="rotate(180 800 500)"/>
      
      <line id="bankthin" x1="800" y1="100" x2="800" y2= "102.5" stroke-width="1" stroke="]]..WFC..[["/>
      ]]..b21..[[2.5 800 500)"/>
      ]]..b21..[[5 800 500)"/>
      ]]..b21..[[7.5 800 500)"/>
      ]]..b21..[[12.5 800 500)"/>
      ]]..b21..[[15 800 500)"/>
      ]]..b21..[[17.5 800 500)"/>
      ]]..b21..[[22.5 800 500)"/>
      ]]..b21..[[25 800 500)"/>
      ]]..b21..[[27.5 800 500)"/>
    
      ]]..b21..[[-2.5 800 500)"/>
      ]]..b21..[[-5 800 500)"/>
      ]]..b21..[[-7.5 800 500)"/>
      ]]..b21..[[-12.5 800 500)"/>
      ]]..b21..[[-15 800 500)"/>
      ]]..b21..[[-17.5 800 500)"/>
      ]]..b21..[[-22.5 800 500)"/>
      ]]..b21..[[-25 800 500)"/>
      ]]..b21..[[-27.5 800 500)"/>
      
      <text x="800" y="70" font-size="12" transform="rotate(]]..Ay0..[[ 800 500)" text-anchor="middle"]]..temp1..format("%.0f", abs(Ay0))*utils.sign(Ay0).."°"..[[</text>
     ]]     

     local AHT = sign(Ax0) * abs(Ax0) / 90 * 400
     local SVGpitchbars = ""
     local i = 1
     local j = 800/18
     if alt < P.AS.stA.value then
      local temp2 = [[" font-size="12" text-anchor="middle" alignment-baseline="middle" stroke-width="0" >]]
      while (i<19) do
       if i*10 < Ax0 + 50 then
       SVGpitchbars = SVGpitchbars ..[[
       <line x1="0" y1="]].. 500 - i*j ..[[" x2="450" y2= "]].. 500 - i*j ..[[" stroke-width="]].. 2*(1-i/19) ..[[" fill="none"/>
       <text x="465" y="]].. 500 - i*j ..temp2.. i*10 ..[[</text>
       <line x1="1600" y1="]].. 500 - i*j ..[[" x2="1150" y2= "]].. 500 - i*j ..[[" stroke-width="]].. 2*(1-i/19) ..[[" fill="none"/>
       <text x="1135" y="]].. 500 - i*j ..temp2.. i*10 ..[[</text>
       ]]
       end
       if i*-10 > Ax0 - 50 then
       SVGpitchbars = SVGpitchbars ..[[
       <line x1="1600" y1="]].. 500 + i*j ..[[" x2="1150" y2= "]].. 500 + i*j ..[[" stroke-width="]].. 2*(1-i/19) ..[[" fill="none"/>
       <text x="1135" y="]].. 500 + i*j ..temp2.. i*-10 ..[[</text>
       <line x1="0" y1="]].. 500 + i*j ..[[" x2="450" y2= "]].. 500 + i*j ..[[" stroke-width="]].. 2*(1-i/19) ..[[" fill="none"/>
       <text x="465" y="]].. 500 + i*j ..temp2.. i*-10 ..[[</text>
       ]]
       end
       i = i+1
      end
      SVGpitchbars = SVGpitchbars..[[
       <line x1="0" y1="500" x2="450" y2= "500" stroke-width="3" fill="none"/>
       <text x="465" y="500]]..temp2..[[0</text>
       <line x1="1600" y1="500" x2="1150" y2= "500" stroke-width="3" fill="none"/>
       <text x="1135" y="500]]..temp2..[[0</text>
       <line x1="480" y1="500" x2="700" y2= "500" stroke-width="2" />
       <line x1="1120" y1="500" x2="900" y2= "500" stroke-width="2" />
      ]]
     end
     local SVGpitch = [[
      <clipPath id="clippitchcircle400">
      <circle cx="800" cy="500" r="400"/>
      </clipPath>
      
      <g clip-path="url(#clippitchcircle400)" stroke="]]..WFC..[[" font-family="]]..widget_font..[[" fill="]]..WFC..[[" stroke-opacity="]].. 0.25 ..[[" fill-opacity="]].. 0.5 ..[[">
        <g transform="rotate(]]..Ay0..[[ 800 500) translate(0 ]]..AHT..[[)">
      ]]..SVGpitchbars..[[
      </g></g>
      
      <text x="380" y="500" font-size="12" transform="rotate(]]..Ay0..[[ 800 500)" text-anchor="middle"]]..temp1..format("%.0f", abs(Ax0))*utils.sign(Ax0).."°"..[[</text>
     ]]
     local cAV = construct.getAbsoluteVelocity()
     local cAVx, cAVy, cAVz = norm(xSpeedKPH * 0.27777777777, ySpeedKPH * 0.27777777777, zSpeedKPH * 0.27777777777)
     local velStrokeColor = WFC
     if xyzSpeedKPH < 5 then cAVx, cAVy, cAVz = 0,0,0 else if abs(Ax) > 45 or abs(Az) > 45 then velStrokeColor = "red" end end
     local SVGvelocity = [[
     <circle cx="]].. 800+cAVx*400 ..[[" cy="]].. 500+cAVz*-400 ..[[" r="10" stroke-width="1.5" stroke="]]..velStrokeColor..[[" fill="none"/>
     <line x1="800" y1="500" x2="]].. 800+cAVx*400 ..[[" y2= "]].. 500+cAVz*-400 ..[[" stroke-width="1" fill="none" stroke="]]..velStrokeColor..[["/>
     ]]
     
     local SVGfuel = ""
     local left, right = 0,0
     for i , v in ipairs(fuelTanksData) do
      
      local fuelT = tonumber(fuelTanksData[i].timeLeft)
      local fuelTLeft = fuelT==nil and "N/A" or fuelT>1000000 and "inf" or format("%.0f", fuelT/60) .. " min" or "N/A"
      local fuelPLeft = format("%.0f", fuelTanksData[i].percentage) .. "％"
      SVGfuelText[i] =  fuelTLeft .. " ( ".. fuelPLeft .." )"
      local p6 = [[" font-family="]]..widget_font..[[" alignment-baseline="middle" stroke-width="0" fill="]]..WFC..[[" >]]..string.sub(fuelTanksData[i].name,1,7):upper()..[[</text>]]
      local p7 = [[" width="]].. 150*tonumber(fuelTanksData[i].percentage)/100 ..[[" height="15" stroke-width="1" fill="]]..WAC..[[" stroke="none" fill-opacity="]]..WCA..[["/>]]
      local p8 = [[" width="150" height="15" stroke-width="1" stroke="]]..WFC..[[" fill="none" />]]
      local p9 = [[" font-size="12" text-anchor="middle"]]..temp1..SVGfuelText[i]..[[</text>]]
      if string.sub(fuelTanksData[i].name,-1,-1) ~= "L" then
       SVGfuel = SVGfuel..[[
       <text x="1350" y="]].. 740+(i-1-left)*20 ..[[" font-size="12" text-anchor="end]]..p6..[[
       <rect x="1360" y="]].. 732+(i-1-left)*20 ..p7 ..[[
       <rect x="1360" y="]].. 732+(i-1-left)*20 ..p8 ..[[
       <text x="1445" y="]].. 740+(i-1-left)*20 ..p9 ..[[
       ]]
       right = right + 1
      else
       SVGfuel = SVGfuel..[[
       <text x="245" y="]].. 740+(i-1-right)*20 ..[[" font-size="12" text-anchor="start]]..p6..[[
       <rect x="90" y="]].. 732+(i-1-right)*20 ..p7 ..[[
       <rect x="90" y="]].. 732+(i-1-right)*20 ..p8 ..[[
       <text x="175" y="]].. 740+(i-1-right)*20 ..p9 ..[[
       ]]
       left = left + 1
      end
     end
     SVGfinal = '<div><svg viewBox="0 0 '.. self.hudSVGSize.x ..' '.. self.hudSVGSize.y ..'">'..SVGrecindicator..SVGaltitude..SVGbank..SVGspeedo..SVGfixed..SVGpitch..SVGvelocity..SVGfuel..'</svg></div>'
     return SVGfinal
    end
    -- Info Widget --
    function WidgetsPlusPlus.Info_Update(self)
     local WFC = P.MS.WFC.value
     local WTC = P.MS.wTC.value
     local WAC = P.MS.wAC.value
     local WC = P.MS.WC.value
     local WCA = P.MS.WCA.value
     local fontSize = 15
     local lS = 25
     info_window_height = 0

     local fBD, bBD = brakingCalculation()
     fBD = toSu(fBD)
     bBD = toSu(bBD)

     local t1, t2 = [[<tspan x="5" dy="]],[[" text-anchor="start" fill="]]..WFC..[[">]]
     local tmp1 = t1..lS..t2
     local tmp2 = [[</tspan><tspan x="300" dy="0" text-anchor="end" fill="]]..WTC..[[">]]
     local KeybindsSVG = [[
      <tspan x="5" text-anchor="start" fill="]]..WFC..[[">]]..'KEYBINDS:'..tmp2..''..[[</tspan>
      ]]..tmp1..'Main Menu: '..tmp2..'Alt + 1'..[[</tspan>
      ]]..tmp1..'Quck Menu: '..tmp2..'Alt + Alt Hold'..[[</tspan>
      ]]..tmp1..'AutoLand: '..tmp2..'G'..[[</tspan>
      ]]..tmp1..'Alt Lock at 11％ atmo: '..tmp2..P.KP.altitudeAP.value..'+'..P.KP.altitudeAP.value..[[</tspan>
      ]]..tmp1..'Reset Databank: lua channel '..tmp2..'reset all'..[[</tspan>
     ]]
     info_window_height = 6 * 30

     local InfoUnitSVG = [[
      ]]..t1..lS*2 ..t2..'W.POS: '..tmp2.. format("%.0f",currentWorldPos.x) ..":"..format("%.0f",currentWorldPos.y) ..":"..format("%.0f",currentWorldPos.z) ..[[</tspan>
      ]]..tmp1..'CLOSEST PLANET: '..tmp2..currentPlanetName..[[</tspan>
      ]]..tmp1..'ALTITUDE: '..tmp2..altF(alt)..[[</tspan>
      ]]..tmp1..'FLIGHT MODE: '..tmp2..MM .." MODE"..[[</tspan>
      ]]..tmp1..'OPTIMAL ORBITAL SPEED: '..tmp2..format("%.0f",math.sqrt(currentPlanetGM / (alt + currentPlanetRadius))*3.6).."kmph"..[[</tspan>
      ]]..tmp1..'MAX SPEED: '..tmp2..format("%.0f",unitData.maxSpeedkph).."kph"..[[</tspan>
      ]]..tmp1..'ACCELERATION: '..tmp2..format("%.4f",unitData.acceleration/10).."g"..[[</tspan>
      ]]..tmp1..'MAX BRAKE: '..tmp2..format("%.0f",unitData.maxBrake/1000).."kn"..[[</tspan>
      ]]..tmp1..'FORWARD BRAKE DISTANCE: '..tmp2..fBD..[[</tspan>
      ]]..tmp1..'BACKWARD BRAKE DISTANCE: '..tmp2..bBD..[[</tspan>
      ]]..tmp1..'ATMO TRHUST: '..tmp2..format("%.0f",unitData.atmoThrust/1000).."kn"..[[</tspan>
      ]]..tmp1..'SPACE TRHUST: '..tmp2..format("%.0f",unitData.spaceThrust/1000).."kn"..[[</tspan>
      ]]..tmp1..'CONSTRUCT WEIGHT: '..tmp2..format("%.2f",coreMass/1000).."tons"..[[</tspan>
      ]]..tmp1..'FPS: '..tmp2..format("%.0f",fps).."fps"..[[</tspan>
     ]]
     info_window_height = info_window_height + 12 * 30

     local InfoAGGSVG = ""
     if antigrav ~= nil then 
      InfoAGGSVG = [[
       ]]..t1..lS*2 ..t2..'ANTIGRAVITY STATE: '..tmp2..tostring(aggData.State):upper()..[[</tspan>
       ]]..tmp1..'POWER: '..tmp2..tostring(aggData.Power):upper()..[[％</tspan>
       ]]..tmp1..'FIELD: '..tmp2..tostring(aggData.Field):upper()..[[</tspan>
       ]]..tmp1..'COMPENSATION: '..tmp2..tostring(aggData.Compensation):upper()..[[</tspan>
       ]]..tmp1..'CURRENT ALTITUDE: '..tmp2..tostring(aggData.Altitude):upper().."m"..[[</tspan>
       ]]..tmp1..'SETUP ALTITUDE: '..tmp2..tostring(P.ES.agA.value):upper().."m"..[[</tspan>
      ]]
      info_window_height = info_window_height + 7 * 30
     end

     local InfoWarpSVG = ""
     if warpdrive ~= nil then
      InfoWarpSVG = [[
       ]]..t1..lS*2 ..t2..'WARP INFO: '..tmp2..tostring(warpData.Info):upper()..[[</tspan>
       ]]..tmp1..'CELLS COUNT: '..tmp2..tostring(warpData.Cells):upper()..[[</tspan>
       ]]..tmp1..'DESTINATION: '..tmp2..tostring(warpData.Destination):upper()..[[</tspan>
       ]]..tmp1..'DISTANCE: '..tmp2..format("%.1f",warpData.Distance/200000).." su"..[[</tspan>
      ]]
      info_window_height = info_window_height + 5 * 30
     end
     local InfoSVG = '<div><svg viewBox="0 0 309 '..info_window_height..'"><text x="5" y="20" font-size="'..fontSize..'" font-family="'..widget_font..'">'..KeybindsSVG..InfoUnitSVG..InfoAGGSVG..InfoWarpSVG..'</text></svg></div>'
     
     return InfoSVG
    end
    -- Platform Widget --
    function WidgetsPlusPlus.Platform_Update(self)
     local wTC = P.MS.wTC.value --widget text color
     local wAC = P.MS.wAC.value --widget animated color
     local WFC = P.MS.WFC.value --widget fixed color
     local fSW = 1.5 --fixed stroke width
     local op = 0.95 -- opacity
 
     local SVGfuel = ""
     for i , v in ipairs(fuelTanksData) do
      if i > 4 then break end --no more than 4 fuel tanks displayed
      local fuelT = tonumber(fuelTanksData[i].timeLeft)
      local fuelTLeft = fuelT==nil and "N/A" or fuelT>1000000 and "inf" or format("%.0f", fuelT/60) .. " min" or "N/A"
      local fuelPLeft = format("%.0f", fuelTanksData[i].percentage) .. "％"
      SVGfuelText[i] =  fuelTLeft .. " ( ".. fuelPLeft .." )"
      SVGfuel = SVGfuel..[[
      <rect x="125" y="]].. 85+(i-1)*-12 ..[[" width="]].. 69*tonumber(fuelTanksData[i].percentage)/100 ..[[" height="9" stroke-width="1" fill="]]..wAC..[[" stroke="none" fill-opacity="]].. 0.25 ..[["/>
      <rect x="125" y="]].. 85+(i-1)*-12 ..[[" width="69" height="9" stroke-width="]]..fSW..[[" stroke="]]..WFC..[[" fill="none" />
      <text x="160" y="]].. 90+(i-1)*-12 ..[[" font-size="6" text-anchor="middle" font-family="]]..widget_font..[[" alignment-baseline="middle" stroke-width="0" fill="]]..wTC..[[" >]]..SVGfuelText[i]..[[</text>
      ]]
     end
 
     --glass frame brackground
     local SVG_glassframe = [[
      <defs>
       <linearGradient id="grad1" x1="0" y1="0" x2="0.5" y2="0.75">
       <stop offset="0.8" style="stop-color:grey;stop-opacity:0.15" />
       <stop offset="1.2" style="stop-color:white;stop-opacity:0.1" />
       </linearGradient>
       <linearGradient id="grad2" x1="0" y1="0" x2="1" y2="1">
       <stop offset="0.1" style="stop-color:white  ;stop-opacity:0.75" />
       <stop offset="0.9" style="stop-color:grey;stop-opacity:0.5" />
       </linearGradient>
      </defs>
      <rect x="2" y="2" rx="8" ry="8" width="200" height="100" fill="url(#grad1)" stroke="none" fill-opacity="0.15" />
      <rect x="2" y="2" rx="8" ry="8" width="200" height="100" fill="none" stroke="url(#grad2)" stroke-width="2" stroke-opacity="0.5"/>
     ]]
 
     --vertical velocity bar --https://www.desmos.com/calculator/2qpxp2huaa
     local scale1 = 42 / math.log(maxSafeVel)
     local zVY = alt < 200000 and clamp(math.log(abs(planetVertSpeedMPS)+1)*scale1,0,42)*-sign(planetVertSpeedMPS) or 0
     local SVG_Zvel_fix = [[
      <rect x="10" y="10" width="15" height="84" style=" fill:none;stroke:]]..WFC..[[;stroke-width:]]..fSW..[["/>
     ]]
     local SVG_Zvel_anim = [[
      <polyline points="10,52 10,]]..format("%.1f",52+zVY)..[[ 25,]]..format("%.1f",52+zVY)..[[ 25,52" style="fill:]]..wAC..[[";stroke:"none" fill-opacity="0.25"/>
     ]]

     
     local nwVx, nwVy, nwVz = norm(wVx, wVy, wVz) -- normalized world vector (negative grav.)
     local wLx, wLy, wLz = cross(nwVx, nwVy, nwVz, cWOFx, cWOFy, cWOFz) -- world left
     local wFx, wFy, wFz = norm(cross(-nwVx, -nwVy, -nwVz, wLx, wLy, wLz)) -- world forward (forward perpendicular to grav.)
     
     local nWVx, nWVy, nWVz = norm(cWAVx, cWAVy, cWAVz) --normalized velocity vector
     local wLVx, wLVy, wLVz = cross(nwVx, nwVy, nwVz, nWVx, nWVy, nWVz) -- Velocity World Left
     local wFVx, wFVy, wFVz = norm(cross(-nwVx, -nwVy, -nwVz, wLVx, wLVy, wLVz)) -- Velocity World forward (velocity perpendicular grav)
     
     local driftAngle = acos(dotVec(wFx, wFy, wFz, wFVx, wFVy, wFVz))*constants.rad2deg
     local cx, cy, cz = cross(wFx, wFy, wFz, wFVx, wFVy, wFVz)
     if dotVec(cx, cy, cz, nwVx, nwVy, nwVz) > 0 then driftAngle = -driftAngle end

     -- Lat speed
     local pLatVel = dotVec(cWAVx, cWAVy, cWAVz, wFVx, wFVy, wFVz)
     if pLatVel < 0.1 then pLatVel = 0; driftAngle = 0 end

     local scale = 38 / math.log(maxSafeVel)
     local xVx = pLatVel and clamp(math.log(abs(pLatVel)+1)*scale,0,38)*sign(pLatVel) or 0
     if xVx ~= xVx then xVx = 0 end

     rotation = rotation and rotation < 360 and rotation + 3 or 0
     local SVG_XYvel_anim = [[<g transform="translate(75 52)">
      <g style="stroke-linecap: round; stroke-linejoin: round; " transform="rotate(]].. driftAngle-90 ..[[) translate(0 0)" fill="none" stroke="]]..wAC..[[" stroke-width="1">
       <line x1="0" y1="0" x2="]]..xVx..[[" y2="0"/>
       <rect x="]]..xVx-3 ..[[" y="-3" width="6" height="6"/>
      </g>
     </g>
     ]]
          
     local brakeStyle = 'stroke:'..WFC..';'
     local b1, b2, b3 = 'stroke:', ';stroke-dasharray: 2, 3; stroke-dashoffset: ', 'px;'
     local p1 = [[<g fill="none" style="]]
     local p2 = [[; stroke-linecap: round; stroke-linejoin: round;" stroke-width="]]..fSW..[[">
      <polyline points="33,38 33,10 61,10"/>
      <polyline points="89,10 117,10 117,38"/>
      <polyline points="117,66 117,94 89,94"/>
      <polyline points="61,94 33,94 33,66"/>
      <rect x="70" y="47" width="10" height="10"/>
     </g>]]
     local SVG_XYvel_fix = p1..brakeStyle..p2
     if Engines == false then
      SVG_XYvel_fix = p1..b1..'red'..b2.. 1 ..b3..p2..p1..b1..'black'..b2.. 3.5 ..b3..p2
     elseif brakeInput == 1 then
      SVG_XYvel_fix = p1..b1..'red'..b2.. 1 ..b3..p2
     end

     --Throttle
     local throttleClip = 0
     local tPos = 0
     if MM == "TRAVEL" then
      tPos = clamp(ThrottlePos,-1,1)
      throttleClip = 125 + 69 * floor(abs(tPos)*100)/100
     else tPos = clamp(ThrottlePos,-unitData.maxSpeedkph,unitData.maxSpeedkph)
      throttleClip = 125 + 69 * abs(tPos)/unitData.maxSpeedkph
     end
     local negThr = ThrottlePos >= 0 and 0 or 1
     local SVG_Throttle = '<polyline points="125,40 '..throttleClip..',40" style="stroke-linecap: butt; stroke-dasharray: 4, '..negThr..'; fill: none; stroke: red; stroke-opacity: 0.31; stroke-width: 4px;"/>'

     --animated text
     local gndH = Gnd.height > 0 and floor(round(Gnd.height)).."m" or " N/A"
     local SVG_text_anim = [[<g text-anchor="end" font-family="]]..widget_font..[[" alignment-baseline="bottom" stroke-width="0" fill="]]..wAC..[[">
      <text x="170" y="25" font-size="21">]]..format("%.0f",xyzSpeedKPH)..[[</text>
      <text x="195" y="17.5" font-size="10">km/h</text>
     </g>
     <g font-size="7" text-anchor="start" font-family="]]..widget_font..[[" alignment-baseline="bottom" stroke-width="0" fill="]]..wAC..[[">
      <text x="125" y="35" >alt:]]..altF(alt)..[[</text>
      <text x="169" y="35" >tel:]]..gndH..[[</text>
     </g>]]
 
     local viewBox = 'viewBox="0 0 '.. self.platSVGSize.x ..' '.. self.platSVGSize.y ..'"'
     local svgBottom = SVGfuel..SVG_Zvel_fix..SVG_XYvel_fix..SVG_XYvel_anim..SVG_Throttle..SVG_text_anim
     local svgTop = SVG_glassframe..SVG_Zvel_anim
     local SVGfinal = '<div><svg '..viewBox..' style="position:absolute; filter: drop-shadow(2px 2px 3px black);">'..svgBottom..'</svg><svg '..viewBox..' style="position:absolute;">'..svgTop..'</svg></div>'
     return SVGfinal
    end
  onStart:
   lua: |
    --minified winlib--.lua
    WLP = {}
    WLP.__index = WLP
    local DWN_Position_X = 0
    local DWN_Position_Y = 0
    local DWN_Width = 300
    local DWN_Height = 150
    local DWN_TitleBar_Height = 25
    local DBu_Position_X = 0
    local DBu_Position_Y = 0
    local DBu_Width = 96
    local DBu_Height = 24
    
    
    WLP.css = {}
    WLP.buttonsNew = {}
    
    function WLP.init()
     local self = setmetatable({}, WLP)
     self.index = 0
     self.windows = {}
     self.buttonLock = nil
     self.wlib_drag = false
     self.CLICK = false
     self.mouseWheel = 0
     self.previousGenerated = ""
     return self
    end
    
    function WLP.winlibCSSUpdate(self)
     local WC = P.MS.WC.value
     local WCA = P.MS.WCA.value
     local WTC = P.MS.WTC.value
     local TCA = P.MS.TCA.value
     local TTC = P.MS.TTC.value
     local BCA = P.MS.BCA.value
     local BTC = P.MS.BTC.value
     local wTC = P.MS.wTC.value
     local wAC = P.MS.wAC.value
     local titleR, titleG, titleB = webColors.namedColor2RGB(P.MS.TC.value)
     local titleRGB = tostring(titleR)..","..tostring(titleG)..","..tostring(titleB)
     local windowR, windowG, windowB = webColors.namedColor2RGB(WC)
     local windowRGB = tostring(windowR)..","..tostring(windowG)..","..tostring(windowB)
     local buttonR, buttonG, buttonB = webColors.namedColor2RGB(P.MS.BC.value)
     local buttonRGB = tostring(buttonR)..","..tostring(buttonG)..","..tostring(buttonB)
     local buttonborderR, buttonborderG, buttonborderB = webColors.namedColor2RGB(P.MS.BBC.value)
     local buttonborderRGB = tostring(buttonborderR)..","..tostring(buttonborderG)..","..tostring(buttonborderB)
    
     self.css.base = [[
      BODY {
       background:rgba(0, 0, 0, 0);
       color:#000000;
       width:100vw;
       height:100vh;
      }
      DIV.WinLib_window {
       position:absolute;
       background:rgba(]]..windowRGB..[[, ]]..WCA..[[);
       color:]]..WTC..[[;
       font-family:"Arial", Sans-Serif;
       box-shadow:0px 1px rgba(128, 128, 128, 0.5);
       font-size:15px;
       text-align:middle;
       fill:]]..WTC..[[;
      }
      DIV.WinLib_w_title {
       height:20px;
       background-color: rgba(]]..titleRGB..[[, ]]..TCA..[[);
       background-image: white;
       color:]]..TTC..[[;
       font-size:16px;
       text-align:center;
       padding-left:4px;
       font-family:"Bank";
      }
      DIV.WinLib_window>.WinLib_content {
       padding:4px;
       color:]]..WTC..[[;
       fill:]]..WTC..[[;
      }
      DIV.WinLib_button {
       position:absolute;
       background: rgba(]]..buttonRGB..[[, ]]..BCA..[[);
       border:1px solid rgb(]]..buttonborderRGB..[[);
       font-family:"Play";
       font-size:12px;
       text-align: center;
       vertical-align: text-top;
       color:]]..BTC..[[;
       overflow:hidden;
       padding-top:5px;
      }
      .widgets {
       background:rgba(0, 0, 0, 0) !important;
       box-shadow:0px 0px rgba(0, 0, 0, 0) !important;
      }
      .widgetnopadding {
       padding: 0px !important;
       padding-top: 0px !important;
       padding-left: 0px !important;
      }
      .separator {
       background:rgba(0, 0, 0, 0) !important;
       border:0px solid rgba(0, 0, 0, 0) !important;
       font-size:0px !important;
       color:rgba(0, 0, 0, 0) !important;
       box-shadow:0px 0px rgba(0, 0, 0, 0) !important;
       border: 0px solid rgba(0, 0, 0, 0) !important;
      }
      .Help_Menu {
       font-family:"Play" !important;
       font-size:14px !important;
      }
      .buttonHover {
       position:absolute;
       border: 3px solid rgb(]]..buttonborderRGB..[[) !important;
       font-family:"Play" !important;
       font-size:13px !important;
       text-align: center !important;
       vertical-align: text-top !important;
       box-shadow:3px 2px rgba(50, 50, 50, 0.5) !important;
       color:]]..BTC..[[ !important;
       overflow:hidden !important;
       padding-top:2px !important;
      }
      .fixed {
       z-index:1 !important;
      }
      .strike {
       text-decoration:line-through underline;
       opacity: 0.3;
      }
      .bold {
       font-family:"Play" !important;
       font-weight:bold;
      }
      .demo {
      text-align:center;
      }
      ]]
    end
    --WLP.winlibCSSUpdate()
    
    WLP.css.w_block = [[
    
     #{wlib_id} {
      width:{wlib_width}px;
      height:{wlib_height}px;
      top:{wlib_posY}px;
      left:{wlib_posX}px;
      z-index:{wlib_zIndex};
     }
     #{wlib_id}>.WinLib_w_title {
      height:{wlib_title_height}px;
      line-height:{wlib_title_height}px;
     }
     {wlib_buttons_generated}]]
    WLP.css.button_block = [[
    
     #{wlib_id} {
      width:{wlib_width}px;
      height:{wlib_height}px;
      top:{wlib_posY}px;
      left:{wlib_posX}px;
     }]]
    WLP.css.generated_block = [[
     <style>
    {wlib_css_generated}
     </style>
    ]]
    
    -- WLP HTML
    WLP.html = {}
    WLP.html.base = [[
    
    <style type="text/css">
    {wlib_css}
    {wlib_css_generated}
    </style>
    {wlib_html_generated}
    ]]
    WLP.html.window = [[
    <DIV class="WinLib_window {wlib_custom_class}" id="{wlib_id}">
    {wlib_title_bar}
     <DIV class="WinLib_content">
    {wlib_html}
    {wlib_buttons_generated}
     </DIV>
    </DIV>]]
    WLP.html.w_title = [[
     <DIV class="WinLib_w_title" id="title_bar">
      {wlib_title}
     </DIV>]]
    WLP.html.button = [[
     <DIV class="WinLib_button {wlib_custom_class}" id="{wlib_id}">
      {wlib_html}
     </DIV>]]

    function WLP.new(self,html,options,buttons)
     local window = {} 
     window.name = nil
     window.title = nil
     window.class = nil
     window.posX = DWN_Position_X
     window.posY = DWN_Position_Y
     window.width = DWN_Width
     window.height = DWN_Height
     window.titleHeight = DWN_TitleBar_Height
     window.draggable = false
     window.alwaysOnTop = false
     window.fixed = false
     if options ~= nil then
      window.name = (options.name ~= nil) and options.name or window.name
      window.title = (options.title ~= nil) and options.title or window.title
      window.class = (options.class ~= nil) and options.class or window.class
      window.posX = (options.posX ~= nil) and options.posX or window.posX
      window.posY = (options.posY ~= nil) and options.posY or window.posY
      window.width = (options.width ~= nil) and options.width or window.width
      window.height  = (options.height ~= nil) and options.height or window.height
      window.titleHeight = (options.titleHeight ~= nil) and options.titleHeight or window.titleHeight
      if options.draggable == nil or options.draggable == true then window.draggable = true else window.draggable = false end
      if options.alwaysOnTop == nil or options.alwaysOnTop == false then window.alwaysOnTop = false else window.alwaysOnTop = true end
      if options.fixed == nil or options.fixed == false then window.fixed = false else window.fixed = true end
     end

     window.buttons = (buttons == nil) and {} or buttons

     self.index = self.index + 1 -- Global index increment
     window.id = "wlib_w_" .. self.index -- Unique ID
     window.html = (html == nil) and "" or html -- Content provided by the user

     if window.fixed == true then
      window.zIndex = -100
     else
      window.zIndex = (window.alwaysOnTop == true) and 999999 + self.index or self.index
     end

     window.css = ""
     window.content = ""

     window.refresh = function()
      local button_html = ""
      local button_css  = ""

      for i, button in pairs(window.buttons) do
       button:refresh()
       button_html = button_html .. button.content
       button_css = button_css .. button.css
      end

      window.css = self.css.w_block
       :gsub("{wlib_id}",window.id)
       :gsub("{wlib_width}",window.width)
       :gsub("{wlib_height}",window.height)
       :gsub("{wlib_posX}",window.posX)
       :gsub("{wlib_posY}",window.posY)
       :gsub("{wlib_zIndex}",window.zIndex)
       :gsub("{wlib_title_height}",window.titleHeight)
       :gsub("{wlib_buttons_generated}",button_css)
    
      local title_bar = (window.title == nil) and "" or self.html.w_title
       :gsub("{wlib_title}",window.title)
      local custom_class = (window.class == nil) and "" or window.class
      window.content = self.html.window
       :gsub("{wlib_id}",window.id)
       :gsub("{wlib_custom_class}",custom_class)
       :gsub("{wlib_title_bar}",title_bar)
       :gsub("{wlib_html}",window.html)
       :gsub("{wlib_buttons_generated}",button_html)
     end

     window.setHTML = function(content)
      window.html = content
     end

     window.setTitle = function(content)
      window.title = content
     end

     window.setPos = function(x,y)
      window.posX = x
      window.posY = y
     end

     window.delete = function()
      self.windows[window.id] = nil
     end

     self.windows[window.id] = window
     return window
    end

    function WLP.toggleClick(self,bool)
     self.CLICK = bool
    end

    function WLP.update(self)
     self:mouseListener()
     if P.w_open == false then
      for k1, window in pairs(self.windows) do
       if P.Widget_HUD.w_open == true and window.name == P.Widget_HUD.w_title then
        local svg = widget:HUD_Update()
        if svg then window.setHTML(svg) else window.setHTML("") end
       end
       if P.Widget_Info.w_open == true and window.name == P.Widget_Info.w_title then
        local svg = widget:Info_Update()
        if svg then window.setHTML(svg) else window.setHTML("") end
       end
       if P.Widget_Platform.w_open == true and window.name == P.Widget_Platform.w_title then
        local svg = widget:Platform_Update()
        if svg then window.setHTML(svg) else window.setHTML("") end
       end
       for i, v in ipairs(customWidgets) do
        if P["Widget_Custom"..i].w_open == true and window.name == P["Widget_Custom"..i].w_title then
         local svg = processPcall(pcall(function() return customWidgets[i]:SVG_Update() end))
         if svg then
          window.setHTML(svg)
          if #customWidgets[i].buttons > 0 then
           for i2, w_button in ipairs(window.buttons) do
            for ___, custom_button in ipairs(customWidgets[i].buttons) do
             if window.buttons[i2].name == custom_button.name then
              self.windows[k2].buttons[i2].class = custom_button.class
              self.windows[k2].buttons[i2].posX = custom_button.posX
              self.windows[k2].buttons[i2].posY = custom_button.posY
              self.windows[k2].buttons[i2].width = custom_button.width
              self.windows[k2].buttons[i2].height = custom_button.height
              self.windows[k2].buttons[i2].__click = custom_button.button_function()
              self.windows[k2].buttons[i2].refresh()
             end
            end
           end
          end
         else
          window.setHTML("")
         end
        end
       end
      end
     end
     local gen_css = ""
     local windows = ""
     for _, window in pairs(self.windows) do
      window:refresh()
      gen_css = gen_css .. window.css 
      windows = windows .. window.content
      if window.name == "cursor" then
       window.posX = cursorX
       window.posY = cursorY
      end
     end
     local generated = self.html.base
      :gsub("{wlib_css}",self.css.base)
      :gsub("{wlib_css_generated}",gen_css)
      :gsub("{wlib_html_generated}",windows)
     if self.previousGenerated ~= generated then
      system.setScreen(generated)
      --if screen then screen.setHTML(generated) end
     end
     self.previousGenerated = generated
    end

    function WLP.mouseListener(self)
     if P.w_open == true or P.QuickToolBar.w_open == true then
      local mouse = self:getMousePos()
      mouseWheel = system.getMouseWheel()
      if mouseWheel ~= 0 then self.CLICK = true end

      if self.grabbed == nil then 
       for _, window in pairs(self.windows) do
        if window.name ~= "cursor" then
         local bound = { x1 = window.posX, y1 = window.posY,
          x2 = window.posX + window.width, y2 = window.posY + window.height }
         if(mouse.x >= bound.x1 and mouse.y >= bound.y1
           and mouse.x <= bound.x2 and mouse.y <= bound.y2) then
          if(self.grabbed == nil) then
           self.grabbed = window
          else
           if(window.zIndex > self.grabbed.zIndex) then
            self.grabbed = window
           end
          end
         end
        end
       end

       if(self.grabbed ~= nil) then
        self:buttonCheck()
        if self.grabbed.zIndex ~= self.index and self.CLICK ~= false then
         if(self.grabbed.alwaysOnTop ~= true) then
          self.index = self.index + 1
          self.grabbed.zIndex = self.index
         end
        end

        if self.grabbed.draggable == true then
         if(self.grabbed.title == nil) then
          self:beginDrag()
         elseif(mouse.y <= self.grabbed.posY + self.grabbed.titleHeight) then
          self:beginDrag()
         else
          self.grabbed = nil
         end
        else
         self.grabbed = nil
        end
       end
      else
       self.buttonLock = nil
      end
      if mouseWheel ~= 0 then
       self.CLICK = false
      end
     end
    end

    function WLP.beginDrag(self)
      local mouse = self:getMousePos()
      self.grabbed.offset = {x = mouse.x - self.grabbed.posX,
           y = mouse.y - self.grabbed.posY}
     self.wlib_drag = true
    end

    function WLP.performDrag(self)
     if self.CLICK == true and mouseWheel == 0 then
      local mouse = self:getMousePos()
      local new_x = tonumber(string.format("%.2f",mouse.x - self.grabbed.offset.x))
      local new_y = tonumber(string.format("%.2f",mouse.y - self.grabbed.offset.y))
      self.grabbed.posX = (self.grabbed.posX ~= new_x) and new_x or self.grabbed.posX
      self.grabbed.posY = (self.grabbed.posY ~= new_y) and new_y or self.grabbed.posY
      Save_Window_Pos(self.grabbed.name,self.grabbed.posX,self.grabbed.posY)
     elseif mouseWheel ~= 0 then
      for i, v in pairs(P) do
       if string.sub (tostring(i),1,7) == "Widget_" and P[i].w_title == self.grabbed.name then
        P[i].w_scale = P[i].w_scale + 0.05 * mouseWheel
        system.print(P[i].w_title.." widget scale: "..P[i].w_scale)
        self.CLICK = false
        windowsShow()
       end
      end
     else
      self:releaseWindow()
     end
    end

    function WLP.releaseWindow(self)
     self.grabbed = nil
     self.wlib_drag = false
    end

    function WLP.buttonCheck(self)
     for _, button in pairs(self.grabbed.buttons) do
      local mouse = self:getMousePos()
      local bound = { x1 = button.posX + self.grabbed.posX,
          y1 = button.posY + self.grabbed.posY,
          x2 = button.posX + self.grabbed.posX + button.width,
          y2 = button.posY + self.grabbed.posY + button.height }
      if(mouse.x >= bound.x1 and mouse.x <= bound.x2 and
        mouse.y >= bound.y1 and mouse.y <= bound.y2 and
        self.buttonLock ~= button) then
       for k1, window in pairs(self.windows) do
        for i1, wbutton in ipairs(window.buttons) do
         if button.id == wbutton.id and button.class ~= "separator" then
          self.windows[k1].buttons[i1].class = "buttonHover"
         end
        end
       end
       if self.CLICK == true then
        self.buttonLock = button
        button:__click()
        self.CLICK = false
       end
      else
       for k1, window in pairs(self.windows) do
        for i1, wbutton in ipairs(window.buttons) do
         if button.id == wbutton.id and button.class ~= "separator" then
          self.windows[k1].buttons[i1].class = ""
         end
        end
       end
      end
     end
    end

    function WLP.getMousePos(self)
      cursorX = system.getMousePosX()
      cursorY = system.getMousePosY()
     return {x = cursorX,y = cursorY}
    end
    
    function WLP.buttonsNew(self, html, onclick, options)
     local button = {}
     button.name = nil
     button.class = nil
     button.posX = DBu_Position_X
     button.posY = DBu_Position_Y
     button.width = DBu_Width
     button.height = DBu_Height

     if(options ~= nil) then
      button.name = (options.name ~= nil) and options.name or button.name
      button.class = (options.class ~= nil) and options.class or button.class
      button.posX = (options.posX ~= nil) and options.posX or button.posX
      button.posY = (options.posY ~= nil) and options.posY or button.posY
      button.width = (options.width ~= nil) and options.width or button.width
      button.height  = (options.height ~= nil) and options.height or button.height
     end

     self.index = self.index + 1
     button.id = "wlib_button_" .. self.index
     button.html = (html == nil) and "" or html

     button.css = ""
     button.previousCSS = ""
     button.previousContent = ""
     button.refresh = function()

       button.css = self.css.button_block
            :gsub("{wlib_id}",button.id)
            :gsub("{wlib_width}",button.width)
            :gsub("{wlib_height}",button.height)
            :gsub("{wlib_posX}",button.posX)
            :gsub("{wlib_posY}",button.posY)
       local custom_class = (button.class == nil) and "" or button.class
       button.content = self.html.button
            :gsub("{wlib_id}",button.id)
            :gsub("{wlib_custom_class}",custom_class)
            :gsub("{wlib_html}",button.html)
      end
     button.previousCSS = button.css
     button.previousContent = button.content

     button.__click = onclick

     button.setClick = function(clickMethod)
      button.__click = clickMethod
     end

     button.setHTML = function(content)
      button.html = content
     end

     button.setClass = function(content)
      button.class = content
     end
     return button
    end
  onStart:
   lua: |
    -- webcolors
    local function index(t,val)
     for i,v in ipairs(t) do
      if v == val then 
       return i
      end
     end
     return nil
    end
    webColors = {}
    webColors.namedColors = {"aliceblue","antiquewhite","aqua","aquamarine","azure","beige","bisque","black","blanchedalmond","blue","blueviolet","brown","burlywood","cadetblue","chartreuse","chocolate","coral","cornflowerblue","cornsilk","crimson","cyan","darkblue","darkcyan","darkgoldenrod","darkgray","darkgreen","darkgrey","darkkhaki","darkmagenta","darkolivegreen","darkorange","darkorchid","darkred","darksalmon","darkseagreen","darkslateblue","darkslategray","darkslategrey","darkturquoise","darkviolet","deeppink","deepskyblue","dimgray","dimgrey","dodgerblue","firebrick","floralwhite","forestgreen","fuchsia","gainsboro","ghostwhite","gold","goldenrod","gray","green","greenyellow","grey","honeydew","hotpink","indianred","indigo","ivory","khaki","lavender","lavenderblush","lawngreen","lemonchiffon","lightblue","lightcoral","lightcyan","lightgoldenrodyellow","lightgray","lightgreen","lightgrey","lightpink","lightsalmon","lightseagreen","lightskyblue","lightslategray","lightslategrey","lightsteelblue","lightyellow","lime","limegreen","linen","magenta","maroon","mediumaquamarine","mediumblue","mediumorchid","mediumpurple","mediumseagreen","mediumslateblue","mediumspringgreen","mediumturquoise","mediumvioletred","midnightblue","mintcream","mistyrose","moccasin","navajowhite","navy","oldlace","olive","olivedrab","orange","orangered","orchid","palegoldenrod","palegreen","paleturquoise","palevioletred","papayawhip","peachpuff","peru","pink","plum","powderblue","purple","red","rosybrown","royalblue","saddlebrown","salmon","sandybrown","seagreen","seashell","sienna","silver","skyblue","slateblue","slategray","slategrey","snow","springgreen","steelblue","teal","thistle","tomato","turquoise","violet","wheat","white","whitesmoke","yellow","yellowgreen"}
    webColors.RGBColors = {{240, 248, 255},{250, 235, 215},{ 0, 255, 255},{127, 255, 212},{240, 255, 255},{245, 245, 220},{255, 228, 196},{ 0, 0, 0},{255, 235, 205},{ 0, 0, 255},{138, 43, 226},{165, 42, 42},{222, 184, 135},{ 95, 158, 160},{127, 255, 0},{210, 105, 30},{255, 127, 80},{100, 149, 237},{255, 248, 220},{220, 20, 60},{ 0, 255, 255},{ 0, 0, 139},{ 0, 139, 139},{184, 134, 11},{169, 169, 169},{ 0, 100, 0},{169, 169, 169},{189, 183, 107},{139, 0, 139},{ 85, 107, 47},{255, 140, 0},{153, 50, 204},{139, 0, 0},{233, 150, 122},{143, 188, 143},{ 72, 61, 139},{ 47, 79, 79},{ 47, 79, 79},{ 0, 206, 209},{148, 0, 211},{255, 20, 147},{ 0, 191, 255},{105, 105, 105},{105, 105, 105},{ 30, 144, 255},{178, 34, 34},{255, 250, 240},{ 34, 139, 34},{255, 0, 255},{220, 220, 220},{248, 248, 255},{255, 215, 0},{218, 165, 32},{128, 128, 128},{128, 128, 128},{ 0, 128, 0},{173, 255, 47},{240, 255, 240},{255, 105, 180},{205, 92, 92},{ 75, 0, 130},{255, 255, 240},{240, 230, 140},{230, 230, 250},{255, 240, 245},{124, 252, 0},{255, 250, 205},{173, 216, 230},{240, 128, 128},{224, 255, 255},{250, 250, 210},{211, 211, 211},{144, 238, 144},{211, 211, 211},{255, 182, 193},{255, 160, 122},{ 32, 178, 170},{135, 206, 250},{119, 136, 153},{119, 136, 153},{176, 196, 222},{255, 255, 224},{ 0, 255, 0},{ 50, 205, 50},{250, 240, 230},{255, 0, 255},{128, 0, 0},{102, 205, 170},{ 0, 0, 205},{186, 85, 211},{147, 112, 219},{ 60, 179, 113},{123, 104, 238},{ 0, 250, 154},{ 72, 209, 204},{199, 21, 133},{ 25, 25, 112},{245, 255, 250},{255, 228, 225},{255, 228, 181},{255, 222, 173},{ 0, 0, 128},{253, 245, 230},{128, 128, 0},{107, 142, 35},{255, 165, 0},{255, 69, 0},{218, 112, 214},{238, 232, 170},{152, 251, 152},{175, 238, 238},{219, 112, 147},{255, 239, 213},{255, 218, 185},{205, 133, 63},{255, 192, 203},{221, 160, 221},{176, 224, 230},{128, 0, 128},{255, 0, 0},{188, 143, 143},{ 65, 105, 225},{139, 69, 19},{250, 128, 114},{244, 164, 96},{ 46, 139, 87},{255, 245, 238},{160, 82, 45},{192, 192, 192},{135, 206, 235},{106, 90, 205},{112, 128, 144},{112, 128, 144},{255, 250, 250},{ 0, 255, 127},{ 70, 130, 180},{ 0, 128, 128},{216, 191, 216},{255, 99, 71},{ 64, 224, 208},{238, 130, 238},{245, 222, 179},{255, 255, 255},{245, 245, 245},{255, 255, 0},{154, 205, 50}}
    function webColors.namedColor2RGB(name)
     if type(name) == "string" then
      local i = index(webColors.namedColors,name)
      return webColors.RGBColors[i][1],webColors.RGBColors[i][2],webColors.RGBColors[i][3]
     end
    end
  onStart:
   lua: |
    -- help menu
    help = {}
    local fontSize = 12
    local lS = 16 --lineSpace
    local h1 = '<tspan x="500" dy="'
    local h2 = '</tspan>'
    help.info = [[
     <text x="500" y="30" font-size="]]..fontSize..[[" text-anchor="middle">
      <tspan x="500" font-size="]]..fontSize*2 ..[[">]]..'INSTRUCTION MANUAL'..h2..[[
      
      ]]..h1..lS*2 ..[[" style="font-weight: bold; " font-size="]]..fontSize*1.8 ..[[">]]..'Default -- Flight Script'..h2..[[
      ]]..h1..lS..[[">]]..'The touch screen revolutionary hud and flight script!'..h2..[[
      ]]..h1..lS..[[">]]..'By Jeronimo 2016-2023, minified by TheGreatSardini 2023'..h2..[[
      
      ]]..h1..lS*2 ..[[">]]..'> "ALT + 1" to open and close Main menu.'..h2..[[
      ]]..h1..lS..[[">]]..'> "LEFT CLICK" as main CLICK.'..h2..[[
      ]]..h1..lS..[[">]]..'> "MOUSE WHEEL SCROLL" over button to change its VALUE.'..h2..[[
      ]]..h1..lS..[[">]]..'> "LEFT CLICK" on button to change its INCREMENT.'..h2..[[
      ]]..h1..lS..[[">]]..'> "CTRL + LEFT CLICK" to save a button in the QUICK TOOL BAR'..h2..[[
      ]]..h1..lS..[[">]]..'(asterisk "*" confirms the shortcut is active).'..h2..[[
      ]]..h1..lS..[[">]]..'> "double tap + hold ALT" to access QUICK TOOL BAR.'..h2..[[
      
      ]]..h1..lS*2 ..[[">]]..'> All the DEFAULT -- windows and widgets are dragable'..h2..[[
      ]]..h1..lS..[[">]]..'either by their title or background.'..h2..[[
      ]]..h1..lS..[[">]]..'> And resizeable using mouse wheel'..h2..[[
      
      ]]..h1..lS*2 ..[[">]]..'> Discord: thegreatsardini'..h2..[[
      
      ]]..h1..lS*2 ..[[" style="font-weight: bold; " font-size="]]..fontSize*1.5 ..[[">]]..'ENJOY!'..h2..[[
     </text>]]
     
    help.menuSettings = [[
     <text x="500" y="30" font-size="]]..fontSize..[[" text-anchor="middle">
      <tspan x="500" font-size="]]..fontSize*2 ..[[">]]..'MENU SETTINGS'..h2..[[
      
      ]]..h1..lS*2 ..[[">]]..'This MENU is dedicated to windows customization'..h2..[[
      
      ]]..h1..lS*2 ..[[">]]..'- TITLE COLOR: Title bar'..h2..[[
      ]]..h1..lS..[[">]]..'- TITLE ALPHA: Title bar opacity'..h2..[[
      ]]..h1..lS..[[">]]..'- TITLE TEXT COLOR: Title bar'..h2..[[
      
      ]]..h1..lS*2 ..[[">]]..'- WINDOW COLOR: Background color'..h2..[[
      ]]..h1..lS..[[">]]..'- WINDOW ALPHA: Background opacity'..h2..[[
      ]]..h1..lS..[[">]]..'- WINDOW TEXT COLOR: '..h2..[[
      
      ]]..h1..lS*2 ..[[">]]..'- BUTTON COLOR: Buttons background'..h2..[[
      ]]..h1..lS..[[">]]..'- BUTTON BORDER COLOR: Buttons border'..h2..[[
      ]]..h1..lS..[[">]]..'- BUTTON ALPHA: Buttons background opacity'..h2..[[
      ]]..h1..lS..[[">]]..'- BUTTON TEXT COLOR:'..h2..[[
      
      ]]..h1..lS*2 ..[[">]]..'- WIDGET COLOR: Widgets background'..h2..[[
      ]]..h1..lS..[[">]]..'- WIDGET SVG COLOR1:'..h2..[[
      ]]..h1..lS..[[">]]..'- WIDGET SVG COLOR2:'..h2..[[
      
      ]]..h1..lS*2 ..[[">]]..'- COLOR PRESETS: Up to 5 presets that can be customized at will'..h2..[[
      ]]..h1..lS..[[">]]..'- HELP MENU: Open and close this instructions window'..h2..[[
     </text>]]
     
    help.engineSettings = [[
     <text x="500" y="30" font-size="]]..fontSize..[[" text-anchor="middle">
      <tspan x="500" font-size="]]..fontSize*2 ..[[">]]..'ENGINES SETTINGS'..h2..[[
      
      ]]..h1..lS*2 ..[[">]]..'This MENU is dedicated to eng default settings'..h2..[[
      
      ]]..h1..lS*2 ..[[">]]..'- PITCH FACTOR: Pitch speed factor'..h2..[[
      ]]..h1..lS..[[">]]..'- YAW FACTOR: Yaw speed factor'..h2..[[
      ]]..h1..lS..[[">]]..'- ROLL FACTOR: Roll speed factor'..h2..[[
      ]]..h1..lS..[[">]]..'- ANGULAR DAMPING: Anti rotational drift factor'..h2..[[
      
      ]]..h1..lS*2 ..[[">]]..'- LONG/LAT/VERT FACTORS: Engine responsiveness'..h2..[[
      
      ]]..h1..lS*2 ..[[">]]..'- LONG BRAKE FACTOR: Brake intensity along logitudinal axis'..h2..[[
      ]]..h1..lS..[[">]]..'- LAT BRAKE FACTOR: Brake intensity along lateral axis'..h2..[[
      ]]..h1..lS..[[">]]..'- VERT BRAKE FACTOR: Brake intensity along vertical axis'..h2..[[
      ]]..h1..lS..[[">]]..'- SPACE BRAKE INTENSIITY: Multiplication factor for all 3 above factors in space'..h2..[[
      
      ]]..h1..lS*2 ..[[">]]..'- GYRO AXIS: Use gyro or "cross" only with special instructions'..h2..[[
      ]]..h1..lS..[[">]]..'- PITCH TILTING: Adjust the default pitch angle of the construct'..h2..[[
      ]]..h1..lS..[[">]]..'- ROLL TILTING: Adjust the default roll angle of the construct'..h2..[[
      
      ]]..h1..lS*2 ..[[">]]..'- HOVERS ON/OFF: Activate/deactivate hover eng'..h2..[[
      ]]..h1..lS..[[">]]..'- HOVER MODE: Dynamic/Static enables altitude stabilisation'..h2..[[
      ]]..h1..lS..[[">]]..'- HOVER ALTITUDE: Altitude for Static Mode'..h2..[[
      ]]..h1..lS..[[">]]..'- AGG ALTITUDE: Adjust the Anti-gravity engine altitude'..h2..[[
      
      ]]..h1..lS*2 ..[[">]]..'- ENGINES ON/OFF: Activate/deactivate all the eng'..h2..[[
      ]]..h1..lS..[[">]]..'- ENGINES AUTO: Long press "C" on the ground to deactivate all eng'..h2..[[
      ]]..h1..lS..[[">]]..'- ATMO MAX SPEED: Speed limiter for atmosphere'..h2..[[
      ]]..h1..lS..[[">]]..'- DRONE CRUISE ANGLE: for normal drone flight in degrees'..h2..[[
      ]]..h1..lS..[[">]]..'- DRONE SHIFT ANGLE: for drone flight holding shift'..h2..[[
     </text>]]
     
    help.autopilotSettings = [[
     <text x="500" y="30" font-size="]]..fontSize..[[" text-anchor="middle">
      <tspan x="500" font-size="]]..fontSize*2 ..[[">]]..'AUTOPILOT SETTINGS'..h2..[[
      
      ]]..h1..lS*2 ..[[">]]..'This MENU is dedicated to autopilot features settings'..h2..[[
      
      ]]..h1..lS*2 ..[[">]]..'- AUTO BRAKE SPEED: Speed under which auto braking will occur in TRAVEL'..h2..[[
      
      ]]..h1..lS*2 ..[[">]]..'- AUTO LEVEL ALT. MAX: Altitude under wich auto stabilisation will be effective'..h2..[[
      ]]..h1..lS ..[[">]]..'- ROLL STABILISATION: Automatic roll stabilisation'..h2..[[
      ]]..h1..lS..[[">]]..'- TURN ASSIST: Automatic pitch and yaw while rolling'..h2..[[
      ]]..h1..lS..[[">]]..'- TURN ASSIST MIN ROLL: Minimum roll angle for the turn assist to occur'..h2..[[
      ]]..h1..lS..[[">]]..'- TURN ASSIST MAX PITCH: Maximum pitch angle for the turn assist to occur'..h2..[[
      
      ]]..h1..lS*2 ..[[">]]..'- PITCH STABILISATION: Automatic pitch stabilisation'..h2..[[
      ]]..h1..lS..[[">]]..'- AUTO PITCH AMPLITUDE: Angle under which pitch stabilisation will occur'..h2..[[
      ]]..h1..lS..[[">]]..'- ALTITUDE STABILISATION: Automatic pitch to keep a stable altitude'..h2..[[
      ]]..h1..lS..[[">]]..'- ATMO ANTI-STALL: Will try to prevent construct from stalling in atmo'..h2..[[
      
      ]]..h1..lS*2 ..[[">]]..'- INERTIA AUTO BRAKE: Anti drift auto braking on/off'..h2..[[
      ]]..h1..lS..[[">]]..'- ATMO INERTIA FACTOR: Amto drift sensitivity factor'..h2..[[
      ]]..h1..lS..[[">]]..'- SPACE INERTIA FACTOR: Space drift sensitivity factor'..h2..[[
      ]]..h1..lS..[[">]]..'- SPACE AUTO PROGRADE: Force align construct to its velocity vector'..h2..[[
      ]]..h1..lS..[[">]]..'- SPACE AUTO ORBIT SPEED: Auto speed adjustment for orbit'..h2..[[
      
      ]]..h1..lS*2 ..[[">]]..'- ROCKETS MAX SPEED: Speed limiter in atmo for rockets(set -1 to disable)(WIP)'..h2..[[
      ]]..h1..lS..[[">]]..'*Rockets are completly disabled at the moment'..h2..[[
      
      ]]..h1..lS*2 ..[[">]]..'- DOCKING PARENT: MANUAL / CLOSEST / OWNER dok parent type'..h2..[[
      
      ]]..h1..lS*2 ..[[">]]..'- BACK BURN: Drone mode, use engines to counter velocity'..h2..[[
      ]]..h1..lS ..[[">]]..'- AUTO LAND FACTOR: how quickly to auto land and still stop in time'..h2..[[
      ]]..h1..lS ..[[">]]..'- GROUND OFFSET: slow down by this distance from ground (autoland)'..h2..[[
     </text>]]
     
    help.widgets = [[
     <text x="500" y="30" font-size="]]..fontSize..[[" text-anchor="middle">
      <tspan x="500" font-size="]]..fontSize*2 ..[[">]]..'WIDGETS SETTINGS'..h2..[[
      
      ]]..h1..lS*2 ..[[">]]..'This MENU is dedicated to widgets settings'..h2..[[
      
      ]]..h1..lS*2 ..[[">]]..'- All widgets are resizeable, repositionable,'..h2..[[
      ]]..h1..lS..[[">]]..'by using the "Quick tool Bar" menu.'..h2..[[
      
      ]]..h1..lS*2 ..[[">]]..'- Widgets with the "ALT" option on will only popup'..h2..[[
      ]]..h1..lS..[[">]]..'when "Quick tool Bar" menu is opened.'..h2..[[
      
      ]]..h1..lS*2 ..[[">]]..'- Widgets with the "AUTO" option on will only popup'..h2..[[
      ]]..h1..lS..[[">]]..' when the needed conditions they requiere are active.'..h2..[[
      
      ]]..h1..lS*2 ..[[">]]..'- Too many opened widgets can cause CPU overload'..h2..[[
      ]]..h1..lS..[[">]]..'Use them wisely!'..h2..[[
      
      ]]..h1..lS*2 ..[[">]]..'- Custom widgets are fully customizable and modular'..h2..[[
      ]]..h1..lS..[[">]]..'they can be found and edited in the WIDGETS folder.'..h2..[[
      ]]..h1..lS..[[">]]..'File name number must be consecutive'..h2..[[
      
      ]]..h1..lS*2 ..[[">]]..'- Custom Widgets are usingwindows system to display custom SVGs,'..h2..[[
      ]]..h1..lS..[[">]]..'they can also include custom buttons and thrust overide'..h2..[[
     </text>]]
     
    help.keybingParams = [[
     <text x="500" y="30" font-size="]]..fontSize..[[" text-anchor="middle">
      <tspan x="500" font-size="]]..fontSize*2 ..[[">]]..'KEYBINDS PARAMETERS'..h2..[[
      
      ]]..h1..lS*2 ..[[">]]..'This MENU is dedicated to keybind parameters'..h2..[[
      
      ]]..h1..lS*2 ..[[">]]..'- FLIGHT MODE: Warning! Default flight mode keybind is deactivated'..h2..[[
      ]]..h1..lS ..[[">]]..'- PARKING MODE: How to behave when near the ground and moving slow'..h2..[[
      ]]..h1..lS ..[[">]]..'- PARKING MAX SPEED: Max parking speed'..h2..[[
      ]]..h1..lS..[[">]]..'CRUISE: Use throttle to control the construct speed and brakes'..h2..[[
      ]]..h1..lS..[[">]]..'TRAVEL: Use throttle to control the construct thrust'..h2..[[
      ]]..h1..lS..[[">]]..'PLATFORM: Use ASDW to move around'..h2..[[
      ]]..h1..lS..[[">]]..'DRONE: Use ASDW to move around using hover or vertical eng.'..h2..[[
      ]]..h1..lS..[[">]]..'- Hover eng must be set to disable thrust along gravity.'..h2..[[
      
      ]]..h1..lS*2 ..[[">]]..'- QE/AD INVERT: Inverts keybind for yaw and roll'..h2..[[
      ]]..h1..lS ..[[">]]..'- Y AXIS INVERT: mouse moude pitch flipped'..h2..[[
      ]]..h1..lS ..[[">]]..'- KEYPRESS WARMUP: makes pressing a key less sudden force: in seconds'..h2..[[
      ]]..h1..lS ..[[">]]..'- DOUBLE TAP TIME: Time in seconds for activating a double tap'..h2..[[
      ]]..h1..lS..[[">]]..'*DOUBLE TAP FEATURES: Backburn stop in space using "double tap CTRL"' ..h2..[[
      ]]..h1..lS ..[[">]]..'- G TOGGLES PARKING: G force exits parking instead of waiting til throttle'..h2..[[
      ]]..h1..lS ..[[">]]..'- BRAKE TOGGLE MODE: Brake toggles (like some other flight scripts)'..h2..[[

      ]]..h1..lS*2 ..[[">]]..'- SHIFT LOCK: Enable the "SHIFT key to lock in place a control key'..h2..[[
      ]]..h1..lS..[[">]]..'First hold "SHIFT" then press and release any control key, then release "SHIFT"'..h2..[[
      
      ]]..h1..lS*2 ..[[">]]..'- FREEZE CONTROL: Freeze/unfreeze movements while using a remote or ECU'..h2..[[
      ]]..h1..lS..[[">]]..'- FREEZE VIEW: Freeze/unfreeze camera movements'..h2..[[
      ]]..h1..lS..[[">]]..'- MOUSE CONTROL: Alternate toggle able keyboard + mouse scheme'..h2..[[
      ]]..h1..lS..[[">]]..'- M-C SENSITIVITY: sensitivity of the mouse control'..h2..[[
      
      ]]..h1..lS*2 ..[[">]]..'- ALT + 3456789 constomizable keybinds for selected features'..h2..[[
     </text>]]
     
    help.q = [[
     <text x="500" y="30" font-size="]]..fontSize..[[" text-anchor="middle">
      <tspan x="500" font-size="]]..fontSize*2 ..[[">]]..'QUICK TOOL BAR'..h2..[[
      
      ]]..h1..lS*2 ..[[">]]..'This MENU is dedicated to the quick menu tool bar'..h2..[[
      
      ]]..h1..lS*2 ..[[">]]..'- While in the "ALT+1" main menu, hold "CTRL" then click to add'..h2..[[
      ]]..h1..lS..[[">]]..'or remove shortcut buttons from the Quick Tool Bar'..h2..[[
      
      ]]..h1..lS*2 ..[[">]]..'- Quick Tool Bar is accessible by double taping and holding "ALT" key while on the main screen'..h2..[[
      
      ]]..h1..lS*2 ..[[">]]..'- Widgets are interactible while Quick Tool Bar is opened'..h2..[[
      
      ]]..h1..lS*2 ..[[">]]..'- Certain widgets with "ALT" parameters will only popup with the Quick Tool Bar'..h2..[[
     </text>]]
      
    help.print = function(system)
     system.print("------------------------")
     system.print("HELP / KEYBINDS")
     system.print("------------------------")
     system.print("ALT + 1 = open/close Main settings menu")
     system.print("Double Tap ALT while flying to acces quicktool menu")
     system.print("Double Tap CTRL in space = backburn stop")
     system.print("------------------------")
     system.print("HELP / COMMANDS")
     system.print("------------------------")
     system.print("help = print the help menu")
     system.print("reset all: formats databank to factory settings")
     system.print("type in a ::pos{} coordinate to translate it to world coordinate")
     system.print("------------------------")
     system.print("End of the help menu")
     system.print("------------------------")
    end
    --return help
  onStart:
   lua: |
    Kinematic = {} -- Part of Jaylebreak's flight files, modified slightly

    local clamp = utils.clamp
   
    function Kinematic.computeAccelerationTime(initial, acceleration, final)
     -- ans: t = (vf - vi)/a
     return (final - initial)/acceleration
    end

    function Kinematic.BrakeDistanceAndTime(initial,final,mass,thrust,maxBrakeForce,atmosDensity,gravityA,zAxis,zBrakeClamp)
     maxBrakeForce = maxBrakeForce or 0
     atmosDensity = atmosDensity or 1
     gravityA = gravityA or 9.89
     zAxis = zAxis or false
     zBrakeClamp = zBrakeClamp or 0.14 --0.1592 -- can't fall slower than this m/s 

     local gF = gravityA*mass
     local gA = gF/mass
     local tA = thrust / -mass
     local t, d = 0,0
     local zBrakeScale = 1
     if zAxis then zBrakeScale = clamp(gF/(maxBrakeForce*zBrakeClamp),0,1) end
     local bA = -(maxBrakeForce*atmosDensity*zBrakeScale)/mass

     if initial <= final then
      return 0, 0, 0  -- trivial
     elseif tA+bA >= 0 then
      return -1, -1, -1 -- no solution
     end
    
     if final < 100 then
      -- first calculate distance to 100 m/s
      local t1 = 0
      local d1 = 0
      if initial > 100 then 
       local a = tA+bA+gA
       t = Kinematic.computeAccelerationTime(initial, a, 100)
       d = initial*t + a*t*t/2
       initial = 100
      end

      -- iterate over remaining speed
      local initialVel = initial
      local stepSize = 2
      while initialVel > final do
       local t2, d2 = 0,0
       local targetVel = initialVel - stepSize > final and initialVel - stepSize or final
       local aveVel = (targetVel + initialVel)/2
       local brakeForce = 0
       if zAxis then 
        local bBottom = aveVel/(100/clamp(1+(6.28-(maxBrakeForce/gF)),1,100))*maxBrakeForce
        local bUpper = maxBrakeForce * clamp(aveVel/100,0.09,1)^1.01
        brakeForce = math.min(bBottom,bUpper) * zBrakeScale * atmosDensity
       else
        brakeForce = maxBrakeForce * clamp(aveVel/100,0.1,1) * atmosDensity
       end
       local bA2 = -brakeForce/mass
       local a = tA+bA2+gA
       if a > 0 then return d, t, initialVel end -- can't slow to target vel
       t2 = Kinematic.computeAccelerationTime(initialVel, a, targetVel)
       d2 = initialVel*t2 + a*t2*t2/2
       t = t2 + t
       d = d2 + d
       initialVel = targetVel
      end
     else
      --Directly calculate since end is > 100
      local a = tA+gA+bA
      t = Kinematic.computeAccelerationTime(initial, a, final)
      d = initial*t + a*t*t/2
     end
     return d, t, 0 --distance, time, minfall speed
    end

    function Kinematic.computeTravelTime(initial, acceleration, distance)
     -- quadratic equation: t=(sqrt(2ad+v^2)-v)/a
     if distance == 0 then return 0 end
     if acceleration ~= 0 then
      return (math.sqrt(2*acceleration*distance+initial^2) - initial)/acceleration
     end
     assert(initial > 0, 'Acceleration and initial speed are both zero.')
     return distance/initial
    end

    function Kinematic.maxInitialVelocity(distance,final,mass,thrust,hov,hoverDist,maxBrakeForce,atmosDensity,gravityA,zAxis,zBrakeClamp)
     if distance <= 0 then return -1 end
     
     hov = hov or 0
     hoverDist = hoverDist or 0
     maxBrakeForce = maxBrakeForce or 0
     atmosDensity = atmosDensity or 1
     gravityA = gravityA or 9.89
     zAxis = zAxis or false
     zBrakeClamp = zBrakeClamp or 0.14 --0.1592 -- can't fall slower than this m/s 

     local gF = gravityA*mass
     local gA = gF/mass
     local tA = thrust / -mass
     local hA = hov / -mass
     local bA = -maxBrakeForce/mass

     local function brakeAcceleration(velocity)
      if maxBrakeForce <= 0 or velocity == 0 then return 0 end
      local brakeForce = 0
      if zAxis then 
       local zBrakeScale = clamp(gF/(maxBrakeForce*zBrakeClamp),0,1)
       local bBottom = velocity/(100/clamp(1+(6.28-(maxBrakeForce/gF)),1,100))*maxBrakeForce
       local bUpper = maxBrakeForce * clamp(velocity/100,0.09,1)^1.01
       brakeForce = math.min(bBottom,bUpper) * zBrakeScale * atmosDensity
      else
       brakeForce = maxBrakeForce * clamp(velocity/100,0.1,1) * atmosDensity
      end
      return -brakeForce/mass
     end
     
     local increment = 2
     local distTraveled = 0
     local vCurrent = final

     while distTraveled < distance do
      local hAs = distTraveled <= hoverDist and hA or 0
      local bAs = brakeAcceleration(vCurrent)
      local a = tA+bAs+gA+hAs
      if a > 0 then return vCurrent end
      local distStep = distTraveled + increment < distance and increment or distance - distTraveled
      local vInitial = vCurrent
      local ts = Kinematic.computeTravelTime(vInitial, -a, distStep)
      vCurrent = vCurrent + (-a) * ts
      distTraveled = distTraveled + distStep
     end
     return vCurrent
    end
  onStart:
   lua: |
    -- navigator --
    local utils = require("cpml/utils")
    local pid = require("cpml/pid")

    local sign, clamp, abs, sqrt, min, max = utils.sign, utils.clamp, math.abs, math.sqrt, math.min, math.max
    local C = construct

    NPP = {} --NavigatorPlusPlus
    NPP.__index = NPP

    function NPP.new()
     local self = setmetatable({}, NPP)

     self.boosterState = 0
     self.boosterStateHasChanged = false
     self.boosterMaxSpeed = 1200 --TODO Use this?

     self.mM = "CRUISE" --MasterMode
     self.tV = 0 --ThrottleValue
     self.mouseWheelValue = 0
     self.mSK = 49999 --maxSpeedKMPH

     self.tSRS = {5,10,20,40,100,200,500,1000} --targetSpeedRangesSteps
     self.tSR = {20,60,140,300,800,2000,7000,49999} --targetSpeedRanges
     self.cTSS = 0 --currentTargetSpeedStep
     self.aMS = C.getFrictionBurnSpeed() * 3.6 * 0.8 --atmoMaxSpeed

     self.targetGAC = unit.computeGroundEngineAltitudeStabilizationCapabilities()
     return self
    end

    function NPP.setAtmoMaxSpeed(self,speed)
     self.aMS = speed
    end

    function NPP.getAtmoMaxSpeed(self)
     return self.aMS
    end

    ------------------
    -- Throttle setup
    ------------------
    function NPP.setupCustomTargetSpeedRanges(self, customTargetSpeedRanges)
     self.customTargetSpeedRanges = customTargetSpeedRanges
    end

    function NPP.getTargetSpeedRangeStep(self,value)
     for i, v in ipairs(self.tSR) do
      self.cTSS = self.tSRS[i]
      if value > 0 then
       if abs(self.tV) < v then
        return self.cTSS
       end
      else
       if abs(self.tV) <= v then
        if self.tSRS[i-1] ~= nil then
         if abs(self.tV) - self.cTSS <= self.tSR[i-1] then
          self.cTSS = abs(self.tV) - self.tSR[i-1]
         end
        end
        return self.cTSS
       end
      end
     end
    end

    function NPP.updateThrottleValue(self,value)
     if value ~= 0 then self:prepareForFlight() end
     if self.mM == "CRUISE" then
      self.tV = clamp(self.tV + value * self:getTargetSpeedRangeStep(value),-self.mSK,self.mSK)
     elseif self.mM == "TRAVEL" then
      self.tV = clamp(self.tV + value/10,-1,1)
     else self.tV = 0
     end
     if abs(self.tV) < 0.01 then self.tV = 0 end
    end

    function NPP.setThrottleValue(self,value)
     if value ~= 0 then self:prepareForFlight() end
     if self.mM == "CRUISE" then
      self.tV = clamp(value,-self.mSK,self.mSK)
     elseif self.mM == "TRAVEL" then
      self.tV = clamp(value,-1,1)
     else self.tV = 0
     end
    end

    function NPP.prepareForFlight(self)
     autoLand, autoStart = false,false
     enginesToggle()
     if pkM then
      pkM = false
      if P.KP.flM.value ~= self.mM then
       self:setMasterMode(P.KP.flM.value)
      end
     end
    end

    function NPP.resetThrottleValue(self)
     self.tV = 0
    end

    function NPP.getThrottleValue(self)
     return self.tV
    end

    -- Master Mode --
    function NPP.setMasterMode(self,mode)
     if self.mM == mode then return end --already set
     self.mM = mode
     if self.mM == "CRUISE" then
      self.tV = ySpeedKPH > 10 and ySpeedKPH or 0
     elseif self.mM == "TRAVEL" or self.mM == "PLATFORM" or self.mM == "DRONE" then
      self:resetThrottleValue()
     end
     self.TargetLongitudinalSpeedPID:reset()
     self.TargetLateralSpeedPID:reset()
     self.TargetVerticalSpeedPID:reset()
     MM = self.mM
    end

    function NPP.buildPIDs(self)
     self.TargetLongitudinalSpeedPID = pid.new(10*P.ES.loF.value, 0, 10*P.ES.loF.value)
     self.TargetLateralSpeedPID = pid.new(10*P.ES.laF.value, 0, 10*P.ES.laF.value)
     self.TargetVerticalSpeedPID = pid.new(10*P.ES.vtF.value, 0, 10*P.ES.vtF.value)
    
     self.LongitudinalBrakePID = pid.new(1, 0, 10)
     self.LateralBrakePID = pid.new(1, 0, 10)
     self.VerticalBrakePID = pid.new(1, 0, 10)
    end

    function NPP.getMasterMode(self)
     return self.mM
    end

    -- Update --
    function NPP.throttleUpdate(self)
     local ThrottleInputFromMouseWheel = system.getThrottleInputFromMouseWheel()
      if self.mouseWheelValue ~= ThrottleInputFromMouseWheel then
       self:updateThrottleValue(ThrottleInputFromMouseWheel)
      end
     self.mouseWheelValue = ThrottleInputFromMouseWheel
    end
    function NPP.updateMaxSpeed(self,speed)
     self.mSK = speed
     self.tSR = {20,60,140,300,800,2000,7000,49999,self.mSK}
    end

    -----------------
    -- Acceleration 
    ----------------
    function NPP.maxForceForward(self)
     local cOF = {cOFx, cOFy, cOFz}
     local maxKPAlongAxis = C.getMaxThrustAlongAxis('thrust analog longitudinal', cOF)
     local spaceT = maxKPAlongAxis[3]~= nil and maxKPAlongAxis[3] or 0
     local atmoT = maxKPAlongAxis[1]~= nil and maxKPAlongAxis[1] or 0
     if not inAtmo then
      return spaceT
     elseif inspace == 0 then
      return atmoT
     else
      return spaceT + atmoT
     end
    end

    function NPP.maxForceBackward(self)
     local cOF = {cOFx, cOFy, cOFz}
     local maxKPAlongAxis = C.getMaxThrustAlongAxis('thrust analog longitudinal', cOF)
     local spaceT = maxKPAlongAxis[4]~= nil and maxKPAlongAxis[4] or 0
     local atmoT = maxKPAlongAxis[2]~= nil and maxKPAlongAxis[2] or 0
     if not inAtmo then
      return spaceT
     elseif inspace == 0 then
      return atmoT
     else
      return spaceT + atmoT
     end
    end

    function NPP.getMaxKPA(self)
     return self:maxForceForward(), self:maxForceBackward()
    end

    function NPP.maxForceUp(self)
     local cOUP = {cOUPx, cOUPy, cOUPz}
     local tags = 'thrust analog not_ground '
     if bCM and gyro.isActive() == true then tags = tags .. 'lateral' else tags = tags .. 'vertical' end
     local maxKPAlongAxis = C.getMaxThrustAlongAxis(tags, cOUP)
     local spaceT = maxKPAlongAxis[3]~= nil and maxKPAlongAxis[3] or 0
     local atmoT = maxKPAlongAxis[1]~= nil and maxKPAlongAxis[1] or 0
     if not inAtmo then
      return spaceT
     elseif inspace == 0 then
      return atmoT
     else
      return spaceT + atmoT
     end
    end

    local function computeAxisAccel(AWDx, AWDy, AWDz, type)
     local cAV = C.getWorldVelocity()
     local cAVx, cAVy, cAVz = cAV[1], cAV[2], cAV[3]
     local WAFA = C.getWorldAirFrictionAcceleration()
     local WAFAx, WAFAy, WAFAz = WAFA[1], WAFA[2], WAFA[3]
     local gravityV = core.getWorldGravity()
     local gx, gy, gz = gravityV[1], gravityV[2], gravityV[3]

     if aggData.State == "ON" then
      local aggAD = alt - aggData.Altitude
      if abs(aggAD) < 240 and upInput == 0 then 
       if vectorLen(gx, gy, gz) > 0.01 and abs(aggAD) > 0.01 then
        local ngx, ngy, ngz = norm(gx, gy, gz) --toward the AGG height
        local velg = clamp(dotVec(cAVx, cAVy, cAVz, ngx, ngy, ngz),0,100) --current vel toward gravity (good)
        local tt = 1 --time to target height
        if type == "brake" then tt = clamp(abs(aggAD)/(velg*3),0,1) end--time to target
        local gVx, gVy, gVz = multiplyVec(ngx, ngy, ngz,velg*tt) --vector to nullify (because we want it)
        cAVx, cAVy, cAVz = cAVx-gVx, cAVy-gVy, cAVz-gVz
       end
       gx, gy, gz = 0,0,0
      end
     end

     local AxisSpeed = dotVec(cAVx, cAVy, cAVz, AWDx, AWDy, AWDz)
     local gravityAcc = dotVec(gx, gy, gz, AWDx, AWDy, AWDz)
     local fAirAcc = dotVec(WAFAx, WAFAy, WAFAz, AWDx, AWDy, AWDz)
     return AxisSpeed, gravityAcc, fAirAcc
    end

    local function awdAxis(axis)
     local AWDx, AWDy, AWDz = 0, 0, 0 --AxisWorldDirection
     if axis == "longitudinal" then
      AWDx, AWDy, AWDz = norm(cWOFx, cWOFy, cWOFz)
     elseif axis == "lateral" then
      AWDx, AWDy, AWDz = norm(cWORx, cWORy, cWORz)
     elseif axis == "vertical" then
      AWDx, AWDy, AWDz = norm(cWOUPx, cWOUPy, cWOUPz)
     end
     return AWDx, AWDy, AWDz
    end

    function NPP.composeAccelerationFromTargetSpeed(self,axis,speed) --axis: longitudinal / lateral / vertical // speed: in kmph
     tSpeed = clamp(speed, -self.mSK+10, self.mSK-10)
     if inAtmo and tSpeed ~= 0 then
      tSpeed = clamp(tSpeed, -self.aMS, self.aMS)
     end
     tSpeed = tSpeed * 0.27777777777

     local AWDx, AWDy, AWDz = awdAxis(axis)
     local AxisSpeed, gravityAcc, fAirAcc = computeAxisAccel(AWDx, AWDy, AWDz,"thrust")

     local Acc = 0
     if axis == "longitudinal" then
      self.TargetLongitudinalSpeedPID:inject(tSpeed - AxisSpeed)
      Acc = self.TargetLongitudinalSpeedPID:get()
     elseif axis == "lateral" then
      self.TargetLateralSpeedPID:inject(tSpeed - AxisSpeed)
      Acc = self.TargetLateralSpeedPID:get()
     elseif axis == "vertical" then
      self.TargetVerticalSpeedPID:inject(tSpeed - AxisSpeed)
      Acc = self.TargetVerticalSpeedPID:get()
     end
     if self.mM == "DRONE" then
      Acc = (tSpeed - AxisSpeed)
     end
     if autoLand == true and velMag > 3 and (planetVertSpeedMPS < 0 or not inAtmo) then
      Acc = (tSpeed - AxisSpeed) * 5
     end
     local AAG = Acc - gravityAcc - fAirAcc
     local FAx = AAG * AWDx
     local FAy = AAG * AWDy
     local FAz = AAG * AWDz
     return FAx, FAy, FAz
    end


    function NPP.composeBrakeAcceleration(self,axis,speed)
     tSpeed = speed ~= nil and speed * 0.27777777777 or 0
     local AWDx, AWDy, AWDz = awdAxis(axis)
     local AxisSpeed, gravityAcc, fAirAcc = computeAxisAccel(AWDx, AWDy, AWDz,"brake")

     local Acc = tSpeed - AxisSpeed
     if (brakeInput == 1 or autoLand == true) and velMag > 3 and (planetVertSpeedMPS < 0 or not inAtmo) then Acc = (tSpeed - AxisSpeed) * 10 end
     local aRAC = Acc - gravityAcc - fAirAcc
     return aRAC * AWDx, aRAC * AWDy, aRAC * AWDz
    end

    function NPP.composeAccelerationFromThrottle(self)
     local cM = C.getTotalMass()
     local throttleForce = 0
     if self.tV > 0 then
      local maxAtmoForceForward = self:maxForceForward()
      throttleForce = self.tV * maxAtmoForceForward
     elseif self.tV < 0 then
      local maxAtmoForceBackward = self:maxForceBackward()
      throttleForce = -self.tV * maxAtmoForceBackward
     end
     local Acc = throttleForce / cM
     local FAx = Acc * cWOFx
     local FAy = Acc * cWOFy
     local FAz = Acc * cWOFz

     if inAtmo and self.aMS > 0 and xyzSpeedKPH > self.aMS - 4 then
      local FAx1, FAy1, FAz1 = self:composeAccelerationFromTargetSpeed('longitudinal',self.aMS)
      if vectorLen(FAx1, FAy1, FAz1) < vectorLen(FAx, FAy, FAz) then return FAx1, FAy1, FAz1 end
     end
     return FAx, FAy, FAz
    end

    function NPP.updateHovers(self,input,hoA,mode)
     local dGS = unit.deactivateGroundEngineAltitudeStabilization
     if mode == "STATIC" then
      if input == 0 then
       if hoA ~= nil then
       hoA = clamp(hoA, 0, self.targetGAC[1])
        if Engines == true then
         unit.activateGroundEngineAltitudeStabilization(hoA)
        end
       end
      else
       dGS()
      end
     else dGS()
     end
    end

    function NPP.updateHovHeight(self,input)
     if P.ES.hoM.value == "STATIC" then
      system.print("lowering")
      P.ES.hoA.value = clamp(round(P.ES.hoA.value + input,1),0,self.targetGAC[1])
     end
    end

    function NPP.updateAggHeight(self,input)
     if aggData.State == "ON" and antigrav then
      P.ES.agA.value = clamp(math.floor(P.ES.agA.value + input),P.ES.agA.range[1],P.ES.agA.range[2])
      antigrav.setTargetAltitude(P.ES.agA.value) 
     end
    end

  onStart:
   lua: |
    -- CUSTOM WINDOWS --
    windowWidth = 260
    titleHeight = 25
    buttonWidth = 160
    buttonHeight = 25
    buttonGape = 5

    local TABLE = {}
    TABLE = {
     index = function (t,val)
      for i,v in ipairs(t) do
       if v == val then 
        return i
       end
      end
      return nil
     end,

     valUp = function (t,val)
      local index = TABLE.index(t,val)
      local newVal 
      if index == nil then
       newVal = t[1]
      elseif t[index+1] == nil then
       newVal = t[1]
      else
       newVal = t[index+1]
      end
      return newVal
     end,

     valDown = function (t,val)
      local index = TABLE.index(t,val)
      local newVal
      if index == nil then
       newVal = t[1]
      elseif t[index-1] == nil then
       newVal = t[#t]
      else
       newVal = t[index-1]
      end
      return newVal
     end,
    }

    function Save_Window_Pos(name,posX,posY)
     for i, v in ipairs(P) do
      if P.w_title == name then
       P.w_pos.x = posX
       P.w_pos.y = posY
       return
      else
       for k, l in ipairs(P[v]) do
        if P[v].w_title == name then
         P[v].w_pos.x = posX
         P[v].w_pos.y = posY
         return
        end
       end
      end
     end
     if name == P.help_menu.w_title then 
      P.help_menu.w_pos.x = posX
      P.help_menu.w_pos.y = posY
      return
     elseif name == P.QuickToolBar.w_title then 
      P.QuickToolBar.w_pos.x = posX
      P.QuickToolBar.w_pos.y = posY
      return
     end
     
     for i, v in pairs(P) do
      if string.sub (tostring(i),1,7) == "Widget_" and P[i].w_title == name then
       P[i].w_pos.x = posX
       P[i].w_pos.y = posY
       return
      end
     end
    end

    SubMenusButtonsClickFunction = function(v, l)
     return function()
      local tv = type(P[v][l].value)
      if CTRL == false then
       if mouseWheel == 0 then
        if tv == "number" then -- Set buttons functions
         P[v][l].increment = TABLE.valUp(P[v][l].step, P[v][l].increment)
        elseif tv == "string" then
         P[v][l].value = TABLE.valUp(P[v][l].range, P[v][l].value)
        elseif tv == "boolean" then
         P[v][l].value = not P[v][l].value
        elseif tv == "function" then
         P[v][l].value()
        end
       elseif mouseWheel > 0 then
        if tv == "number" then
         P[v][l].value = P[v][l].value + P[v][l].increment
         P[v][l].value = utils.clamp(P[v][l].value,P[v][l].range[1],P[v][l].range[2])
         if math.abs(P[v][l].value) < 0.0009 then P[v][l].value = 0 end
        elseif tv == "string" then
         P[v][l].value = TABLE.valUp(P[v][l].range, P[v][l].value)
        elseif tv == "boolean" then
         P[v][l].value = not P[v][l].value
        end
       elseif mouseWheel < 0 then
        if tv == "number" then
         P[v][l].value = P[v][l].value - P[v][l].increment
         P[v][l].value = utils.clamp(P[v][l].value,P[v][l].range[1],P[v][l].range[2])
         if math.abs(P[v][l].value) < 0.0009 then P[v][l].value = 0 end
        elseif tv == "string" then
         P[v][l].value = TABLE.valDown(P[v][l].range, P[v][l].value)
        elseif tv == "boolean" then
         P[v][l].value = not P[v][l].value
        end
       end
      else
       if P.w_open == true then
        P[v][l].q = not P[v][l].q
       end
      end
      updateParams()
      if v == "MS" then WindowLib:winlibCSSUpdate() end
      if P.QuickToolBar.w_open == true then checkWidgets() end
      windowsShow()
     end
    end

    function Cursor_Builder()
     if P.w_open == true or P.QuickToolBar.w_open == true then
      local cursorPos = vec2(WindowLib:getMousePos())
      local window = WindowLib:new(
       [[<div style='background:rgba(0, 0, 0, 0)'>
       <svg height="50" width="50">
       <polygon points="0,0 25,22.5 10,20 5,32.5" 
       stroke="lightsteelblue" stroke-width="1.5" fill="white"/>
       </svg></div>
       ]],{class = "widgets", name = "cursor", width = 50, height = 50, posX = cursorPos.x, posY = cursorPos.y, fixed = false, draggable = false, alwaysOnTop = true})
     end
    end

    function Quick_Menu_Builder()
     if P.w_open == false and ALT == true then
     system.showHelper(0)
      local svg = [[<style>
      .button {fill:]]..P.MS.WTC.value..[[; font-size:12px; text-anchor:end; font-family:Play; alignment-baseline:middle}
      </style>]]
      local buttons = {}
      local ind = 0
      -- Creating favorit buttons
      for i, v in ipairs(P) do
       for k, l in ipairs(P[v]) do
        if l ~= "separator" then
         if P[v][l].q == true then
          local increment = ""
          if P[v][l].increment ~= nil then increment = " (+-"..tostring(P[v][l].increment)..")" end
          if type(P[v][l].value) ~= "function" then
           svg = svg .. [["<text class="button" x="]]..windowWidth - 10 ..[[" y="]].. 15 + ind * (buttonHeight + buttonGape) ..[[" >]]..string.sub (tostring(P[v][l].value),1,10):upper()..increment..[[</text>"]]
          end
          local nb = WindowLib:buttonsNew(P[v][l].name, SubMenusButtonsClickFunction(v,l), {width = buttonWidth, height = buttonHeight, posX = 5, posY = (titleHeight + 5 + ind * (buttonHeight + buttonGape))})
          ind = ind + 1
          buttons[ind] = nb
         end
        end
       end
      end
      -- Creating the window t1
      if ind > 0 then
       local window = WindowLib:new(
        [[<div style='background:rgba(0, 0, 0, 0); text-align:middle; vertical-align: text-top'>
        <svg height="5000" width="500">
        ]]..svg..[[
        </svg></div>
        ]],
        {name = P.QuickToolBar.w_title, title = P.QuickToolBar.w_title, width = windowWidth, height = (titleHeight + ind*(buttonHeight+buttonGape)+buttonGape), posX = P.QuickToolBar.w_pos.x, posY = P.QuickToolBar.w_pos.y, fixed = false, draggable = true, alwaysOnTop = false},buttons)
      end
     end
    end

    function Params_Menu_Builder()
     if P.w_open == true then
      system.showHelper(0)
      local mainMenuButtons = {}
      local buttonClickFunction = nil
      local indMMB = 0
      local ind = 0
      --ComposeQuickToolMenu()
      for i, v in ipairs(P) do
       ind = 0
       local svg = [[<style>
       .button {fill:]]..P.MS.WTC.value..[[; font-size:12px; text-anchor:end; font-family:Play; alignment-baseline:middle}
       </style>]]
       local buttons = {}
       --Building the main menu bar buttons
       if P[v] ~= P.QuickToolBar then
        buttonClickFunction = function()
         P[v].w_open = not P[v].w_open
         WindowLib = WLP.init(system)
         Params_Menu_Builder()
         Help_Menu_Builder()
         Cursor_Builder()
        end
        local mmb = WindowLib:buttonsNew(P[v].w_title, buttonClickFunction, {width = windowWidth, height = buttonHeight, posX = (5 + indMMB * (windowWidth + buttonGape)), posY = 5})
        indMMB = indMMB + 1
        mainMenuButtons[indMMB] = mmb
       end
       --Building the windows buttons
       for k, l in ipairs(P[v]) do
        local increment = ""
        local QTBtag = ""
        if P[v].w_open == true then
         if l ~= "separator" then
          if P[v][l].increment ~= nil then increment = " (+-"..tostring(P[v][l].increment)..")" end
          if P[v][l].q == true then QTBtag = "*" end
          local nb = WindowLib:buttonsNew(P[v][l].name..QTBtag, SubMenusButtonsClickFunction(v,l), {width = buttonWidth, height = buttonHeight, posX = 5, posY = (titleHeight + 5 + (k-1) * (buttonHeight + buttonGape))})
          ind = ind + 1
          buttons[ind] = nb
          if type(P[v][l].value) ~= "function" then
           svg = svg .. [["<text class="button" x="]]..windowWidth - 10 ..[[" y="]].. 15 + (k-1) * (buttonHeight + buttonGape) ..[[" >]]..string.sub (tostring(P[v][l].value),1,10):upper()..increment..[[</text>"]]
          end
         else
          local nb = WindowLib:buttonsNew("", nil, {class= "separator", width = 0, height = 0, posX = 0, posY = (titleHeight + 5 + (k-1) * (buttonHeight + buttonGape))})
          ind = ind + 1
          buttons[ind] = nb
          svg = svg .. [["<line x1="5" y1="]].. 12 + (k-1) * (buttonHeight + buttonGape) ..[[" x2="]]..windowWidth - 10 ..[[" y2="]].. 12 + (k-1) * (buttonHeight + buttonGape) ..[[" stroke="]]..P.MS.BBC.value..[[" fill="None" stroke-width="0.5"/>"]]
         end
        end
       end
       
       -- Creating the sub menu window
       if ind > 0 and v ~= P.QuickToolBar then
        local ww = windowWidth
        local wclass = nil
        local whtml = ""
        local window = WindowLib:new(
        [[<div><svg height="1080" width="1920">
        ]]..svg..whtml..[[
        </svg></div>
        ]],
        {name = P[v].w_title, title = P[v].w_title, width = ww, height = (titleHeight + ind *(buttonHeight+buttonGape)+buttonGape), posX = P[v].w_pos.x, posY = P[v].w_pos.y, draggable = true},buttons)
       end
      end
      
      -- Creating the main menu bar window
      local window = WindowLib:new(
        [[<div><svg height="1080" width="3840">
        <text x="]]..((indMMB) * (windowWidth + buttonGape))..[[" y="17" font-size="16" font-family="Play" text-anchor="start" fill="]]..P.MS.BTC.value..[[">DEFAULT-- ]]..script.version..[[ by TheGreatSardini</text>
        </svg></div>
        ]],{name = P.w_title, width = 3840, height = buttonHeight + buttonGape , posX = P.w_pos.x, posY = P.w_pos.y, draggable = false},mainMenuButtons)
     end
    end

    function Help_Menu_Builder()
     if P.w_open == true and P.help_menu.w_open == true then
      local buttons = {}
      local svg = ""
      local ind = 0
      for i, v in ipairs(P.help_menu) do
       if v ~= "separator" then
        local help_button_function = function(v)
         return function()
           P.help_menu.w_html = P.help_menu[v].html
           WindowLib = WLP.init(system)
           Params_Menu_Builder()
           Help_Menu_Builder()
           Cursor_Builder()
           end
        end
        local nb = WindowLib:buttonsNew(P.help_menu[v].name, help_button_function(v), {width = buttonWidth, height = buttonHeight, posX = 5, posY = (titleHeight + 5 + (i-1) * (buttonHeight + buttonGape))})
        ind = ind + 1
        buttons[ind] = nb
       else
        local nb = WindowLib:buttonsNew("", nil, {class= "separator", width = 0, height = 0, posX = 0, posY = (titleHeight + 5 + (i-1) * (buttonHeight + buttonGape))})
        ind = ind + 1
        buttons[ind] = nb
        svg = svg .. [["<line x1="5" y1="]].. 12 + (i-1) * (buttonHeight + buttonGape) ..[[" x2="]]..buttonWidth - 5 ..[[" y2="]].. 12 + (i-1) * (buttonHeight + buttonGape) ..[[" stroke="]]..P.MS.BBC.value..[[" fill="None" stroke-width="0.5"/>"]]
       end
      end
      local ww = 800
      local whtml = P.help_menu.w_html
      local window = WindowLib:new(
      [[<div><svg height="1080" width="1920">
      ]]..svg..whtml..[[
      </svg></div>
      ]],
      {name = P.help_menu.w_title, title = P.help_menu.w_title, width = ww, height = (titleHeight + ind *(buttonHeight+buttonGape)+buttonGape), posX = P.help_menu.w_pos.x, posY = P.help_menu.w_pos.y, draggable = true},buttons)
     end
    end

    --function errors(err)
    -- system.print("ERROR: "..err)
    --end

    function processPcall(success, response)
     if not success then
      system.print("ERROR:"..response)
      return nil
     else
      return response
     end
    end

    function Widgets_Builder()
     if P.w_open == false then
      for i, v in ipairs(customWidgets) do
       if P["Widget_Custom"..i].w_open == true then
        local svg = processPcall(pcall(function() return customWidgets[i]:SVG_Update() end))
        local bt = processPcall(pcall(function() return customWidgets[i]:getButtons() end))
        local tt = processPcall(pcall(function() return customWidgets[i]:getTitle() end))
        if svg and bt then -- and bt and tt 
         --system.print("before4")
         local nbt = {}
         for i2, v2 in ipairs(bt) do
          nbt[i2] = WindowLib:buttonsNew(v2[1], v2[2], v2[3])
         end
         if #nbt == 0 then nbt = nil end
         local draggable = true
         if customWidgets[i].draggable == 0 then draggable = false end
         local window = WindowLib:new(svg,
          {class = customWidgets[i].class,
          name = P["Widget_Custom"..i].w_title,
          title = tt,
          width = P["Widget_Custom"..i].w_size.x*P["Widget_Custom"..i].w_scale, 
          height = P["Widget_Custom"..i].w_size.y*P["Widget_Custom"..i].w_scale, 
          posX = P["Widget_Custom"..i].w_pos.x, 
          posY = P["Widget_Custom"..i].w_pos.y, 
          draggable = customWidgets[i].draggable,
          fixed = customWidgets[i].fixed},
          nbt)
        end
       end
      end

      if P.Widget_HUD.w_open == true then
       local svg = widget:HUD_Update()
       local window = WindowLib:new(svg,{class = "widgets", name = P.Widget_HUD.w_title, width = P.Widget_HUD.w_size.x*P.Widget_HUD.w_scale, height = P.Widget_HUD.w_size.y*P.Widget_HUD.w_scale, posX = P.Widget_HUD.w_pos.x, posY = P.Widget_HUD.w_pos.y, draggable = true})
      end
      if P.Widget_Platform.w_open == true then
       local svg = widget:Platform_Update()
       local window = WindowLib:new(svg,{class = "widgets", name = P.Widget_Platform.w_title, width = P.Widget_Platform.w_size.x*P.Widget_Platform.w_scale, height = P.Widget_Platform.w_size.y*P.Widget_Platform.w_scale, posX = P.Widget_Platform.w_pos.x, posY = P.Widget_Platform.w_pos.y, draggable = true})
      end
      if P.Widget_Info.w_open == true then
       local svg = widget:Info_Update()
       local window = WindowLib:new(svg,{class = "widgetnopadding", title = "INFO", name = P.Widget_Info.w_title, width = 307*P.Widget_Info.w_scale, height = info_window_height*P.Widget_Info.w_scale, posX = P.Widget_Info.w_pos.x, posY = P.Widget_Info.w_pos.y, draggable = true})
      end
     end
    end
  onStart:
   lua: |
    -- ON START PARAMS --
    function onStartParams()
     system.print("Loading onStartParams")
     hasFinishedLoading = false
     system.showScreen(1)

     info_w_height = 0
     fps = 0
     uCount = 0

     nullvector = vec3(0,0,0)

     cursorX = 860
     cursorY = 440
     cursorWin = ""
     reset = false
     mouseWheel = 0
     mwCLICK = false
     CLICK = false
     CTRL = false
     ALT = false
     SHIFT = false
     GEAR = false

     pitchInput = 0
     rollInput = 0
     yawInput = 0
     brakeInput = 0
     strafeInput = 0
     upInput = 0
     forwardInput = 0
     boosterInput = 0
     ThrottlePos = 0

     previousDeltaY = 0
     previousDeltaX = 0

     xSpeedKPH = 0
     ySpeedKPH = 0
     zSpeedKPH = 0
     xyzSpeedKPH = 0
     velMag = 0
     Az = 0
     Ax = 0
     Ax0 = 0
     Ay0 = 0
     maxAcceleration = 0

     MM = "TRAVEL"
     pkM = true

     VStabPrevAlt = 0
     VStabPrevPosx, VStabPrevPosy, VStabPrevPosz = 0, 0, 0
     targetAutoPitchDeg = 0
     VStabAltLock = nil
     VStabCount = 0
     VStabAdjustedAngle = 0
     SAMflat = false
     turnAssist_toggle = false
     atmoSpeedLock = true

     PKP = ""
     PKPT = 999
     DTK = ""
     Engines = false

     landPos = nullvector
     fuelTanksData = {}
     unitData = {}
     aggData = {}
     warpData = {}

     --DRONE
     modeRocket = false
     rocketWarmup = false

     --AUTO LAND
     autoLand = false
     autoStart = false
     autoStartTime = 0
     landTime = 0

     -- BRAKING
     gravityA = 0
     atmosDensity = 0
     LastMaxBrakeInAtmo = 0
     LastMaxBrake = 0
     Gnd = AboveGroundLevel()
     hasGndDet = telemeter ~= nil and true or vBooster ~= nil and true or hover ~= nil and true or false
     hasATelemeter = telemeter ~= nil and true
     bCM = false -- brake CROSS Mode
     approachSpeed = 0
     approachSpeedZ = 0
     BrakeToggle = false

     -- THRUST
     TargetSpeed = {0,0,0}
     ThrustAcc = {0,0,0}
     BrakeAcc = {0,0,0}


     -- Autopilot
     LowOrbitHeight = 2000
     nearPlanet = true
     ahDoubleClick = 0

     warpInfo = ""
     cWOUPx, cWOUPy, cWOUPz = 0, 0, 0
     cWOFx, cWOFy, cWOFz = 0, 0, 0
     cWORx, cWORy, cWORz = 0, 0, 0

     cOUPx, cOUPy, cOUPz = 0, 0, 0
     cOFx, cOFy, cOFz = 0, 0, 0
     cORx, cORy, cORz = 0, 0, 0

     planetVertSpeedMPS = 0
     cWAVx, cWAVy, cWAVz = 0,0,0
     wVx, wVy, wVz = 0,0,0
     gravity = 0

     brakeFact = 0
     maxSafeVel = 0

     BackBurn = false
     BackBurnToggle = false
     PreviousACM = nil
     resetingBackBurn = false
     MaxBrakesForce = 0

     parkingModeLockOut = false

     vec2 = require "cpml.vec2"
     if DB ~= nil then
      system.print("Databank found")
      Data = dtbk.new(DB_1)
      system.print("Databank new created")
     else system.print("No Databank linked, please connect one and restart the script!") unit.exit()
     end
     local Atlas = require "atlas"
     Helios = Atlas[0]
     Atlas = nil
     system.print("Atlas loaded")
     Nav = NPP.new()
     Nav:buildPIDs()
     system.print("Navigator-- new created")
     widget = WidgetsPlusPlus.new()
     system.print("Widgets-- new created")

     local function pRequire(libName)
      return xpcall( require, system.print, libName)
     end
     customWidgets = {}
     
     for i=1, 25 do
      local fileName = "autoconf.custom.WIDGETS--.widget--custom"..i
      if pRequire(fileName) ~= false then
       require (fileName)
       system.print("Widgets-- Custom"..i.." loaded")
       customWidgets[i] = WidgetsPlusPlusCustom.new(core, unit, (DB ~= nil) and DB or nil, (antigrav ~= nil) and antigrav or nil, (warpdrive ~= nil) and warpdrive or nil, (shield ~= nil) and shield or nil, (switch ~= nil) and switch or nil, player, telemeter)
       P.Widgets_Custom[i] = "w_custom"..i
       P.Widgets_Custom["w_custom"..i] = {name = "CUSTOM 1", value = "None", range = {"Default --", "ALT", "None"}, q = false}
       P.Widgets_Custom["w_custom"..i].name = customWidgets[i]:getName()
       P["Widget_Custom"..i] = {
        w_title = customWidgets[i]:getName(),
        w_pos = customWidgets[i]:getPos(),
        w_size = customWidgets[i]:getSize(),
        w_scale = pcall( function () return type(customWidgets[i]:getScale()) end ) and customWidgets[i]:getScale() or 1,
        w_open = false,
       }
       --system.print(P["Widget_Custom"..i]w_scale)
       system.print("Widgets-- Custom"..i.." new created")
       if type(customWidgets[i].loadData) == 'function' and DB_1 ~= nil then
        customWidgets[i]:loadData()
        system.print("Widgets-- Custom"..i.." data loaded")
       end
      else
       break
      end
     end
     system.print("Finished loading custom widgets: "..#customWidgets)

     WindowLib = WLP.init()
     system.print("winlib-- new created")

     gearExtended = (unit.isAnyLandingGearDeployed() == true)
     if gearExtended then
      unit.deployLandingGears()
     else
      unit.retractLandingGears()
     end
     unit.switchOnHeadlights()
     Nav:updateHovers(upInput,P.ES.hoA.value,P.ES.hoM.value)

     local function decodeJSON(json)
       local decodedInput = string.gsub(json, "%\\u(%x%x%x%x)", function(a) return utf8.char(tonumber(a,16))end)
       return load('return ' .. decodedInput:gsub('[[]', '{'):gsub('[]]', '}'):gsub('"(%w+)":', '["%1"]='))()
      end
     local RemoteControl = false
     local helperId = decodeJSON(unit.getWidgetData())["helperId"] if helperId == nil then helperId = "nan" end
     local name = decodeJSON(unit.getWidgetData())["name"] if name == nil then name = "nan" end
     system.print(tostring(helperId))
     system.print(tostring(name))

     if helperId == "basic_control_unit" or unit.isRemoteControlled() == true then RemoteControl = true end
     if RemoteControl == true then
      player.freeze(1)
      system.print("Is remote controled")
      P.KP.mvL.value = true
      P.KP.mvL.q = true
     end

     local function merge(t1, t2)
      if type(t1) ~= "table" or type(t2)~= "table" then return nil end
      local newT = t1
      local ind = #t1
      for k,v in pairs(t2) do
       ind = ind + 1
       newT[ind] = v
      end 
      return newT
     end
     fueltanks_size = atmofueltank_size + spacefueltank_size + rocketfueltank_size
     fueltanks = {}
     fueltanks = merge(fueltanks,atmofueltank) or fueltanks
     fueltanks = merge(fueltanks,spacefueltank) or fueltanks
     fueltanks = merge(fueltanks,rocketfueltank) or fueltanks
     system.print("Merged fuel tanks")
     prevFTD = 0
    end
  onStart:
   lua: |
    -- Keybinds library --
    local sSS = true
    local tFactor = 1
    local altPreset = 0
    local function checkKeybinds(option)
     --system.print("Option "..option)
     if string.sub(P.KP.mouseControlKB.value,-1,-1) == option then
      system.print("Toggling mouse control")
      P.KP.moC.value = not P.KP.moC.value
     elseif string.sub(P.KP.movementLockKB.value,-1,-1) == option then
      system.print("Toggling movement lock")
      P.KP.mvL.value = not P.KP.mvL.value
     elseif string.sub(P.KP.viewLockKB.value,-1,-1) == option then
      system.print("Toggling view lock")
      P.KP.viL.value = not P.KP.viL.value
     elseif string.sub(P.KP.flightModeKB.value,-1,-1) == option then
      if P.KP.flM.value == "CRUISE" then
        setControlMasterMode("TRAVEL")
      elseif P.KP.flM.value == "TRAVEL" then
        setControlMasterMode("CRUISE")
      end
     elseif string.sub(P.KP.altitudeAP.value,-1,-1) == option then
      if (time - ahDoubleClick) < 1.5 then
       if hasAtmosphere then
        if inAtmo then
         HoldAltitude = spaceEngineMinAltitude - 0.01*noAtmosphericDensityAltitude
         system.print("Altitude Locked to 11% atmo.")
        else
         if nearPlanet then
          HoldAltitude = noAtmosphericDensityAltitude + LowOrbitHeight
         end
        end
        ahDoubleClick = -1
        if HoldAltitude ~= nil then return end
       end
      else
       ahDoubleClick = time
      end
      if HoldAltitude ~= nil then 
       HoldAltitude = nil 
       ahDoubleClick = 0
      elseif ahDoubleClick > -1 then --not in deep space
       HoldAltitude = round(alt) 
      end
      autoLand, autoStart = false,false
      if HoldAltitude ~= nil then Nav:prepareForFlight() end
      return
     elseif string.sub(P.KP.speedLockKB.value,-1,-1) == option then
      atmoSpeedLock = not atmoSpeedLock
      if atmoSpeedLock == true then Nav:setAtmoMaxSpeed(P.ES.aMS.value) system.print("Atmospheric speed limit activated")
      else Nav:setAtmoMaxSpeed(49999) system.print("Atmospheric speed limit deactivated") end
     elseif string.sub(P.KP.showScreenKB.value,-1,-1) == option then
      system.print("Toggling system.showScreen")
      sSS = not sSS
      if sSS == true then system.showScreen(1) else system.showScreen(0) end
     end
     updateParams()
    end
    
    local ticks = {}
    function keyBindsOnStartControl(a) -- action
     local time = system.getArkTime()-0.03 -- usually the aproximate repeat interval
     if not ticks[a] then ticks[a] = {} end
     ticks[a]["t"] = time
     if a ~= nil then
      --system.print('on a start: '..a)
      for i, widget in ipairs(customWidgets) do
       if type(customWidgets[i].onActionStart) == 'function' then
        local _ = processPcall(pcall(function() return customWidgets[i]:onActionStart(a) end))
       end
      end
     end
     if a == 'option1' then
      P.w_open = not P.w_open
      P.QuickToolBar.w_open = false
      if P.w_open == false then
       windowsHide()
      else windowsShow() end
      ALT = false
     elseif a == 'option2' then
      -- TODO use this?
     elseif a == 'option3' then
      checkKeybinds("3")
     elseif a == 'option4' then
      checkKeybinds("4")
     elseif a == 'option5' then
      checkKeybinds("5")
     elseif a == 'option6' then
      checkKeybinds("6")
     elseif a == 'option7' then
      checkKeybinds("7")
     elseif a == 'option8' then
      checkKeybinds("8")
     elseif a == 'option9' then
      checkKeybinds("9")
     elseif a ~= 'lalt' and a ~= 'lshift' and not (a == 'brake' and velMag < 1) and a ~= 'gear' then 
      enginesToggle()
     end
     if P.w_open == true then
      system.showHelper(0)
      if a == 'stopengines' or a == 'leftmouse' then
       WindowLib:toggleClick(true)
      elseif a == 'brake' then
       CTRL = true
      end
     elseif P.QuickToolBar.w_open == true then
      system.showHelper(0)
      if a == 'stopengines' or a == 'leftmouse' then
       WindowLib:toggleClick(true)
      end
     elseif MM == "CRUISE" or MM == "TRAVEL" then
      if a == 'brake' then
       if DTK ~= "brake" and Nav:getMasterMode() == "CRUISE" then
        if Nav:getThrottleValue() > constants.epsilon then
         Nav:updateThrottleValue(-0.5)
        end
       end
      end
     elseif MM == "PLATFORM" then
      if a == 'stopengines' then
       if pkM then modeRocket = false else modeRocket = not modeRocket end
      end
     elseif MM == "DRONE" then
      if a == 'stopengines' then
       if pkM then modeRocket = false else modeRocket = not modeRocket end
       if modeRocket then self.warmup = true else self.warmup = false VStabAltLock = nil end
      end     
     end

     -- Shared Actions for all Modes --
     if P.w_open == false and P.QuickToolBar.w_open == false then
      tFactor = 1
      if PKP == a and currentTime - PKPT < P.KP.dTT.value then 
       DTK = a 
       --system.print("Double tap: "..a) 
      end
      PKP = a -- previous keypress
      PKPT = currentTime
      --system.print(a.."|"..MM)

      if a == 'speedup' then
       Nav:updateThrottleValue(0.1)
      elseif a == 'speeddown' then
       Nav:updateThrottleValue(-0.1)
      elseif a == 'stopengines' then
       if Nav:getThrottleValue() == 0 then
        Nav:setThrottleValue(49999)
       else
        Nav:resetThrottleValue()
        Nav:setThrottleValue(0)
       end
       mwCLICK = true
       autoLand, autoStart = false,false
      elseif a == 'forward' then
       autoLand, autoStart = false,false
       modeRocket = false
       HoldAltitude = nil
      elseif a == 'backward' then
       autoLand, autoStart = false,false
       modeRocket = false
       HoldAltitude = nil
      elseif a == 'yawright' then
      elseif a == 'yawleft' then
      elseif a == 'right' then
       autoLand, autoStart = false,false
      elseif a == 'left' then
       autoLand, autoStart = false,false
      elseif a == 'straferight' then
       autoLand, autoStart = false,false
       modeRocket = false
      elseif a == 'strafeleft' then
       autoLand, autoStart = false,false
       modeRocket = false
      elseif a == 'up' then
       Nav:updateHovers(1,nil,P.ES.hoM.value)
       autoLand, autoStart = false,false
       HoldAltitude = nil
      elseif a == 'down' then
       Nav:updateHovers(-1,nil,P.ES.hoM.value)
       autoLand, autoStart = false,false
       HoldAltitude = nil
       landTime = time
      elseif a == 'lshift' then
       SHIFT = true
      elseif a == 'lalt' then
       system.showHelper(0)
       ALT = true
       if DTK == 'lalt' then
        P.QuickToolBar.w_open = true
        windowsShow()
       end
      elseif a == 'brake' then
       CTRL = true
       brakeInput = 1
       autoLand, autoStart = false,false
      elseif a == 'gear' then
       GEAR = true
       modeRocket = false
       HoldAltitude = nil
       toggleLandingGearCheck()
       if geL then 
        if not withinParkingRange() or autoLand or DTK == 'gear' or P.KP.flM.value == "DRONE" or P.KP.flM.value == "PLATFORM" then 
         enableAutoLand()
        else
         setParkingMode(not pkM)
         parkingModeLockOut = not pkM
        end
       else
        if withinParkingRange() and Engines == false then
         enginesToggle()
         enableAutoStart()
        else
         enableAutoLand()
        end
       end
      elseif a == 'light' then
       if unit.isAnyHeadlightSwitchedOn() == true then
        unit.switchOffHeadlights()
       else
        unit.switchOnHeadlights()
       end
      elseif a == 'booster' then
      elseif a == 'antigravity' then
       if antigrav ~= nil then antigrav.toggle() end
      elseif a == 'warp' then
      end
     end
    end

    local ctrl_alt = false
    function keyBindsOnStopControl(a)
     if a ~= nil then
      --system.print('on a start: '..a)
      for i, widget in ipairs(customWidgets) do
       if type(customWidgets[i].onActionStop) == 'function' then
        local _ = processPcall(pcall(function() return customWidgets[i]:onActionStop(a) end))
       end
      end
     end
     if a == DTK then 
      --system.print("Double tap released: "..DTK) 
      DTK = "" 
     end
     if P.w_open == true then
      if a == 'stopengines' or a == 'leftmouse' then
       WindowLib:toggleClick(false)
      elseif a == 'brake' then
       CTRL = false
      end
     elseif P.QuickToolBar.w_open == true then
      system.showHelper(1)
      if a == 'stopengines' or a == 'leftmouse' then
       WindowLib:toggleClick(false)
      elseif a == 'lalt' then
       P.QuickToolBar.w_open = false
       ALT = false
       windowsHide()
      end
     end
     if (a ~= 'lshift' and (SHIFT == false or SHIFT == true and P.KP.shL.value == false) and MM ~= "DRONE") or MM == "DRONE" then else return end
     if MM == "CRUISE" or MM == "TRAVEL" or MM == "DRONE" then
      if a == 'forward' then
       pitchInput = 0
      elseif a == 'backward' then
       pitchInput = 0
      elseif a == 'right' then
       if P.KP.iCo.value == false then
       rollInput = 0 else yawInput = 0 end
      elseif a == 'left' then
       if P.KP.iCo.value == false then
       rollInput = 0 else yawInput = 0 end
      end
     elseif MM == "PLATFORM" then
      if a == 'forward' then
       forwardInput = 0
      elseif a == 'backward' then
       forwardInput = 0
      elseif a == 'right' then
       strafeInput = 0
      elseif a == 'left' then
       strafeInput = 0
      end
     elseif a == 'lshift' then SHIFT = false
     end
     -- Shared Actions for all modes
     if P.w_open == false and P.QuickToolBar.w_open == false then
      if a == 'stopengines' then
       mwCLICK = false
      elseif a == 'yawright' then
       if P.KP.iCo.value == false then
       yawInput = 0 else rollInput = 0 end
      elseif a == 'yawleft' then
       if P.KP.iCo.value == false then
       yawInput = 0 else rollInput = 0 end
      elseif a == 'straferight' then
       strafeInput = 0
      elseif a == 'strafeleft' then
       strafeInput = 0
      elseif a == 'up' then
       upInput = 0
       Nav:updateHovers(upInput,P.ES.hoA.value,P.ES.hoM.value)
      elseif a == 'down' then
       upInput = 0
       Nav:updateHovers(upInput,P.ES.hoA.value,P.ES.hoM.value)
      elseif a == 'brake' then
       CTRL = false
       if ALT == false and ctrl_alt == false and P.KP.bTM.value == false then brakeInput = 0 end
       if ctrl_alt then ctrl_alt = false end
       if P.KP.bTM.value then 
        BrakeToggle = not BrakeToggle
        brakeInput = BrakeToggle and 1 or 0
       end
      elseif a == 'gear' then
       GEAR = false
      elseif a == 'light' then
      elseif a == 'booster' then
      elseif a == 'antigravity' then
      elseif a == 'warp' then
      elseif a == 'lshift' then
       SHIFT = false
      elseif a == 'lalt' then
       if CTRL then ctrl_alt = true else ctrl_alt = false end
       ALT = false
      end
     end
    end

    local clamp = utils.clamp
    local function inc(a)
     if DTK == a then return 1 end
     return ticks[a].d / P.KP.kWU.value
    end
    local function yI(val,a) yawInput = clamp(yawInput + val*inc(a),-1,1) end
    local function pI(val,a) pitchInput = clamp(pitchInput + val*inc(a),-1,1) end
    local function rI(val,a) rollInput = clamp(rollInput + val*inc(a),-1,1) end
    local function uI(val,a) upInput = clamp(upInput + val*inc(a),-1,1) end
    local function fI(val,a) forwardInput = clamp(forwardInput + val*inc(a),-1,1) end
    local function sI(val,a) strafeInput = clamp(strafeInput + val*inc(a),-1,1) end

    function keyBindsOnLoopControl(a)
     tFactor = utils.clamp(tFactor * 1.01 + 0.1,1,1000)
     if a == nil then return end
     local time = system.getArkTime()
     ticks[a]["d"] = time - ticks[a].t
     ticks[a]["t"] = time
 
     --system.print('on a start: '..a)
     for i, widget in ipairs(customWidgets) do
      if type(customWidgets[i].onActionLoop) == 'function' then
       local _ = processPcall(pcall(function() return customWidgets[i]:onActionLoop(a) end))
      end
     end

     --shared
     if a == 'straferight' then
      sI(1,a)
     elseif a == 'strafeleft' then
      sI(-1,a)
     elseif a == 'up' then
      uI(1,a)
     elseif a == 'down' then
      uI(-1,a)
      checkLanded()
     elseif a == 'speedup' then
      Nav:updateThrottleValue(0.02*tFactor)
     elseif a == 'speeddown' then
      Nav:updateThrottleValue(-0.02*tFactor)
     elseif a == 'groundaltitudeup' then
      Nav:updateHovHeight(0.1*tFactor)
      Nav:updateHovers(upInput,P.ES.hoA.value,P.ES.hoM.value)
      if HoldAltitude then HoldAltitude = math.floor(HoldAltitude + (5 * tFactor)) end
      Nav:updateAggHeight(1*tFactor)
     elseif a == 'groundaltitudedown' then
      Nav:updateHovHeight(-0.1*tFactor)
      Nav:updateHovers(upInput,P.ES.hoA.value,P.ES.hoM.value)
      if HoldAltitude then HoldAltitude = math.floor(HoldAltitude - (5 * tFactor)) end
      Nav:updateAggHeight(-1*tFactor)
     --separate
     elseif MM == "PLATFORM" then
      if a == 'yawright' then
       yI(-1,a)
      elseif a == 'yawleft' then
       yI(1,a)
      elseif a == 'forward' then
       fI(1,a)
      elseif a == 'backward' then
       fI(-1,a)
      elseif a == 'right' then
       sI(1,a)
      elseif a == 'left' then
       sI(-1,a)
      end
     else
      if a == 'forward' then
       pI(-1,a)
      elseif a == 'backward' then
       pI(1,a)
      elseif a == 'yawright' then
       if P.KP.iCo.value == false then
       yI(-1,a) else rI(1,a) end
      elseif a == 'yawleft' then
       if P.KP.iCo.value == false then
        yI(1,a) else rI(-1,a) end
      elseif a == 'right' then
       if P.KP.iCo.value == false then
        rI(1,a) else yI(-1,a) end
      elseif a == 'left' then
       if P.KP.iCo.value == false then
        rI(-1,a) else yI(1,a) end
      elseif a == 'brake' then
       if DTK ~= "brake" and Nav:getMasterMode() == "CRUISE" then
        if Nav:getThrottleValue() > constants.epsilon then
         Nav:updateThrottleValue(-0.05)
        end
       end
      end
     end


    end
    
  onStart:
   lua: |
    -- Divers Functions --
    function getGlobals()
     currentWorldPos = vec3(construct.getWorldPosition())
     closestPlanetIndex = 0
     local planetDistance = 999999999999
     for i, v in pairs(Helios) do
      if (currentWorldPos - vec3(v.center)):len() < planetDistance then
       planetDistance = (currentWorldPos - vec3(v.center)):len()
       closestPlanetIndex = i
      end
     end
     planet = Helios[closestPlanetIndex]
     currentPlanetName = planet.name[1]
     currentPlanetRadius = planet.radius --TODO Remove?
     currentPlanetCenter = planet.center
     currentPlanetGM = planet.GM
     currentPlanetMaxStatic = planet.maxStaticAltitude
     hasAtmosphere = planet.hasAtmosphere
     local altTable = { [1]=6637, [2]=3426, [4]=7580, [26]=4242, [27]=4150, [3]=21452, [6]=4498, [7]=6285, [8]=3434, [9]=5916 } -- Measured min space engine altitudes for: Madis, Alioth, Talemai, Sanctuary, Haven, Sicari, Sinnen, Thades, Teoma, Jago
     spaceEngineMinAltitude = altTable[planet.id] or 0.5353125*(planet.atmosphereThickness)
     noAtmosphericDensityAltitude = planet.atmosphereThickness or 0


     local function vectorLen(x,y,z)
      return math.sqrt(x * x + y * y + z * z)
     end
     local cWCOM = construct.getWorldCenterOfMass()
     local cWCOMx, cWCOMy, cWCOMz = cWCOM[1], cWCOM[2], cWCOM[3]
     local cPCx, cPCy, cPCz = currentPlanetCenter[1], currentPlanetCenter[2], currentPlanetCenter[3]
     alt = vectorLen(cWCOMx-cPCx, cWCOMy-cPCy, cWCOMz-cPCz) - planet.radius or 0

     --TODO Fix this
     inspace = 0
     atmosDensity = unit.getAtmosphereDensity()
     inAtmo = false or (alt < noAtmosphericDensityAltitude and atmosDensity > 0.00001 )
     if atmosDensity < 0.075 then
      inspace = 1
     end

     nearPlanet = unit.getClosestPlanetInfluence() > 0 or (alt > 0 and alt < 200000)
     
     MM = Nav:getMasterMode()
     coreMass = construct.getTotalMass()
     maxSafeVel = inAtmo and construct.getFrictionBurnSpeed() or unitData.maxSpeedMPS ~= nil and unitData.maxSpeedMPS or 900
    end

    function paramsSetColorsRange()
     for i, v in ipairs (P.MS) do
      if type(P.MS[v]) == "table" then
       if P.MS[v].value then
        if type( P.MS[v].value) == "string" and v ~= "PRESET" and v ~= "HELP_MENU" then
         for k, l in ipairs (webColors.namedColors) do
          P.MS[v].range[#P.MS[v].range+1] = l
         end
        end
       end
      end
     end
    end


    function checkWidgets()
     hideAllDefaultWidgets()
     -- SPEEDOMETER 
     if P.w_open == false then
      -- HUD
      if P.WS.w_hud.value == "None" then
       P.Widget_HUD.w_open = false
      else
       P.Widget_HUD.w_open = true
      end

      -- Info
      if P.WS.w_info.value == "None" then
       P.Widget_Info.w_open = false
      else
       P.Widget_Info.w_open = true
      end

      -- Platform
      if P.WS.w_platform.value == "None" then
       P.Widget_Platform.w_open = false
      else
       P.Widget_Platform.w_open = true
      end

      -- SPEEDO
      if P.WS.w_speedometer.value == "Default" then
       if unit then unit.showWidget() end
      end

      -- GYRO
      if P.WS.w_gyro.value == "Default" then
       if gyro then gyro.showWidget() end
      end

      -- FUEL
      if P.WS.w_fuel.value == "Default" then
       if atmofueltank then
        if atmofueltank_size > 0 then
         _autoconf.displayCategoryPanel(atmofueltank, atmofueltank_size, L_TEXT("ui_lua_w_atmofuel", "Atmo Fuel"), "fuel_container")
        end
       end
       if spacefueltank then
        if spacefueltank_size > 0 then
         _autoconf.displayCategoryPanel(spacefueltank, spacefueltank_size, L_TEXT("ui_lua_w_spacefuel", "Space Fuel"), "fuel_container")
        end
       end
       if rocketfueltank then
        if rocketfueltank_size > 0 then
         _autoconf.displayCategoryPanel(rocketfueltank, rocketfueltank_size, L_TEXT("ui_lua_w_rocketfuel", "Rocket Fuel"), "fuel_container")
        end
       end
      end

      -- CORE
      if (P.WS.w_core.value == "Default" and ALT == false) or (P.WS.w_core.value == "ALT" and ALT == true)then
       if core then core.showWidget() end
      end

      -- RADAR
      if (P.WS.w_radar.value == "Default" and ALT == false) or (P.WS.w_radar.value == "ALT" and ALT == true)then
       if #radar ~= 0 then
        _autoconf.displayCategoryPanel(radar, radar_size, L_TEXT("ui_lua_widget_radar", "Radar"), "radar")
       end
      end

      -- PERISCOPE
      if (P.WS.w_periscope.value == "Default" and ALT == false) or (P.WS.w_periscope.value == "ALT" and ALT == true)then
       if #radar ~= 0 then
        local rdr = radar_1.getOperationalState() == 1 and {radar_1} or {radar_2} or {radar_1}
        if rdr then _autoconf.displayCategoryPanel(rdr, 1, L_TEXT("ui_lua_w_periscope", "Periscope"), "periscope") end
       end
      end

      -- AGG
      if (P.WS.w_agg.value == "Default" and ALT == false) or (P.WS.w_agg.value == "ALT" and ALT == true)then
       if antigrav then antigrav.showWidget() end
      end

      -- WARP
      if (P.WS.w_warp.value == "Default" and ALT == false) or (P.WS.w_warp.value == "Auto" and warpData.Info:lower() == "activate warp") or (P.WS.w_warp.value == "ALT" and ALT == true)then
       if warpdrive then warpdrive.showWidget() end
      end

      -- PARENTING
      if (P.WS.w_parenting.value == "Default" and ALT == false) or (P.WS.w_parenting.value == "ALT" and ALT == true)then
       parentingPanelId = system.createWidgetPanel("Docking")
       parentingWidgetId = system.createWidget(parentingPanelId,"parenting")
       system.addDataToWidget(unit.getDataId(),parentingWidgetId)
      end

      -- COMBAT STRESS
      if (P.WS.w_cstress.value == "Default" and ALT == false) or (P.WS.w_cstress.value == "ALT" and ALT == true)then
       coreCombatStressPanelId = system.createWidgetPanel("Core combat stress")
       coreCombatStressgWidgetId = system.createWidget(coreCombatStressPanelId,"core_stress")
       system.addDataToWidget(core.getDataId(),coreCombatStressgWidgetId)
      end

      -- SHIELD
      if (P.WS.w_shield.value == "Default" and ALT == false) or (P.WS.w_shield.value == "ALT" and ALT == true) then
       if shield then shield.showWidget() end
      end

      for i, v in ipairs(P.Widgets_Custom) do
       if (P.Widgets_Custom["w_custom"..i].value == "Default --" and ALT == false) or (P.Widgets_Custom["w_custom"..i].value == "ALT" and ALT == true) then
        P["Widget_Custom"..i].w_open = true
       elseif P.Widgets_Custom["w_custom"..i].value == "None" or (P.Widgets_Custom["w_custom"..i].value == "ALT" and ALT == false) then
        P["Widget_Custom"..i].w_open = false
       end
      end
     end
    end

    function hideAllDefaultWidgets()
     if core then core.hideWidget() end
     if unit then unit.hideWidget() end
     if gyro then gyro.hideWidget() end
     if antigrav then antigrav.hideWidget() end
     if warpdrive then warpdrive.hideWidget() end
     if shield then shield.hideWidget() end
     _autoconf.hideCategoryPanels()
     system.destroyWidgetPanel(parentingPanelId)
     system.destroyWidgetPanel(coreCombatStressPanelId)
    end

    function windowsShow()
     system.lockView(1)
     player.freeze(1)
     WindowLib = WLP.init(system)
     checkWidgets()
     Cursor_Builder()
     Params_Menu_Builder()
     Help_Menu_Builder()
     Widgets_Builder()
     Quick_Menu_Builder()
    end

    function windowsHide()
     if P.KP.mvL.value == false then player.freeze(0) else player.freeze(1) end
     if P.KP.viL.value == false then system.lockView(0) else system.lockView(1) end
     WindowLib = WLP.init()
     checkWidgets()
     Params_Menu_Builder()
     Help_Menu_Builder()
     Widgets_Builder()
     Quick_Menu_Builder()
     Cursor_Builder()
    end

    function setParamsFuelTanks()
     for i, v in ipairs(fuelTanksData) do
      P["Widget_FuelTank_"..i] = {
       w_title = "FUEL TANK "..i,
       w_pos = {x=150+i*99, y=150},
       w_open = false,
       w_scale = 1.5
       }
     end
    end

    function enginesToggle()
     if P.ES.eng.value == "AUTO" then 
      if Engines == false then
       Engines = true
       system.print("Engines ON")
      end
     elseif P.ES.eng.value == "OFF" and Engines == true then
      Engines = false
      system.print("Engines OFF")
     elseif P.ES.eng.value == "ON" and Engines == false then
      Engines = true
      system.print("Engines ON")
     end
    end

    function setControlMasterMode(mode)
     Nav:setMasterMode(mode)
     if mode ~= P.KP.flM.value then
      P.KP.flM.value = mode--Nav:getMasterMode()
      system.print(mode.." mode set")
      updateEngines()
     end
    end

    colorPresets = {
     preset0 = {TC = "olive",
      TCA = 1,
      TTC = "black",
      WC = "dimgray",
      WCA = 0.9,
      WTC = "gold",
      BC = "navajowhite",
      BBC = "darkslategray",
      BCA = 0.4,
      BTC = "saddlebrown",
      wTC = "gold",
      wAC = "burlywood",
      WFC = "olive",
     },
     preset1 = {TC = "white",
      TCA = 1,
      TTC = "black",
      WC = "midnightblue",
      WCA = 0.4,
      WTC = "skyblue",
      BC = "white",
      BBC = "lightgray",
      BCA = 0.1,
      BTC = "white",
      wTC = "skyblue",
      wAC = "red",
      WFC = "white",
     },
     preset2 = {TC = "yellowgreen",
      TCA = 1,
      TTC = "black",
      WC = "dimgrey",
      WCA = 0.8,
      WTC = "greenyellow",
      BC = "lightgrey",
      BBC = "lightgrey",
      BCA = 0.3,
      BTC = "white",
      wTC = "greenyellow",
      wAC = "greenyellow",
      WFC = "lightgrey",
     },
     preset3 = {TC = "black",
      TCA = 0.5,
      TTC = "chartreuse",
      WC = "black",
      WCA = 0.1,
      WTC = "chartreuse",
      BC = "black",
      BBC = "chartreuse",
      BCA = 0.3,
      BTC = "chartreuse",
      wTC = "chartreuse",
      wAC = "chartreuse",
      WFC = "chartreuse",
     },
     preset4 = {TC = "darkorange",
      TCA = 0.6,
      TTC = "yellow",
      WC = "black",
      WCA = 0.5,
      WTC = "yellow",
      BC = "darkorange",
      BBC = "darkorange",
      BCA = 0.5,
      BTC = "yellow",
      wTC = "yellow",
      wAC = "yellow",
      WFC = "darkorange",
     },
     preset5 = {TC = "black",
      TCA = 0,
      TTC = "white",
      WC = "black",
      WCA = 0,
      WTC = "white",
      BC = "black",
      BBC = "white",
      BCA = 0,
      BTC = "white",
      wTC = "white",
      wAC = "white",
      WFC = "white",
     },
    }
    function saveColorPreset()
     for k, l in pairs(P.MS) do
      if type(l) == "table" and l.value ~= nil and k ~= "PRESET" and k ~= "HELP_MENU" then
       colorPresets[previousPreset][k] = P.MS[k].value
      end
     end
     
    end

    function loadColorPreset()
     for k, l in pairs(P.MS) do
      if type(l) == "table" and l.value ~= nil and k ~= "PRESET" and k ~= "HELP_MENU" then
       P.MS[k].value = colorPresets[P.MS.PRESET.value][k]
      end
     end
     previousPreset = P.MS.PRESET.value
    end

    function updateEngines()
    end

    function updateParams()
     setControlMasterMode(P.KP.flM.value)
     if Nav:getAtmoMaxSpeed() ~= P.ES.aMS.value and atmoSpeedLock == true then
      Nav:setAtmoMaxSpeed(P.ES.aMS.value)
     end
     if gyro then
      if P.ES.gyr.value == "ON" and gyro.isActive() == false then gyro.activate()
      elseif P.ES.gyr.value == "OFF" and gyro.isActive() == true then gyro.deactivate()
      end
     elseif P.ES.gyr.value ~= "OFF" then
      P.ES.gyr.value = "OFF"
      system.print("No Gyro attached. Resetting gyr")
     end
     updateGyro()
     Nav:updateAggHeight(0)
     Nav:updateHovers(upInput,P.ES.hoA.value,P.ES.hoM.value)
     saveColorPreset()
     loadColorPreset()
     unit.setTimer("SCREEN",P.WS.w_refresh.value)
     if P.KP.mvL.value == false then player.freeze(0) else player.freeze(1) end
     if P.KP.viL.value == false then system.lockView(0) else system.lockView(1) end
     Nav:buildPIDs()
    end

    function updateGyro()
     if gyro then
      if P.ES.gyr.value == "ON" and gyro.isActive() == false then gyro.activate()
      elseif P.ES.gyr.value == "OFF" and gyro.isActive() == true then gyro.deactivate()
      elseif P.ES.gyr.value == "CROSS" then
       if bCM and gyro.isActive() ~= true then 
        gyro.activate()
        system.print("turn ON gyro")
       elseif not bCM and gyro.isActive() == true then
        gyro.deactivate()
        system.print("turn off gyro is now="..tostring(gyro.isActive()))
       end
      end
     elseif P.ES.gyr.value ~= "OFF" then
      P.ES.gyr.value = "OFF"
      system.print("No Gyro attached. Resetting gyr")
     end
    end

    function updateGear()
     if hasGndDet then
      toggleLandingGearCheck() -- can't be called from flush
     end
    end

    function withinParkingRange()
     return hasGndDet and (Gnd.height < 100 or Gnd.ground < 100) and Gnd.height > 0
    end
    
    function setParkingMode(pm)
     pkM = pm == true and true or false 
     local mode = nil
     if pkM and P.KP.pkM.value ~= "OFF" then 
      mode = P.KP.pkM.value
     else
      mode = P.KP.flM.value
     end
     if mode ~= Nav:getMasterMode() then
      Nav:setMasterMode(mode)
     end
    end
    
    function parkingEligible()
      return P.KP.pkM.value ~= "OFF" and P.KP.flM.value ~= "PLATFORM" and P.KP.flM.value ~= "DRONE"
    end
    
    local lPx, lPy, lPz = 0,0,0
    function checkLanded()
     local dist = math.abs(vectorLen(cWPx, cWPy, cWPz) - vectorLen(lPx, lPy, lPz))
     if currentTime - landTime > 0.5 
     and dist < 0.1 
     and accMag < 0.1 
     and Engines == true 
     then
      if P.ES.eng.value == "AUTO" then
       system.print("Switching off eng")
       Engines = false
       autoLand = false
       updateEngines()
      elseif autoLand then
       system.print("Auto Land Completed")
       autoLand = false
       updateEngines()
      end
     elseif dist >= 0.1 then
      lPx, lPy, lPz = cWPx, cWPy, cWPz
      landTime = currentTime
     else
      --
     end
    end

    function enableAutoLand()
     if autoLand then return end
     autoLand = true; autoStart = false
     system.print('Auto landing mode activated')
     if hasGndDet == false then system.print("WARNING no telemeter detected! Crash landing") end
     landTime = currentTime
    end

    function enableAutoStart()
     if autoStart then return end
     autoStart = true; autoLand = false
     autoStartTime = time
     system.print('Auto start eng activated')
    end
    
    function toggleLandingGearCheck()
     if hasGndDet == false then -- no ground detection, manually toggle
      gearExtended = not gearExtended
      if gearExtended then
       unit.deployLandingGears()
      else
       unit.retractLandingGears()
      end
     else -- has ground detection, auto choose when
      local eligible = withinParkingRange() and not parkingModeLockOut and (velMag < 28 or autoLand)
      if eligible and not gearExtended then
       gearExtended = true
       unit.deployLandingGears()
      elseif not eligible and gearExtended then
       gearExtended = false
       unit.retractLandingGears()
      end
     end
    end

    function updateHelpMenu()
     P.help_menu.Info_Page.html = help.info
     P.help_menu.MS.html = help.menuSettings
     P.help_menu.ES.html = help.engineSettings
     P.help_menu.AS.html = help.autopilotSettings
     P.help_menu.WS.html = help.widgets
     P.help_menu.KP.html = help.keybingParams
     P.help_menu.QuickToolBar.html = help.q
     P.help_menu.w_html = P.help_menu.Info_Page.html
    end

    local cos, sin, max, min = math.cos, math.sin, math.max, math.min
    function convertToWorldCoordinates(posString)
     local num = ' *([+-]?%d+%.?%d*e?[+-]?%d*)'
     local posPattern = '::pos{' .. num .. ',' .. num .. ',' .. num .. ',' .. num .. ',' .. num .. '}'
     local systemId, bodyId, latitude, longitude, altitude = string.match(posString,posPattern)
     systemId = tonumber(systemId)
     bodyId = tonumber(bodyId)
     latitude = tonumber(latitude)
     longitude = tonumber(longitude)
     altitude = tonumber(altitude)
     if tonumber(bodyId) == 0 then
      return latitude,longitude,altitude
     end
     latitude = 0.0174532925199 * max(min(latitude, 90), -90)
     longitude = 0.0174532925199 * (longitude % 360)
     local center, radius = Helios[bodyId].center, tonumber(Helios[bodyId].radius)
     local xproj = cos(latitude)
     local px, py, pz = center[1]+(radius+altitude) * xproj*cos(longitude),
          center[2]+(radius+altitude) * xproj*sin(longitude),
          center[3]+(radius+altitude) * sin(latitude)
     return px, py, pz
    end

    function stringToTable(String, Separator)
     local Separator = Separator or ','
     local axes = {}
     for axis in String:gmatch('[^'..Separator..']+') do
      axes[#axes + 1] = axis
     end
     return axes
    end

    function mouseControlUpdate()
     system.lockView(1)
     if system.getMouseDeltaY() ~= 0 or previousDeltaY ~= 0 then 
      if MM ~= "DRONE" and MM ~= "PLATFORM" then --TODO make mouse Y work for drone
       local f = P.KP.mCI.value == false and 1 or -1
       pitchInput = system.getMouseDeltaY() * P.KP.mCS.value *-0.25 * f
       previousDeltaY = pitchInput
      end
     end
     if system.getMouseDeltaX() ~= 0 or previousDeltaX ~= 0 then 
      yawInput = system.getMouseDeltaX() * P.KP.mCS.value *-0.25
      previousDeltaX = yawInput
     end
    end

  onStart:
   lua: |
    local abs, floor, asin, sqrt, cos, acos, sin, deg, atan, rad, sign, clamp, rad2deg, max, ceil = math.abs, math.floor, math.asin, math.sqrt, math.cos, math.acos, math.sin, math.deg, math.atan, math.rad, utils.sign, utils.clamp, constants.rad2deg, math.max, math.ceil
    local C = construct
    -- Thrust Management library --
    function vectorLen(x,y,z)
     return sqrt(x*x+y*y+z*z)
    end
    
    function brakingCalculation()
     local MaxBrakesForce = C.getMaxBrake() or 0
     local maxSpeed = 50000*0.27777777777
     local cAV = C.getVelocity()
     local cAVx, cAVy, cAVz = cAV[1], cAV[2], cAV[3]
     local cWAV = C.getWorldAbsoluteVelocity()
     local velMag = sqrt(cAVx^2+cAVy^2+cAVz^2)
     local cM = C.getTotalMass()
     local forwardEnginesForce, backwardEnginesForce = Nav:getMaxKPA()
     local gravityV = core.getWorldGravity()
     local g = core.getGravityIntensity()
     local G_axis = -1*utils.sign(cWAV[1]*gravityV[1] + cWAV[2]*gravityV[2] + cWAV[3]*gravityV[3])
     local brakesAcceleration = MaxBrakesForce + g*G_axis * cM
     local forwardAcceleration = forwardEnginesForce + g*G_axis * cM
     local backwardAcceleration = backwardEnginesForce + g*G_axis * cM
     local forwardBrakeDistance = cM * maxSpeed^2 / (brakesAcceleration + backwardAcceleration/2) * (1 - sqrt(1 - ((velMag)^2 / maxSpeed^2)))
     local backburnBrakeDistance = cM * maxSpeed^2 / (brakesAcceleration + forwardAcceleration/2) * (1 - sqrt(1 - ((velMag)^2 / maxSpeed^2)))
     return forwardBrakeDistance, backburnBrakeDistance
    end

    function sf(s)
     return string.format("%.4f", s)
    end

    function norm(x,y,z)
     local l = sqrt(x*x + y*y + z*z)
     return x/l, y/l, z/l
    end

    function dotVec(x1,y1,z1,x2,y2,z2)
     return x1*x2 + y1*y2 + z1*z2
    end

    function multiplyVec(x,y,z,factor)
     return x*factor, y*factor, z*factor
    end
  
    local function world2local(x,y,z)
     local v = library.systemResolution3({cWORx, cWORy, cWORz},{cWOFx, cWOFy, cWOFz},{cWOUPx, cWOUPy, cWOUPz},{x,y,z})
     return v[1],v[2],v[3]
    end

    local function rotateVec(vx, vy, vz, phi, ax, ay, az)
     local l = sqrt(ax*ax + ay*ay + az*az)
     local ux, uy, uz = ax/l, ay/l, az/l
     local cs, s = cos(phi), sin(phi)
     local m1x, m1y, m1z = (cs + ux * ux * (1-cs)), (ux * uy * (1-cs) - uz * s), (ux * uz * (1-cs) + uy * s)
     local m2x, m2y, m2z = (uy * ux * (1-cs) + uz * s), (cs + uy * uy * (1-cs)), (uy * uz * (1-cs) - ux * s)
     local m3x, m3y, m3z = (uz * ux * (1-cs) - uy * s), (uz * uy * (1-cs) + ux * s), (cs + uz * uz * (1-cs))
     return m1x*vx+m1y*vy+m1z*vz, m2x*vx+m2y*vy+m2z*vz, m3x*vx+m3y*vy+m3z*vz
    end

    function cross(x, y, z, vx, vy, vz)
     return y*vz - z*vy, z*vx - x*vz, x*vy - y*vx
    end

    -- Rotations control --
    local function getConstructRot(x, y, z)
     if x == nil then x, y, z = -1,0,0 end
     x, y, z = norm(x,y,z)
     local CRx, CRy, CRz = cWORx, cWORy, cWORz
     local CUx, CUy, CUz = cWOUPx, cWOUPy, cWOUPz
     local cx, cy, cz = cross(x, y, z, CUx, CUy, CUz)
     local rAx, rAy, rAz = norm(cx, cy, cz) -- rot axis
     local ConstructRot = acos(clamp(dotVec(rAx, rAy, rAz,CRx, CRy, CRz), -1, 1)) * rad2deg
     cx, cy, cz = cross(rAx, rAy, rAz, CRx, CRy, CRz)
     if dotVec(cx, cy, cz, CUx, CUy, CUz) < 0 then ConstructRot = -ConstructRot end
     return ConstructRot
    end

    local function getConstructPitch(x, y, z)
     if x == nil then x, y, z = 0,0,1 end
     x, y, z = norm(x,y,z)
     local CRx, CRy, CRz = cWORx, cWORy, cWORz
     local CFx, CFy, CFz = cWOFx, cWOFy, cWOFz
     local cx, cy, cz = cross(x, y, z, CRx, CRy, CRz)
     local pAx, pAy, pAz = norm(cx, cy, cz) --pitch axis
     local ConstructPitch = acos(clamp(dotVec(pAx, pAy, pAz, CFx, CFy, CFz), -1, 1)) * rad2deg
     cx, cy, cz = cross(pAx, pAy, pAz, CFx, CFy, CFz)
     if dotVec(cx, cy, cz, CRx, CRy, CRz) < 0 then ConstructPitch = -ConstructPitch end
     return ConstructPitch
    end

    local function getConstructRoll(x,y,z)
     if x == nil then x, y, z = 0,0,1 end
     x, y, z = norm(x,y,z)
     local CRx, CRy, CRz = cWORx, cWORy, cWORz
     local CFx, CFy, CFz = -cWOFx, -cWOFy, -cWOFz
     local cx, cy, cz = cross(x, y, z, CFx, CFy, CFz)
     local rAx, rAy, rAz = norm(cx, cy, cz) --roll Axis
     local ConstructRoll = acos(clamp(dotVec(rAx, rAy, rAz, CRx, CRy, CRz), -1, 1)) * rad2deg
     cx, cy, cz = cross(rAx, rAy, rAz, CRx, CRy, CRz)
     if dotVec(cx, cy, cz, CFx, CFy, CFz) < 0 then ConstructRoll = -ConstructRoll end
     return ConstructRoll
    end
    
    local function getConstructRoll90(x,y,z) --for the auto yaw when pitch = 90
     if x == nil then x, y, z = 0,0,1 end
     x, y, z = norm(x,y,z)
     local CRx, CRy, CRz = cWORx, cWORy, cWORz
     local CUx, CUy, CUz = -cWOUPx, -cWOUPy, -cWOUPz
     local cx, cy, cz = cross(x, y, z, CUx, CUy, CUz)
     local rAx, rAy, rAz = norm(cx, cy, cz) --roll Axis
     local ConstructRoll = acos(clamp(dotVec(rAx, rAy, rAz, CRx, CRy, CRz), -1, 1)) * rad2deg
     cx, cy, cz = cross(rAx, rAy, rAz, CRx, CRy, CRz)
     if dotVec(cx, cy, cz, CUx, CUy, CUz) < 0 then ConstructRoll = -ConstructRoll end
     return ConstructRoll
    end

    local function rollAngularVelocity90(x,y,z, angle, speed) --for the auto yaw when pitch = 90
     if x == nil then x, y, z = 0,0,1 end
     x, y, z = norm(x,y,z)
     local CUx, CUy, CUz = -cWOUPx, -cWOUPy, -cWOUPz
     if angle ~= 0 then x, y, z = rotateVec(x, y, z, rad(-angle), CUx, CUy, CUz) end
     local RollDeg = getConstructRoll90(x, y, z)
     if (RollPID90 == nil) then 
      RollPID90 = pid.new(0.05, 0, 1)
     end
     RollPID90:inject(0 - RollDeg)
     local PIDget = RollPID90:get()
     return PIDget * CUx * speed, PIDget * CUy * speed, PIDget * CUz * speed
    end

    local function rollAngularVelocity(x,y,z, angle, speed)
     if x == nil then x, y, z = 0,0,1 end
     x, y, z = norm(x,y,z)
     local CFx, CFy, CFz = -cWOFx, -cWOFy, -cWOFz
     if angle ~= 0 then x, y, z = rotateVec(x, y, z, rad(-angle), CFx, CFy, CFz) end
     local RollDeg = getConstructRoll(x, y, z)
     local PIDget = 0-RollDeg*0.05*speed
     return PIDget * CFx, PIDget * CFy, PIDget * CFz
    end

    local function pitchAngularVelocity(x,y,z, angle, speed)
     if x == nil then x, y, z = 0,0,1 end
     x, y, z = norm(x,y,z)
     local CRx, CRy, CRz = cWORx, cWORy, cWORz
     if angle ~= 0 then x, y, z = rotateVec(x, y, z, rad(-angle), CRx, CRy, CRz) end
     local PitchDeg = getConstructPitch(x, y, z)
     local PIDget = 0-PitchDeg*0.05*speed
     return PIDget * CRx, PIDget * CRy, PIDget * CRz
    end

    local function yawAngularVelocity(x,y,z, angle, speed)
     if x == nil then x, y, z = -1,0,0 end
     x, y, z = norm(x,y,z)
     local CUx, CUy, CUz = cWOUPx, cWOUPy, cWOUPz
     if angle ~= 0 then x, y, z = rotateVec(x, y, z, rad(angle), CUx, CUy, CUz) end
     local YawDeg = getConstructRot(x, y, z)
     local PIDget = 0-YawDeg*0.5*speed
     return PIDget * CUx, PIDget * CUy, PIDget * CUz
    end

    local function getAAR(ox, oy, oz, nx, ny, nz, px, py, pz)
     ox, oy, oz = norm(ox, oy, oz)
     nx, ny, nz = norm(nx, ny, nz)
     local ax, ay, az = cross(ox, oy, oz, nx, ny, nz)
     local axisLen = vectorLen(ax, ay, az)
     local angle = 0
     ax, ay, az = norm(ax, ay, az)
     if axisLen > 0.000001
     then
      angle = asin(clamp(axisLen, 0, 1))
     else
      ax, ay, az = px, py, pz
     end
     if dotVec(ox, oy, oz, nx, ny, nz) < 0
     then
      angle = math.pi - angle
     end
     return ax, ay, az, angle
    end

    function round(num, numDecimalPlaces) -- rounds variable num to numDecimalPlaces
     local mult = 10 ^ (numDecimalPlaces or 0)
     return floor(num * mult + 0.5) / mult
    end

    function fn(v) --fixNan
     return v~=v and 0 or v
    end

    local lastG = 0
    local lastVel = 0
    local function RefreshLastMaxBrake()
     local gravityR = round(gravityA, 5) -- round to avoid insignificant updates
     local speedR = round(velMag)
     if lastG == nil or lastG ~= gravityR or lastVel ~= speedR then
      local maxBrake = C.getMaxBrake()
      if maxBrake ~= nil and maxBrake > 0 and inAtmo then 
       maxBrake = maxBrake / clamp(speedR/100, 0.1, 1) / atmosDensity
       if atmosDensity > 0.10 then 
        LastMaxBrakeInAtmo = maxBrake 
       end
      end
      if maxBrake ~= nil and maxBrake > 0 then
       LastMaxBrake = maxBrake
      end
      lastG = gravityR
      lastVel = speedR
     end
    end

    local pHD = 0 --previous
    function AboveGroundLevel()
     local function hoverDetectGround()
      local function getDist(e)
       local dist,max,d = -1,-1,-1
       if e then
        d,max = e.getDistance(), e.getMaxDistance()
        d = abs(d) < 0.01 and 0 or d -- round to 0
        if d == 0 and pHD ~= 0 then
         dist = pHD
        else
         dist = d
        end
        pHD = d
       end
       return dist,max
      end
      local vGndDist,vGndMax = getDist(vBooster)
      local hGndDist,hGndMax = getDist(hover)
      if vGndDist ~= -1 and hGndDist ~= -1 then
       if vGndDist < hGndDist then
        return vGndDist, math.max(vGndMax,hGndMax)
       else
        return hGndDist, math.max(vGndMax,hGndMax)
       end
      elseif vGndDist ~= -1 then
       return vGndDist, vGndMax
      elseif hGndDist ~= -1 then
       return hGndDist, hGndMax
      else
       return -1, math.max(vGndMax,hGndMax)
      end
     end
     local hovGndDet, hovGndMax = hoverDetectGround() 
     local grnd = {height=hovGndDet,max=hovGndMax,ground=hovGndDet,tel=-1}
     if telemeter then 
      grnd.tel = telemeter.raycast().distance
      if grnd.tel > 0 then grnd.height = grnd.tel end
     end
     return grnd
    end

    local lastApTickTime = system.getArkTime()
    local deltaTick = 0
    local brakingLastTime = lastApTickTime
    local brakingLastSpd = 0
    local brakingLastGnd = -1
    local landSpeed = -1
    local StopDistance = -1
    local minFallSpeed = -1

    function thrustManager()
     time = system.getArkTime()
     deltaTick = time - lastApTickTime
     lastApTickTime = time
     if deltaTick < 0.004 then return end

     -- Final inputs --
     local finalPitchInput = pitchInput + system.getControlDeviceForwardInput()
     local finalRollInput = rollInput + system.getControlDeviceYawInput()
     local finalYawInput = yawInput - system.getControlDeviceLeftRightInput()
     local finalRotationInput = finalPitchInput + finalRollInput + finalYawInput

     -- Globals --
     local cWOUP = C.getWorldOrientationUp()
     local cWOF = C.getWorldOrientationForward()
     local cWOR = C.getWorldOrientationRight()
     local cOUP = C.getOrientationUp()
     local cOF = C.getOrientationForward()
     local cOR = C.getOrientationRight()
     if bCM and gyro.isActive() == true then
      cWOUPx, cWOUPy, cWOUPz = cWOR[1], cWOR[2], cWOR[3]
      cWOFx, cWOFy, cWOFz = cWOF[1], cWOF[2], cWOF[3]
      cWORx, cWORy, cWORz = -cWOUP[1], -cWOUP[2], -cWOUP[3]
      --local
      cOUPx, cOUPy, cOUPz = cOR[1], cOR[2], cOR[3]
      cOFx, cOFy, cOFz = cOF[1], cOF[2], cOF[3]
      cORx, cORy, cORz = -cOUP[1], -cOUP[2], -cOUP[3]
     else
      cWOUPx, cWOUPy, cWOUPz = cWOUP[1], cWOUP[2], cWOUP[3]
      cWOFx, cWOFy, cWOFz = cWOF[1], cWOF[2], cWOF[3]
      cWORx, cWORy, cWORz = cWOR[1], cWOR[2], cWOR[3]
      --local
      cOUPx, cOUPy, cOUPz = cOUP[1], cOUP[2], cOUP[3]
      cOFx, cOFy, cOFz = cOF[1], cOF[2], cOF[3]
      cORx, cORy, cORz = cOR[1], cOR[2], cOR[3]
     end
     atmosDensity = unit.getAtmosphereDensity()
     gravityA = core.getGravityIntensity()

     -- Flush Variables --
     local cWP = C.getWorldPosition()
     cWPx, cWPy, cWPz = cWP[1], cWP[2], cWP[3]
     local cWCOM = C.getWorldCenterOfMass()
     local cWCOMx, cWCOMy, cWCOMz = cWCOM[1], cWCOM[2], cWCOM[3]
     local gravityV = core.getWorldGravity()
     local gx, gy, gz = gravityV[1], gravityV[2], gravityV[3]
     local cAV = C.getVelocity()
     local cAVx, cAVy, cAVz = cAV[1], cAV[2], cAV[3]
     local cWAV = C.getWorldVelocity()
     cWAVx, cWAVy, cWAVz = cWAV[1], cWAV[2], cWAV[3]
     local WAFA = C.getWorldAirFrictionAcceleration()
     local WAFAx, WAFAy, WAFAz = WAFA[1], WAFA[2], WAFA[3]
     local cWAngV = C.getWorldAngularVelocity()
     local cWAngVx, cWAngVy, cWAngVz = cWAngV[1], cWAngV[2], cWAngV[3]
     local wAFAA = C.getWorldAirFrictionAngularAcceleration()
     local wAFAAx, wAFAAy, wAFAAz = wAFAA[1], wAFAA[2], wAFAA[3]
     local cMAS = C.getMaxAngularSpeed()
     local cWA = C.getWorldAcceleration()

     local cPCx, cPCy, cPCz = currentPlanetCenter[1], currentPlanetCenter[2], currentPlanetCenter[3]
     wVx, wVy, wVz = cWCOMx-cPCx, cWCOMy-cPCy, cWCOMz-cPCz --world vertical
     local nwVx, nwVy, nwVz = norm(wVx, wVy, wVz) -- normalized
     gravity = dotVec(gx, gy, gz, nwVx, nwVy, nwVz)
     local cWAVDirx, cWAVDiry, cWAVDirz = norm(cWAVx,cWAVy,cWAVz)
     velMag = vectorLen(cAVx, cAVy, cAVz) --xyzSpeedMPS
     accMag = vectorLen(cWA[1], cWA[2], cWA[3])
     xyzSpeedKPH = velMag*3.6
     xSpeedKPH = dotVec(cWAVx, cWAVy, cWAVz, cWORx, cWORy, cWORz)*3.6
     ySpeedKPH = dotVec(cWAVx, cWAVy, cWAVz, cWOFx, cWOFy, cWOFz)*3.6
     zSpeedKPH = dotVec(cWAVx, cWAVy, cWAVz, cWOUPx, cWOUPy, cWOUPz)*3.6
     --local xySpeedKPH = sqrt(xSpeedKPH^2+ySpeedKPH^2)
     planetVertSpeedMPS = dotVec(cWAVx, cWAVy, cWAVz, nwVx, nwVy, nwVz)
     local planetLatSpeedMPS = sqrt(vectorLen(cWAVx, cWAVy, cWAVz)^2-planetVertSpeedMPS^2)
     alt = vectorLen(cWCOMx-cPCx, cWCOMy-cPCy, cWCOMz-cPCz) - planet.radius or 0

   
     Ax0 = 0 --pitch angle in deg
     Ay0 = 0 --roll angle in deg
     if alt < P.AS.stA.value then
      Ax0 = getConstructPitch(wVx, wVy, wVz)
      Ay0 = getConstructRoll(wVx, wVy, wVz)
     end

     Az = deg(atan(xSpeedKPH, ySpeedKPH)) -- drift rot angle in deg
     Ax = deg(atan(zSpeedKPH, ySpeedKPH)) -- drift pitch angle in deg

     ThrottlePos = (Nav:getThrottleValue() ~= nil) and Nav:getThrottleValue() or 0

     -- Gnd Detection --
     if hasGndDet then
      Gnd = AboveGroundLevel()

      -- Parking Mode --
      local noInputs = finalPitchInput==0 and finalRollInput==0 and finalYawInput==0 and upInput==0 and not modeRocket and not autoLand

      if parkingEligible() and ThrottlePos == 0 then
       if withinParkingRange() and xyzSpeedKPH < P.AS.aBS.value and HoldAltitude == nil then
        if not parkingModeLockOut and noInputs then
         setParkingMode(true)
        end
       else --not in range
        parkingModeLockOut = false
       end
      else --not eligible
       parkingModeLockOut = false
       setParkingMode(false)
      end

      -- Turn on brakeCrossMode --
      if 
      P.ES.gyr.value == "CROSS" 
      and gyro 
      and Gnd.height < 100 and Gnd.height > 0
      and (autoLand or brakeInput > 0)
      then -- prerequisites for turning on bCM
       local downVel = dotVec(cWAVx,cWAVy,cWAVz,-cWOUPx,-cWOUPy,-cWOUPz)
       local limitB, limitT = approachSpeedZ > 0 and approachSpeedZ or 2, approachSpeedZ+10
       if downVel > limitT and downVel > 15 then
        bCM = true
       elseif bCM and downVel < limitB then
        bCM = false
       end
      elseif bCM then
       bCM = false
      end

      if (time - brakingLastTime > 0.5 or abs(brakingLastGnd - Gnd.height) > 2)then
       -- update approach speed based on stop distance --
       RefreshLastMaxBrake()
       local fUP = Nav:maxForceUp()*0.5
       local cOUP = {cOUPx, cOUPy, cOUPz}
       local maxKinematicGnd = C.getMaxThrustAlongAxis("ground", cOUP)[1]
       local gDist = Gnd.height ~= -1 and Gnd.height*clamp(P.AS.aLR.value-0.1,0.1,1) or hasATelemeter and 101 or Gnd.max > 0 and Gnd.max

       local delayDist = 0.1 * velMag
       local dist      = gDist-P.AS.grO.value-delayDist
       local final      = 0.1
       local mass      = coreMass
       local thrust     = fUP
       local hov   = maxKinematicGnd
       local hoverDist    = Gnd.max-P.AS.grO.value
       local maxBrakeForce  = LastMaxBrakeInAtmo
       local atmosDensity  = clamp(atmosDensity,0.4,2) --0.994
       local gravityA    = gravityA --9.8893
       local zAxis      = true
       approachSpeedZ = Kinematic.maxInitialVelocity(dist,final,mass,thrust,hov,hoverDist,maxBrakeForce,atmosDensity,gravityA,zAxis)
       if P.ES.gyr.value == "CROSS" then
        zAxis      = false
        approachSpeed = Kinematic.maxInitialVelocity(dist,final,mass,thrust,hov,hoverDist,maxBrakeForce,atmosDensity,gravityA,zAxis)
       end 
       local minSpd = 3
       landSpeed = P.ES.gyr.value == "CROSS" and approachSpeed > minSpd and -approachSpeed or approachSpeedZ > minSpd and -approachSpeedZ or -(minSpd+gDist*0.1)

       brakingLastTime = time
       brakingLastGnd = Gnd.height
      end
     else
      pkM = false
      approachSpeed = 0
      approachSpeedZ = 0
     end
     MM = Nav:getMasterMode()

     if Engines == true then
      -- Starting Values

      if MM == "CRUISE" or MM == "TRAVEL" then
       -- Autopilot rotations --
       if P.AS.anS.value == true and abs(Az) > 35 and ySpeedKPH > 50 and ySpeedKPH > zSpeedKPH and inspace == 0 and abs(Ax0) < 30 and abs(Ay0) < 30 then
        finalYawInput = finalYawInput * -0.1
       end
      end

      if MM == "DRONE" then
       --P.AS.iAB.value = false
       P.KP.shL.value = false
      end      

      -- Control Keys Rotation --
      local tAVx, tAVy, tAVz = 0,0,0
      local pFact = finalPitchInput * cMAS * P.ES.pSF.value
      local rFact = finalRollInput * cMAS * P.ES.rSF.value
      local yFact = finalYawInput  * cMAS * P.ES.ySF.value
      if MM == "DRONE" and modeRocket == true then
       tAVx = rFact * cWOFx + yFact * -cWOFx
       tAVy = rFact * cWOFy + yFact * -cWOFy
       tAVz = rFact * cWOFz + yFact * -cWOFz
      elseif MM == "DRONE" and modeRocket == false then
       tAVx = yFact * cWOUPx
       tAVy = yFact * cWOUPy
       tAVz = yFact * cWOUPz
      else
       tAVx = pFact * cWORx + rFact * cWOFx + yFact * cWOUPx
       tAVy = pFact * cWORy + rFact * cWOFy + yFact * cWOUPy
       tAVz = pFact * cWORz + rFact * cWOFz + yFact * cWOUPz
      end

      -- THRUST COMPOSER --
      local longAx, longAy, longAz = 0, 0, 0 --longitudinal acceleration
      local latAx, latAy, latAz = 0, 0, 0 --lateral acceleration
      local vertAx, vertAy, vertAz = 0, 0, 0 --vertical acceleration
      local strafeSpeed = unitData.maxSpeedkph
      local strafeStep = clamp(100,0,strafeSpeed)
      local targetLongSpeed, targetLatSpeed, targetVertSpeed = 0,0,0

      -- Auto Rotations --
      if autoLand == true and MM ~= "DRONE"then
       local rAVx, rAVy, rAVz = rollAngularVelocity(wVx, wVy, wVz, 0, P.ES.rSF.value)
       local pAVx, pAVy, pAVz = pitchAngularVelocity(wVx, wVy, wVz, 0 , P.ES.pSF.value)
       tAVx = tAVx + pAVx + rAVx
       tAVy = tAVy + pAVy + rAVy
       tAVz = tAVz + pAVz + rAVz
      elseif MM == "CRUISE" or MM == "TRAVEL" then
       -- Pitch and roll stabilization
       if alt < P.AS.stA.value then
        if P.AS.auR.value == true 
         and abs(Ay0 + P.ES.rAd.value*-1) > 0.25
         and finalRollInput == 0 and abs(Ax0) < 30
         and turnAssist_toggle == false
         and abs(Ay0 + P.ES.rAd.value) < P.AS.tAR.value then
         local rAVx, rAVy, rAVz = rollAngularVelocity(wVx, wVy, wVz, 0 - P.ES.rAd.value, P.ES.rSF.value)
         tAVx = tAVx + rAVx
         tAVy = tAVy + rAVy
         tAVz = tAVz + rAVz
        end
        
        if HoldAltitude ~= nil then
         VStabAltLock = floor(HoldAltitude)
         local pitchOffset = clamp(((alt - HoldAltitude)+(planetVertSpeedMPS*4))*0.05,-30,30)
         local pAVx, pAVy, pAVz = pitchAngularVelocity(wVx, wVy, wVz, pitchOffset + P.ES.pAd.value, P.ES.pSF.value)
         tAVx = tAVx + pAVx
         tAVy = tAVy + pAVy
         tAVz = tAVz + pAVz
        elseif P.AS.auP.value == true 
         and abs(Ax0) < (P.AS.aPA.value + abs(P.ES.pAd.value))
         and finalPitchInput == 0 
         and upInput == 0 
         and turnAssist_toggle == false
         and abs(Ax0) < 45 
         and abs(Ay0) < 10
         then

         -- auP alt Stabilization
         if xyzSpeedKPH > 250 and P.AS.atS.value == true then
          if VStabAltLock == nil and abs(Ax0) < 0.05 then 
           VStabAltLock = floor(alt)
           system.print("Altitude locked at: "..VStabAltLock)
          end
         else VStabAltLock = nil
         end
         local pAVx, pAVy, pAVz = pitchAngularVelocity(wVx, wVy, wVz, 0 + P.ES.pAd.value, P.ES.pSF.value)
         tAVx = tAVx + pAVx
         tAVy = tAVy + pAVy
         tAVz = tAVz + pAVz
        else if VStabAltLock ~= nil then VStabAltLock = nil system.print("Pitch stabilisation unlocked") end
        end

        -- Turn assist
        if P.AS.tuA.value == true 
         and abs(Ay0) > P.AS.tAR.value
         and abs(Ax0) < P.AS.tAP.value
         and finalPitchInput == 0
         and finalYawInput == 0
         and finalRollInput == 0
         and inspace == 0 
         then
         turnAssist_toggle = true
         if (TApitchPID == nil) then 
          TApitchPID = pid.new(0.2, 0, 10)
         end
         TApitchPID:inject(0 - Ax0)
         local PIDget = TApitchPID:get()
         local pAAx, pAAy, pAAz = PIDget * cWORx, PIDget * cWORy, PIDget * cWORz
         --targetAngularVelocity = cWOUP * 0.25 * sign(Ay0) * -1 + pitchAngularAcceleraion
         tAVx = cWOUPx * 0.25 * sign(Ay0) + pAAx
         tAVy = cWOUPy * 0.25 * sign(Ay0) + pAAy
         tAVz = cWOUPz * 0.25 * sign(Ay0) + pAAz
        else turnAssist_toggle = false
        end
       end

       -- BackBurn --
       if finalYawInput == 0 and finalPitchInput == 0 and finalRollInput == 0
        and (DTK == "brake" or BackBurnToggle == true) then
        local SBBMinimumSpeed = 1000
        if MM ~= "CRUISE" then
         PreviousMasterMode = "TRAVEL"
         Nav:setMasterMode("CRUISE")
        end
        -- Space BackBurn --
        if xyzSpeedKPH > SBBMinimumSpeed and not inAtmo then 
         BackBurnToggle = true
         if Az == 0 then
          finalYawInput = 1
         else
          local axx, axy, axz, an = getAAR(-1*cWOFx, -1*cWOFy, -1*cWOFz, cWAVx, cWAVy, cWAVz, 0, 0, 0)
          if (BBPID == nil) then
           BBPID = pid.new(0.2, 0, 10)
          end
          BBPID:inject(an)
          local PIDget = BBPID:get()
          tAVx = axx * PIDget
          tAVy = axy * PIDget
          tAVz = axz * PIDget
          ThrottlePos = 0
          oWVx, oWVy, oWVz = cWAVx, cWAVy, cWAVz
         end
        -- Continue BackBurn --
        elseif (DTK == "" and BackBurnToggle == true) or (xyzSpeedKPH < SBBMinimumSpeed and BackBurnToggle == true) then
         local axx, axy, axz, an = getAAR(cWOFx, cWOFy, cWOFz, oWVx, oWVy, oWVz, 0,0,0)
         if (BBPID == nil) then
          BBPID = pid.new(0.2, 0, 10)
         end
         BBPID:inject(an)
         local PIDget = BBPID:get()
         tAVx = axx * PIDget
         tAVy = axy * PIDget
         tAVz = axz * PIDget
         ThrottlePos = 0
        end
       elseif (finalYawInput ~= 0 or finalPitchInput ~= 0 or finalRollInput ~= 0 or DTK ~= "brake")
        and BackBurnToggle == true then
        BackBurnToggle = false
        if PreviousMasterMode == "TRAVEL" then 
         Nav:setMasterMode("TRAVEL") 
        end
        ThrottlePos = 0
        Nav:resetThrottleValue()
       end

       -- Prograde --
       if not inAtmo 
        and finalRotationInput == 0
        and BackBurnToggle == false
        and P.AS.aPG.value == true
        and xyzSpeedKPH > 200
        then
        local axx, axy, axz, an = getAAR(cWOFx, cWOFy, cWOFz, cWAVx, cWAVy, cWAVz, 0, 0, 0)
        if (APGPID == nil) then
         APGPID = pid.new(0.05, 0, 1)
        end
        APGPID:inject(an)
        local PIDget = APGPID:get()
        tAVx = axx * PIDget
        tAVy = axy * PIDget
        tAVz = axz * PIDget
       end
      elseif MM == "PLATFORM" and alt < P.AS.stA.value then
       --Roll stabilisation
       local autoRollRollThreshold = 0.1
       if abs(Ay0) > autoRollRollThreshold then
        local rAVx, rAVy, rAVz = rollAngularVelocity(wVx, wVy, wVz, 0 - P.ES.rAd.value, 1)
        tAVx = tAVx + rAVx
        tAVy = tAVy + rAVy
        tAVz = tAVz + rAVz
       end

       --Pitch stabilisation
       local aPA = 90
       if abs(Ax0) < aPA then
        local pAVx, pAVy, pAVz = pitchAngularVelocity(wVx, wVy, wVz, 0 + P.ES.pAd.value, 1)
        tAVx = tAVx + pAVx
        tAVy = tAVy + pAVy
        tAVz = tAVz + pAVz
       end
      elseif MM == "DRONE" and modeRocket == true then
       local pitchOffset = 90 + (-upInput * 30)
       if upInput ~= 0 then
       else
        if not prevAltHoldAng then prevAltHoldAng = -4.8 end
        local aAdj = prevAltHoldAng
        if xyzSpeedKPH > 100 and HoldAltitude ~= nil then
         VStabAltLock = floor(HoldAltitude)
         if abs(alt - HoldAltitude) < 50 then aAdj = prevAltHoldAng + clamp(planetVertSpeedMPS,-1,1)/1000 end
         VStabAltLock = floor(HoldAltitude)
         pitchOffset = pitchOffset + clamp(((alt - HoldAltitude)+(planetVertSpeedMPS*4))*0.05,-30,30) + aAdj
        else
         aAdj = prevAltHoldAng + clamp(planetVertSpeedMPS,-1,1)/1000
         pitchOffset = pitchOffset + clamp(planetVertSpeedMPS/10,-30,30) + aAdj
        end
        prevAltHoldAng = aAdj
       end

       local pAVx, pAVy, pAVz = pitchAngularVelocity(wVx, wVy, wVz, pitchOffset + P.ES.pAd.value, P.ES.pSF.value*0.5)
       tAVx = tAVx + pAVx
       tAVy = tAVy + pAVy
       tAVz = tAVz + pAVz
     
       if Ax0 < -45 and Ax0 > -135 then --auto yaw (roll) to stay flat
        local rAVx, rAVy, rAVz = rollAngularVelocity90(wVx, wVy, wVz, 0, 1)
        tAVx = tAVx + rAVx
        tAVy = tAVy + rAVy
        tAVz = tAVz + rAVz
       end
      elseif MM == "DRONE" and modeRocket == false then
       -- BackBurn --
       if finalYawInput == 0 and finalPitchInput == 0 and finalRollInput == 0 and upInput <= 0
        and P.AS.bBu.value == true 
        then

        local axx, axy, axz, an = 0,0,0,0
        local nwVx, nwVy, nwVz = norm(wVx, wVy, wVz) -- normalized world vector (negative grav.)
        local ncWAVx, ncWAVy, ncWAVz = norm(cWAVx, cWAVy, cWAVz)
        local vAngle = acos(dotVec(ncWAVx, ncWAVy, ncWAVz, nwVx, nwVy, nwVz) / (vectorLen(ncWAVx, ncWAVy, ncWAVz) * vectorLen(nwVx, nwVy, nwVz)))*rad2deg
        if vAngle < 15 and planetVertSpeedMPS > 9 then 
         local ux, uy, uz = multiplyVec(-gx,-gy,-gz,1)
         axx, axy, axz, an = getAAR(cWOUPx, cWOUPy, cWOUPz, cWAVx+ux, cWAVy+uy, cWAVz+uz, 0, 0, 0)
        else
         local ux, uy, uz = multiplyVec(gx,gy,gz,1.8)
         axx, axy, axz, an = getAAR(-cWOUPx, -cWOUPy, -cWOUPz, cWAVx+ux, cWAVy+uy, cWAVz+uz, 0, 0, 0)
        end
        local aFact = clamp(an*rad2deg/40,-1,1) -- 40 = less sensitive
        tAVx = axx * aFact
        tAVy = axy * aFact
        tAVz = axz * aFact

       else
        -- Stabilization & Drone Rolling --
        local angF = SHIFT == true and P.ES.dSA.value or P.ES.dCA.value
        local fRI = 1 * sign(rollInput)
        local fPI = 1 * sign(pitchInput)
        local rAVx, rAVy, rAVz = rollAngularVelocity(wVx, wVy, wVz, 0 + fRI * angF, P.ES.rSF.value)
        local pAVx, pAVy, pAVz = pitchAngularVelocity(wVx, wVy, wVz, 0 - fPI * angF , P.ES.pSF.value)
        tAVx = tAVx + pAVx + rAVx
        tAVy = tAVy + pAVy + rAVy
        tAVz = tAVz + pAVz + rAVz
       end
      end

      -- Longitudinal Translation
      if MM == "PLATFORM" then 
       if pkM then
        if SHIFT == false then 
         strafeSpeed = P.KP.pMS.value
         strafeStep = clamp(100,0,strafeSpeed)
         targetLongSpeed = forwardInput * P.KP.pMS.value
        else
         targetLongSpeed = forwardInput * unitData.maxSpeedkph
        end
       else
        if modeRocket == true then 
         targetLongSpeed = unitData.maxSpeedkph
        else
         targetLongSpeed = forwardInput * unitData.maxSpeedkph
        end
       end
      end
      
      if MM == "CRUISE" or MM == "TRAVEL" or MM == "PLATFORM" then
       -- Auto Orbit Speed --
       --TODO make orbiting possible for platform mode? and drone Mode?
       if P.AS.atS.value == true and P.AS.aOS.value == true and not inAtmo and ThrottlePos ~= 0 and VStabAltLock ~= nil then
        ThrottlePos = sqrt(currentPlanetGM / (alt + planet.radius))*3.6
       end

       if xyzSpeedKPH > 10000 then
        if strafeInput == 0 then
         targetLatSpeed = xSpeedKPH
        end
        if upInput == 0 then
         targetVertSpeed = zSpeedKPH
        end
       else
        local rV = dotVec(cWORx,cWORy,cWORz,cWAVx,cWAVy,cWAVz)*3.6 --right vel
        if abs(rV) < 0.1 or sign(strafeInput) ~= sign(rV) then rV = 0 end
        local uV = dotVec(cWOUPx,cWOUPy,cWOUPz,cWAVx,cWAVy,cWAVz)*3.6 -- up vel
        if abs(uV) < 0.1 or sign(upInput) ~= sign(uV) then uV = 0 end
        --system.print("uV="..uV)
        targetLatSpeed = clamp(rV + strafeInput*strafeStep,-strafeSpeed,strafeSpeed)
        --system.print("uv="..round(uV,2).." input"..round(upInput,2).."strafeStep"..round(strafeStep,2).." strafeSpeed"..round(strafeSpeed,2))
        targetVertSpeed = VStabAltLock ~= nil and VStabAltLock-alt or clamp(uV + upInput*strafeStep,-strafeSpeed,strafeSpeed)
       end
      end

      if MM == "DRONE" and modeRocket == true then
       if abs(Ax0) > 85 then rocketWarmup = false end
       if rocketWarmup then
        targetVertSpeed = P.ES.aMS.value * (abs(Ax0)/90)
       else
        targetVertSpeed = P.ES.aMS.value
       end
      elseif MM == "DRONE" and modeRocket == false then
       local wLx, wLy, wLz = cross(nwVx, nwVy, nwVz, cWOUPx, cWOUPy, cWOUPz) -- world left
       local wFx, wFy, wFz = norm(cross(-nwVx, -nwVy, -nwVz, wLx, wLy, wLz)) -- world forward (forward perpendicular to grav.)
       local cFx, cFy, cFz = norm(cross(wLx, wLy, wLz, cWOUPx, cWOUPy, cWOUPz)) -- C forward

       local fGA = dotVec(gx, gy, gz, cFx, cFy, cFz) -- forward grav. acceleration (my forward engine)
       local fAirA = dotVec(WAFAx, WAFAy, WAFAz, cFx, cFy, cFz) -- forward air resistance acceleration
       local fTotA = fGA + fAirA -- forward total acceleration
       local fS = dotVec(cWAVx, cWAVy, cWAVz, cFx, cFy, cFz) -- forward speed

       -- Angle from world vertical (radians)
       local fAngle = acos(dotVec(cWOUPx, cWOUPy, cWOUPz, nwVx, nwVy, nwVz) / (vectorLen(cWOUPx, cWOUPy, cWOUPz) * vectorLen(nwVx, nwVy, nwVz)))
       local adjacent = fTotA + fS
       local hyp = adjacent/math.cos(fAngle)
       local tVx, tVy, tVz = multiplyVec(wFx, wFy, wFz, hyp) -- scale to max grav. thrust

       -- Downinput shifts vector down
       local downInput = upInput < 0 and abs(upInput) or 0 -- downInput
       local dVx, dVy, dVz = multiplyVec(-nwVx, -nwVy, -nwVz, downInput*(abs(planetVertSpeedMPS)+hyp+50))
       local tVx, tVy, tVz = tVx+dVx, tVy+dVy, tVz+dVz -- add downinput vector

       -- Convert back to local coords
       local tLVx, tLVy, tLVz = world2local(tVx, tVy, tVz)
       targetLatSpeed, targetLongSpeed, targetVertSpeed = multiplyVec(tLVx, tLVy, tLVz, 3.6) -- convert to kph

       -- MODIFIERS --
       local ncWAVx, ncWAVy, ncWAVz = norm(cWAVx, cWAVy, cWAVz)
       local VvsNZang = acos(dotVec(-cWOUPx, -cWOUPy, -cWOUPz, ncWAVx, ncWAVy, ncWAVz) / (vectorLen(-cWOUPx, -cWOUPy, -cWOUPz) * vectorLen(ncWAVx, ncWAVy, ncWAVz)))*rad2deg
       --angle between velocity vector and -z axis (when to brake)
       if brakeInput == 1 
        or finalYawInput == 0 and finalPitchInput == 0 and finalRollInput == 0 and upInput == 0 and (
         VvsNZang < 95 or VvsNZang > 165 or xyzSpeedKPH < 0.01
        )
       then
        targetLatSpeed, targetLongSpeed, targetVertSpeed = 0,0,0
       end
     
       local targetForwardSpeed = dotVec(tVx, tVy, tVz, cFx, cFy, cFz)
       local targetForwardAcceleration = targetForwardSpeed - fS
       local forwardRemainingAcceleration = fTotA - targetForwardAcceleration

       -- only up, not down input --
       local extraVertSpeed = upInput > 0 and upInput*strafeSpeed or 0
       targetVertSpeed = targetVertSpeed + extraVertSpeed
      end

      local overRide = false
      if autoLand == true then
       if MM ~= "DRONE" then
        overRide = true
        targetLongSpeed = 0
        ThrottlePos = 0
        Nav:resetThrottleValue()
        Nav:setThrottleValue(0)
        Nav:updateHovers(-1,nil,P.ES.hoM.value)
        targetLatSpeed = 0
       end

       local minSpd = 3
       -- Calculate Approach Speed --
       if hasGndDet == false then 
        targetVertSpeed = -20 -- crash landing
       else
        if Gnd.height > -1 then --I sense the ground
         if Gnd.height < P.AS.grO.value then -- close
          targetVertSpeed = -minSpd*3.6 * P.AS.aLR.value
         else -- ratio of distance left
          targetVertSpeed = landSpeed * 0.9 * 3.6 * P.AS.aLR.value
         end
        else -- can't detect the ground
         if alt - currentPlanetMaxStatic > 200 then --accelerate
          targetVertSpeed = -5000
         else
          targetVertSpeed = landSpeed * 3.6 * P.AS.aLR.value
         end
        end
       end
       checkLanded()-- turn off Engines when stopped
      elseif autoStart == true then
       overRide = true
       targetLongSpeed = 0
       ThrottlePos = 0
       Nav:resetThrottleValue()
       Nav:setThrottleValue(0)
       targetLatSpeed = 0
       if time - autoStartTime < 3 then
        targetVertSpeed = 10
       else
        autoStart = false
       end
      end


      if MM == "DRONE" or MM == "PLATFORM" then 
       --ThrottlePos = targetLongSpeed --TODO Change this to better represent target speed
      elseif MM == "TRAVEL" or MM == "CRUISE" then 
       targetLongSpeed = ThrottlePos
      end

      -- widgets complete thrust override
      for _, cWidget in ipairs(customWidgets) do
       local longSpeed, latSpeed, vertSpeed, otAVx, otAVy, otAVz = nil,nil,nil,nil,nil,nil
       local status, err = pcall(function ()
        longSpeed, latSpeed, vertSpeed, otAVx, otAVy, otAVz = cWidget:flushOverRide()
       end)
       if not status then system.print(err) end
       if longSpeed ~= nil and latSpeed  ~= nil and vertSpeed  ~= nil and otAVx ~= nil and otAVy ~= nil and otAVz  ~= nil then
        tAVx, tAVy, tAVz = otAVx, otAVy, otAVz
        targetLatSpeed = latSpeed
        targetLongSpeed = longSpeed
        targetVertSpeed = vertSpeed
        overRide = true
        break
       end
      end

      --if aggData.State == "ON" then
      -- local aggAD = alt - aggData.Altitude
      -- if abs(aggAD) > 240 and upInput == 0 then
      --  targetVerticalSpeed =  aggAD - sign(aggAD)*230
      -- end
      --end

      -- Brake Module --
      local hold = false -- Hold Position, No inputs
      if finalPitchInput==0 and finalRollInput==0 and finalYawInput==0 and upInput==0 and not modeRocket and not autoLand and ThrottlePos == 0 
      and xyzSpeedKPH < 1 
      then hold = true end

      local b = {la=targetLatSpeed,lo=targetLongSpeed,v=targetVertSpeed,dLa=1,dv=1} --brake matrix
      alignmentFactor = inspace == 0 and P.AS.aAD.value or P.AS.sAD.value

      if brakeInput > 0 or hold then 
       b.la, b.lo, b.v = 0,0,0
      elseif autoLand then
       --if MM == "DRONE" then system.print("auto land braking") end
      elseif P.AS.iAB.value == false then --drift braking turned off
       if MM == "DRONE" and modeRocket == true then
        -- rocket braking slows down max speed
        b.la=nil;b.lo=nil;b.v=nil
       elseif MM == "DRONE" and modeRocket == false then
        local inputs = finalPitchInput~=0 or finalRollInput~=0 -- or finalYawInput~=0
        -- drone braking messes up turning
        if inputs then b.la=nil;b.lo=nil;b.v=nil end
       elseif MM == "TRAVEL" then
        -- trying to drift and not brake
        b.la=nil;b.v=nil
        if xyzSpeedKPH > P.AS.aBS.value or ThrottlePos ~= 0 then
         --trying to coast or accelerate
         b.lo=nil
        end 
       elseif MM == "CRUISE" then
        b.la=nil;b.v=nil
       elseif MM == "PLATFORM" then
        if xyzSpeedKPH > P.AS.aBS.value then --faster than autoBrakeSpeed
         b.la=nil;b.lo=nil;b.v=nil
        end
       elseif overRide == true then
        --TODO fix this?
        b.la=nil;b.lo=nil;b.v=nil
       end
      elseif P.AS.iAB.value == true then
       if MM == "DRONE" and modeRocket == true then
        --TODO
       elseif MM == "DRONE" and modeRocket == false then
        --TODO
       elseif MM == "TRAVEL" or MM == "CRUISE" then
        --system.print("p drift=".. 180 - round(abs(Ax),1).." yaw drift=".. 180 - round(abs(Az),1))
        b.dLa=1+abs(Az/180)
        if 180 - abs(Az) > 180 * alignmentFactor then --drifting less than thrshold = no brakes
          b.la=nil
        end
        b.dv=1+abs(Ax/180)
        if 180 - abs(Ax) > 180 * alignmentFactor then
          b.v=nil
        end
        if MM == "TRAVEL" and (xyzSpeedKPH > P.AS.aBS.value or ThrottlePos ~= 0) then --over auto brake speed
         b.lo=nil
        end
       end
      end

      local longBx, longBy, longBz = 0, 0, 0 --longitudinal brake
      local latBx, latBy, latBz = 0, 0, 0 --lateral brake
      local vertBx, vertBy, vertBz = 0, 0, 0 --vertical brake
      if inAtmo and Nav:getAtmoMaxSpeed() > 0 and xyzSpeedKPH > Nav:getAtmoMaxSpeed() then
       b.la=xSpeedKPH;b.lo=ySpeedKPH;b.v=zSpeedKPH
       --TODO fix this to brake since over speed
      end
      if b.la ~= nil then latBx, latBy, latBz = Nav:composeBrakeAcceleration("lateral",b.la) end
      if b.lo ~= nil then longBx, longBy, longBz = Nav:composeBrakeAcceleration("longitudinal",b.lo) end
      if b.v ~= nil then vertBx, vertBy, vertBz = Nav:composeBrakeAcceleration("vertical",b.v) end

      local SBF = inspace == 1 and P.ES.spB.value or 1
      local LBF = P.ES.loB.value
      local lBF = P.ES.laB.value
      local vBF = P.ES.vtB.value
      local brakeAx = longBx*LBF*SBF + latBx*lBF*SBF*b.dLa + vertBx*vBF*SBF*b.dv
      local brakeAy = longBy*LBF*SBF + latBy*lBF*SBF*b.dLa + vertBy*vBF*SBF*b.dv
      local brakeAz = longBz*LBF*SBF + latBz*lBF*SBF*b.dLa + vertBz*vBF*SBF*b.dv
      BrakeAcc = {brakeAx, brakeAy, brakeAz}

      -- Thrust Composer
      if MM == "TRAVEL" and overRide == false then
       longAx, longAy, longAz = Nav:composeAccelerationFromThrottle()
      else
       longAx, longAy, longAz = Nav:composeAccelerationFromTargetSpeed("longitudinal",targetLongSpeed)
      end
      latAx, latAy, latAz = Nav:composeAccelerationFromTargetSpeed("lateral",targetLatSpeed)
      vertAx, vertAy, vertAz = Nav:composeAccelerationFromTargetSpeed("vertical",targetVertSpeed)

      TargetSpeed = {targetLatSpeed,targetLongSpeed,targetVertSpeed}

      --Space brakes holding in position, no need for eng.
      if inspace == 1 and targetLongSpeed == 0 and ThrottlePos == 0 and upInput == 0 and strafeInput == 0 and xyzSpeedKPH < 3 then
       longAx, longAy, longAz = 0, 0, 0
       latAx, latAy, latAz = 0, 0, 0
       vertAx, vertAy, vertAz = 0, 0, 0
      end

      -- Torque
      local vF = 500/(deltaTick*1000) -- 2 frames per sampling resolution
      local aVCF = P.ES.anD.value
      if finalYawInput ~= 0 or finalPitchInput ~= 0 or finalRollInput ~= 0 then aVCF = 1 end
      if (tAVxPID == nil) then tAVxPID = pid.new(1,0,0) end --cMAS*1.2,0.02,2*aVCF
      tAVxPID:inject((tAVx - cWAngVx)*vF*aVCF - wAFAAx)
      if (tAVyPID == nil) then tAVyPID = pid.new(1,0,0) end
      tAVyPID:inject((tAVy - cWAngVy)*vF*aVCF - wAFAAy)
      if (tAVzPID == nil) then tAVzPID = pid.new(1,0,0) end
      tAVzPID:inject((tAVz - cWAngVz)*vF*aVCF - wAFAAz)
      local angAccelx = tAVxPID:get()
      local angAccely = tAVyPID:get()
      local angAccelz = tAVzPID:get()
      unit.setEngineCommand('torque', {0,0,0}, {angAccelx, angAccely, angAccelz}, 1, 1, '', '', '', 1)

      -- Thrust
      local allx,ally,allz = longAx + latAx + vertAx, longAy + latAy + vertAy, longAz + latAz + vertAz
      ThrustAcc = {allx,ally,allz}
      local tags = "airfoil,not_ground thrust"
      if P.ES.hov.value == "ON" then
       tags = tags..",ground"
      else
       unit.setEngineCommand("ground", {0,0,0}, {0,0,0}, 0, 1, '', '', '', 1)
      end
      unit.setEngineCommand(tags, ThrustAcc, {0,0,0}, 0, 1, 'airfoil', 'hover_engine', 'eco', 0)

      -- Brake
      unit.setEngineCommand('brake', BrakeAcc, {0,0,0}, 0, 1, '', '', '', 1)

     else
      Nav:updateHovers(-1,nil,P.ES.hoM.value)
      unit.setEngineCommand('thrust, torque', {0,0,0}, {0, 0, 0}, 1, 1, '', '', '', 1)
      local longBx, longBy, longBz = Nav:composeBrakeAcceleration("longitudinal",0)
      local latBx, latBy, latBz = Nav:composeBrakeAcceleration("lateral",0)
      local vertBx, vertBy, vertBz = Nav:composeBrakeAcceleration("vertical",0)
      local brakeAx, brakeAy, brakeAz = longBx + latBx + vertBx, longBy + latBy + vertBy, longBz + latBz + vertBz
      BrakeAcc = {brakeAx, brakeAy, brakeAz}
      unit.setEngineCommand('brake', BrakeAcc, {0,0,0}, 0, 1, '', '', '', 1)
     end
    end