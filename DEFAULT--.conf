# conf file for DEFAULT-- flight script by TheGreatSardini
# Modified from DEFAULT ++ by Jeronimo

name: (PILOT) DEFAULT-- v0.10.8

slots:
 core:
  class: CoreUnit
 gyro:
  class: GyroUnit
 DB:
  class: DataBankUnit
  select: manual
 shield:
  class: ShieldGeneratorUnit
 radar:
  class: RadarPVPUnit
  select: manual
 antigrav:
  class: AntiGravityGeneratorUnit
 warpdrive:
  class: WarpDriveUnit
 atmofueltank:
  class: AtmoFuelContainer
  select: manual
 spacefueltank:
  class: SpaceFuelContainer
  select: manual
 rocketfueltank:
  class: RocketFuelContainer
  select: manual
 switch:
  class: ManualSwitchUnit
  select: manual
 telemeter:
  class: TelemeterUnit
 vBooster:
  class: VerticalBooster
 hover:
  class: Hovercraft
 screen:
  class: ScreenUnit
  select: manual
handlers:
 unit:
  onStart:
   lua: |
    if #switch ~= 0 then switch_1.activate() end
    printDebug = true --export: Print extra data in the lua channel while executing actions
    PerUserSaves = true --export: Save ALL users separately false = other users share one profile
    masterDataID = true --export: Use Master User parameters as reference for other users
    widgetsFolder = "autoconf.custom.WIDGETS--" --export: widgets folder directory
    serverMaxSpeed = 200000 --export: max speed set on the server

    p = system.print
    pd = function(s) if printDebug then p(s) end end
    P = {
     w_title = "MAIN MENU",
     w_pos = {x=0, y=0},
     w_open = false,
     AP_destination = {value = {0,0,0}},
     [1] = 'MS',
     [2] = 'ES',
     [3] = 'AS',
     [4] = 'WS',
     [5] = 'KP',
     [6] = 'Widgets_Custom',
     MS = {
      w_title = "MENU SETTINGS",
      w_pos = {x=5, y=50},
      w_open = true,
      [1] = 'TC',
      [2] = 'TCA',
      [3] = 'TTC',
      [4] = 'TFS',
      [5] = 'separator',
      [6] = 'WC',
      [7] = 'WCA',
      [8] = 'WTC',
      [9] = 'WFS',
      [10] = 'separator',
      [11] = 'BC',
      [12] = 'BBC',
      [13] = 'BCA',
      [14] = 'BTC',
      [15] = 'BFS',
      [16] = 'separator',
      [17] = 'wTC',
      [18] = 'wAC',
      [19] = 'WFC',
      [20] = 'separator',
      [21] = 'MSS',
      [22] = 'separator',
      [23] = 'PRESET',
      TC = {name = "TITLE COLOR", value = "white", range = {}, q = false},
      TCA = {name = "TITLE ALPHA", value = 1, range = {0,1}, step = {0.1, 0.05}, increment = 0.1, q = false},
      TTC = {name = "TITLE TEXT COLOR", value = "black", range = {}, q = false},
      TFS = {name = "TITLE FONT SIZE", value = 17, range = {8,32}, step = {1, 2}, increment = 1, q = false},
      WC = {name = "WINDOW COLOR", value = "midnightblue", range = {}, q = false},
      WCA = {name = "WINDOW ALPHA", value = 0.4, range = {0,1}, step = {0.1, 0.05}, increment = 0.1, q = false},
      WTC = {name = "WINDOW TEXT COLOR", value = "skyblue", range = {}, q = false},
      WFS = {name = "WINDOW FONT SIZE", value = 12, range = {8,32}, step = {1, 2}, increment = 1, q = false},
      BC = {name = "BUTTON COLOR", value = "white", range = {}, q = false},
      BBC = {name = "BUTTON BORDER COLOR", value = "lightgray", range = {}, q = false},
      BCA = {name = "BUTTON ALPHA", value = 0.1, range = {0,1}, step = {0.1, 0.05}, increment = 0.1, q = false},
      BTC = {name = "BUTTON TEXT COLOR", value = "white", range = {}, q = false},
      BFS = {name = "BUTTON FONT SIZE", value = 12, range = {8,32}, step = {1, 2}, increment = 1, q = false},
      wTC = {name = "WIDGET TEXT COLOR", value = "skyblue", range = {}, q = false},
      wAC = {name = "WIDGET MOTION COLOR", value = "red", range = {}, q = false},
      WFC = {name = "WIDGET FIXED COLOR", value = "white", range = {}, q = false},
      MSS = {name = "MENUS GLOBAL SCALE", value = 1, range = {0.5,3}, step = {0.01, 0.1}, increment = 0.01, q = false},
      PRESET = {name = "COLOR PRESETS", value = "preset1", range = {"preset0","preset1","preset2","preset3","preset4","preset5"}, q = true},
     },
     ES = {
      w_title = "ENGINE SETTINGS",
      w_pos = {x=270, y=50},
      w_open = true,
      [1] = 'pSF',
      [2] = 'ySF',
      [3] = 'rSF',
      [4] = 'anD',
      [5] = 'separator',
      [6] = 'loF',
      [7] = 'laF',
      [8] = 'vtF',
      [9] = 'separator',
      [10] = 'loB',
      [11] = 'laB',
      [12] = 'vtB',
      [13] = 'spB',
      [14] = 'separator',
      [15] = 'gyr',
      [16] = 'pAd',
      [17] = 'rAd',
      [18] = 'separator',
      [19] = 'hov',
      [20] = 'hoM',
      [21] = 'hoA',
      [22] = 'hoS',
      [23] = 'agA',
      [24] = 'separator',
      [25] = 'eng',
      [26] = 'aMS',
      [27] = 'separator',
      [28] = 'dCA',
      [29] = 'dSA',
      [30] = 'separator',
      [31] = 'fpP',
      pSF = {name = "PITCH FACTOR", value = 1, range = {0,10}, step = {0.01, 0.1, 0.5}, increment = 0.1, q = false},
      ySF = {name = "YAW FACTOR", value = 1, range = {0,10}, step = {0.01, 0.1, 0.5}, increment = 0.1, q = false},
      rSF = {name = "ROLL FACTOR", value = 1, range = {0,10}, step = {0.01, 0.1, 0.5}, increment = 0.1, q = false},
      anD = {name = "ANGULAR DAMPENING", value = 0.2, range = {0,10}, step = {0.01, 0.1, 0.5}, increment = 0.1, q = false},
      loF = {name = "LONG ENGINE FACTOR", value = 1, range = {0,1}, step = {0.01, 0.1, 0.5}, increment = 0.1, q = false},
      laF = {name = "LAT ENGINE FACTOR", value = 1, range = {0,1}, step = {0.01, 0.1, 0.5}, increment = 0.1, q = false},
      vtF = {name = "VERT ENGINE FACTOR", value = 1, range = {0,1}, step = {0.01, 0.1, 0.5}, increment = 0.1, q = false},
      loB = {name = "LONG BRAKE FACTOR", value = 1, range = {0,10}, step = {0.01, 0.1, 0.5}, increment = 0.1, q = false},
      laB = {name = "LAT BRAKE FACTOR", value = 1, range = {0,10}, step = {0.01, 0.1, 0.5}, increment = 0.1, q = false},
      vtB = {name = "VERT BRAKE FACTOR", value = 1, range = {0,10}, step = {0.01, 0.1, 0.5}, increment = 0.1, q = false},
      spB = {name = "SPACE BRAKE INTENSITY", value = 1, range = {0,10}, step = {0.01, 0.1, 0.5}, increment = 0.1, q = false},
      gyr = {name = "GYRO AXIS", value = "OFF", range = {"ON","CROSS","SPACE AUTO","OFF"}, q = false},
      pAd = {name = "PITCH TILTING", value = 0, range = {-90,90}, step = {1, 45, 90}, increment = 1, q = false},
      rAd = {name = "ROLL TILTING", value = 0, range = {-90,90}, step = {1, 45, 90}, increment = 1, q = false},
      hov = {name = "HOVERS ON/OFF", value = "ON", range = {"ON","OFF"}, q = false},
      hoM = {name = "HOVERS MODE", value = "DYNAMIC", range = {"DYNAMIC","STATIC","AUTO"}, q = true},
      hoA = {name = "HOVERS ALTITUDE", value = 5, range = {0,80}, step = {0.1, 1, 5}, increment = 1, q = true},
      hoS = {name = "HOVERS STRENGTH", value = 2.5, range = {1,10}, step = {0.1, 0.5, 1}, increment = 0.5, q = true},
      agA = {name = "AGG ALTITUDE", value = 1000, range = {-1,500000}, step = {1, 10, 100, 1000, 10000}, increment = 100, q = false},
      eng = {name = "ENGINES ON/OFF", value = "AUTO", range = {"ON","OFF","AUTO"}, q = false},
      aMS = {name = "ATMO MAX SPEED", value = -2, range = {-2,29999}, step = {1, 10, 100}, increment = 10, q = false},
      dCA = {name = "DRONE CRUISE ANGLE", value = 22, range = {1,88}, step = {1, 5, 10}, increment = 1, q = false},
      dSA = {name = "DRONE SHIFT ANGLE", value = 60, range = {1,88}, step = {1, 5, 10}, increment = 1, q = false},
      fpP = {name = "FPS FLUSH PROTECT", value = -1, range = {-1,100}, step = {1, 5, 10}, increment = 1, q = false}
     },
     AS = {
      w_title = "AUTO-ASSIST SETTINGS",
      w_pos = {x=535, y=50},
      w_open = true,
      [1] = 'aBS',
      [2] = 'separator',
      [3] = 'stA',
      [4] = 'auR',
      [5] = 'tuA',
      [6] = 'tAR',
      [7] = 'tAP',
      [8] = 'separator',
      [9] = 'auP',
      [10] = 'aPA',
      [11] = 'atS',
      [12] = 'anS',
      [13] = 'separator',
      [14] = 'iAB',
      [15] = 'lIF',
      [16] = 'vIF',
      [17] = 'sAD',
      [18] = 'iAI',
      [19] = 'aPG',
      [20] = 'aOS',
      [21] = 'separator',
      [22] = 'rMS',
      [23] = 'separator',
      [24] = 'dok',
      [25] = 'separator',
      [26] = 'bBu',
      [27] = 'aLR',
      [28] = 'grO',
      [29] = 'aSO',
      [30] = 'separator',
      [31] = 'aAP',
      aBS = {name = "AUTO BRAKE SPEED", value = 100, range = {0,1000}, step = {1, 5, 10}, increment = 1, q = false},
      stA = {name = "AUTO LEVEL ALT. MAX", value = 200000, range = {-2000,500000}, step = {100, 1000, 10000}, increment = 100, q = false},
      auR = {name = "ROLL STABILISATION", value = true, q = false},
      tuA = {name = "TURN ASSIST", value = false, q = true},
      tAR = {name = "TURN ASSIST MIN ROLL", value = 3, range = {1,90}, step = {1, 5, 10}, increment = 1, q = false},
      tAP = {name = "TURN ASSIST MAX PITCH", value = 45, range = {1,90}, step = {1, 5, 10}, increment = 1, q = false},
      auP = {name = "PITCH STABILISATION", value = true, q = false},
      aPA = {name = "AUTO PITCH AMPLITUDE", value = 2, range = {1,90}, step = {0.5, 1, 5}, increment = 1, q = false},
      atS = {name = "ALTITUDE STABILISATION", value = true, q = false},
      anS = {name = "ATMO ANTI-STALL", value = false, q = false},
      iAB = {name = "INERTIA AUTO BRAKE", value = true, q = true},
      lIF = {name = "LAT DRIFT BRAKE ANGLE", value = 5, range = {1,179}, step = {0.1,1,10}, increment = 1, q = false},
      vIF = {name = "VERT DRIFT BRAKE ANGLE", value = 45, range = {1,179}, step = {0.1,1,10}, increment = 1, q = false},
      sAD = {name = "SPACE DRIFT BRAKE ANGLE", value = 85, range = {1,179}, step = {0.1,1,10}, increment = 1, q = false},
      iAI = {name = "AUTO BRAKE INTENSITY", value = 2, range = {0,10}, step = {0.01, 0.1, 1}, increment = 0.1, q = false},
      aPG = {name = "SPACE AUTO PROGRADE", value = false, q = false},
      aOS = {name = "AUTO ORBIT SPEED", value = false, q = false},
      rMS = {name = "ROCKETS MAX SPEED", value = 1200, range = {-1,serverMaxSpeed}, step = {1, 10, 100}, increment = 10, q = false},
      dok = {name = "DOCKING PARENT", value = "MANUAL", range = {"MANUAL","OWNER","CLOSEST"}, q = false},
      bBu = {name = "BACK BURN", value = false, q = false},
      aLR = {name = "AUTO LAND FACTOR", value = 0.7, range = {0,1.1}, step = {0.001, 0.01, 0.1}, increment = 0.1, q = false},
      grO = {name = "GROUND OFFSET", value = 3, range = {0,50}, step = {0.1, 1}, increment = 1, q = false},
      aSO = {name = "LANDING AUTO SHUT OFF", value = false, q = false},
      aAP = {name = "ALTITUDE HOLD ATMO %", value = 10, range = {0.1,20}, step = {0.1, 1}, increment = 1, q = false},
     },
     WS = {
      w_title = "WIDGETS",
      w_pos = {x=800, y=50},
      w_open = true,
      [1] = 'w_hud',
      [2] = 'w_platform',
      [3] = 'w_speedometer',
      [4] = 'w_gyro',
      [5] = 'w_fuel',
      [6] = 'separator',
      [7] = 'w_core',
      [8] = 'w_agg',
      [9] = 'w_warp',
      [10] = 'w_parenting',
      [11] = 'w_cstress',
      [12] = 'w_shield',
      [13] = 'separator',
      [14] = 'w_periscope',
      [15] = 'w_radar',
      [16] = 'w_refresh',
      [17] = 'separator',
      [18] = 'HELP_MENU',
      w_hud = {name = "HUD", value = "Default --", range = {"Default --","None"}, q = false},
      w_platform = {name = "PLATFORM HUD", value = "None", range = {"Default --","None"}, q = false},
      w_speedometer = {name = "SPEEDOMETER", value = "None", range = {"Default", "None"}, q = false},
      w_gyro = {name = "GYROSCOPE", value = "None", range = {"Default", "None"}, q = false},
      w_fuel = {name = "FUEL TANKS", value = "None", range = {"Default", "None"}, q = false},
      w_core = {name = "CORE", value = "None", range = {"Default", "ALT", "None"}, q = false},
      w_agg = {name = "AGG", value = "None", range = {"Default", "ALT", "None"}, q = false},
      w_warp = {name = "WARP DRIVE", value = "None", range = {"Default", "ALT", "Auto", "None"}, q = false},
      w_parenting = {name = "PARENTING", value = "None", range = {"Default", "ALT", "None"}, q = false},
      w_cstress = {name = "COMBAT STRESS", value = "None", range = {"Default", "ALT", "None"}, q = false},
      w_shield = {name = "SHIELD", value = "None", range = {"Default", "ALT", "None"}, q = false},
      w_periscope = {name = "PERISCOPE", value = "None", range = {"Default", "ALT", "None"}, q = false},
      w_radar = {name = "RADAR", value = "None", range = {"Default", "ALT", "None"}, q = false},
      w_refresh = {name = "GUI REFRESH RATE", value = 0.01, range = {0.001,1}, step = {0.001, 0.01, 0.1}, increment = 0.001, q = false},
      HELP_MENU = {name = "HELP MENU", value = "Hover", range = {"Open", "ALT", "Hover", "None"}, q = true},
     },
     KP = {
      w_title = "KEYBIND PARAMETERS",
      w_pos = {x=1065, y=50},
      w_open = true,
      [1] = 'flM',
      [2] = 'pkM',
      [3] = 'pMS',
      [4] = 'separator',
      [5] = 'iCo',
      [6] = 'mCI',
      [7] = 'kWU',
      [8] = 'dTT',
      [9] = 'shL',
      [10] = 'geL',
      [11] = 'mmb',
      [12] = 'bTM',
      [13] = 'separator',
      [14] = 'mvL',
      [15] = 'viL',
      [16] = 'separator',
      [17] = 'moC',
      [18] = 'mCS',
      [19] = 'separator',
      [20] = 'flightModeKB',
      [21] = 'mouseControlKB',
      [22] = 'movementLockKB',
      [23] = 'altitudeAP',
      [24] = 'viewLockKB',
      [25] = 'speedLockKB',
      [26] = 'showScreenKB',
      flM = {name = "FLIGHT MODE", value = "TRAVEL", range = {"CRUISE","TRAVEL","PLATFORM","DRONE"}, q = true},
      pkM = {name = "PARKING MODE", value = "PLATFORM", range = {"PLATFORM","DRONE","OFF"}, q = true},
      pMS = {name = "PARKING MAX SPEED", value = 50, range = {0,29999}, step = {1, 10, 100}, increment = 1, q = false},
      iCo = {name = "QE/AD INVERT", value = false, q = false},
      mCI = {name = "Y Axis Invert", value = false, q = false},
      kWU = {name = "KEYPRESS WARMUP", value = 0.1, range = {0.1,10.0}, step = {0.1, 1}, increment = 0.1, q = false},
      dTT = {name = "DOUBLE TAP TIME", value = 0.25, range = {0.01,1}, step = {0.01, 0.1}, increment = 0.01, q = false},
      shL = {name = "SHIFT LOCK", value = false, q = false},
      geL = {name = "G TOGGLES PARKING", value = false, q = false},
      mmb = {name = "MIDDLE MOUSE BUTTON", value = "MAX THROTTLE", range = {"NONE", "MAX THROTTLE", "BRAKE"}, q = false},
      bTM = {name = "BRAKE TOGGLE MODE", value = false, q = false},
      mvL = {name = "FREEZE MOVEMENT", value = false, q = false},
      viL = {name = "FREEZE VIEW", value = false, q = false},
      moC = {name = "MOUSE CONTROL", value = false, q = false},
      mCS = {name = "M-C SENSITIVITY", value = 0.3, range = {0.01,10}, step = {0.01,0.1, 1}, increment = 0.1, q = false},
      flightModeKB = {name = "FLIGHT MODE KB", value = "ALT+3", range = {"ALT+3","ALT+4","ALT+5","ALT+6","ALT+7","ALT+8","ALT+9", "None"}, q = false},
      mouseControlKB = {name = "MOUSE CONTROL KB", value = "ALT+4", range = {"ALT+3","ALT+4","ALT+5","ALT+6","ALT+7","ALT+8","ALT+9", "None"}, q = false},
      movementLockKB = {name = "MOVEMENT FREEZE KB", value = "ALT+5", range = {"ALT+3","ALT+4","ALT+5","ALT+6","ALT+7","ALT+8","ALT+9", "None"}, q = false},
      altitudeAP = {name = "10% Atmo KB", value = "ALT+6", range = {"ALT+3","ALT+4","ALT+5","ALT+6","ALT+7","ALT+8","ALT+9", "None"}, q = false},
      viewLockKB = {name = "VIEW FREEZE KB", value = "ALT+7", range = {"ALT+3","ALT+4","ALT+5","ALT+6","ALT+7","ALT+8","ALT+9", "None"}, q = false},
      speedLockKB = {name = "ATMO SPEED LOCK KB", value = "ALT+8", range = {"ALT+3","ALT+4","ALT+5","ALT+6","ALT+7","ALT+8","ALT+9", "None"}, q = false},
      showScreenKB = {name = "SHOW HUDS KB", value = "ALT+9", range = {"ALT+3","ALT+4","ALT+5","ALT+6","ALT+7","ALT+8","ALT+9", "None"}, q = false},
     },
     Widgets_Custom = {
      w_title = "CUSTOM WIDGETS",
      w_pos = {x=1330, y=50},
      w_open = true,
      w_scale = 1,
     },
     QuickToolBar = {
      w_title = "QUICK TOOL BAR",
      w_pos = {x=770, y=500},
      w_open = false,
      w_scale = 1,
     },
     help_menu = {
      w_title = "HELP",
      w_pos = {x=720, y=580},
      w_open = false,
      w_scale = 1,
      w_html = "INSTRUCTION MANUAL",
      [1] = 'separator',
      [2] = 'Info_Page',
      [3] = 'separator',
      [4] = 'separator',
      [5] = 'MS',
      [6] = 'separator',
      [7] = 'ES',
      [8] = 'separator',
      [9] = 'AS',
      [10] = 'separator',
      [11] = 'WS',
      [12] = 'separator',
      [13] = 'KP',
      [14] = 'separator',
      [15] = 'QuickToolBar',
      [16] = 'separator',
      [17] = 'separator',
      Info_Page = {name = "INSTRUCTION MANUAL", html = ""},
      MS = {name = "MENU SETTINGS", html = ""},
      ES = {name = "ENGINES SETTINGS", html = ""},
      AS = {name = "AUTOPILOT SETTINGS", html = ""},
      WS = {name = "WIDGET SETTINGS", html = ""},
      KP = {name = "KEYBIND PARAMS", html = ""},
      QuickToolBar = {name = "QUICK TOOL BAR", html = ""}
     }
    }
    script = {}
    script = {
     version = "v0.10.8",
     start = function()
      pd("Script initialisation started")
      onStartParams()
      pd("On start P loaded")
      getGlobals()
      pd("Closest planet: "..Helios[closestPlanetIndex].name[1])
      script.onTickData()
      setParamsFuelTanks()
      pd("Fuel tanks loaded: "..#fuelTanksData)
      loadParamsFromDB()
      previousPreset = P.MS.PRESET.value
      loadColorPreset()
      updateHelpMenu()
      paramsSetColorsRange()
      WindowLib:winlibCSSUpdate()
      pd("Winlibcss updated")
      if P.w_open == true then windowsShow() else windowsHide() end
      pd("Widgets display updated")
      WindowLib:update()
      pd("Winlib updated")
      updateParams()
      updateEngines()
      pd("Params updated")
      if P.ES.eng.value == "ON" then enginesToggle() end
      p("Script initialisation successfull")
      hasFinishedLoading = true
      help.print(system)
      unit.setTimer("DATA",0.5)
      unit.setTimer("SCREEN",P.WS.w_refresh.value)
      unit.setTimer("FPS",1)
      unit.setTimer("BACKUP",30)
     end,

     stop = function()
      if reset == false and hasFinishedLoading == true and not noDB() then p("saving to DB");setParams2DB() end 
      reset = false
      windowsHide()
      system.showScreen(0)
      if #switch ~= 0 then switch_1.deactivate() end
     end,

     onUpdate = function()
      if ALT == false and P.w_open == false and P.QuickToolBar.w_open == false then--and Engines == true then
       Nav:throttleUpdate()
      end
      if ALT == true or P.w_open == true or P.QuickToolBar.w_open == true then WindowLib:update() end
      if WindowLib.wlib_drag == true then WindowLib:performDrag() end
      
      if P.KP.moC.value == true and P.w_open == false and ALT == false then
       mouseControlUpdate()
      end
      if P.w_open == true or P.QuickToolBar.w_open == true then
       system.lockView(1)
      elseif P.KP.moC.value == true and ALT == true then
       system.lockView(0)
      end
      ArkTime = system.getArkTime()
      uCount = uCount + 1
      updateGyro()
      updateGear()
      unitData.maxBrake = construct.getMaxBrake()
      unitData.currentBrake = construct.getCurrentBrake()
      for i, cWidget in ipairs(customWidgets) do
       if type(cWidget.onUpdate) == 'function' and P["Widget_Custom"..i].w_open == true then
        local _ = processPcall(pcall(function() return cWidget:onUpdate() end))
       end
      end
     end,

     onTickData = function()
      local ind = 1
      local function decodeJSON(json)
       local decodedInput = string.gsub(json, "%\\u(%x%x%x%x)", function(a) return utf8.char(tonumber(a,16))end)
       return load('return ' .. decodedInput:gsub('[[]', '{'):gsub('[]]', '}'):gsub('"(%w+)":', '["%1"]='))()
      end
      getGlobals()
      fuelTanksData = {}
      if fueltanks then
       for i , v in ipairs(fueltanks) do
        fuelTanksData[i] = {}
        local decodeFT = decodeJSON(v.getWidgetData())
        fuelTanksData[i].name = decodeFT.name or "LOADING"
        fuelTanksData[i].percentage = decodeFT.percentage or 0.01
        fuelTanksData[i].timeLeft = decodeFT.timeLeft ~= "n/a" and decodeFT.timeLeft or 0.01
       end
      end
      if DB_1 ~= nil and DB_1.getStringValue("fueltanks") and DB_1.getStringValue("fueltanks") ~= "" then
       local function merge(t1, t2)
        if type(t1) ~= "table" or type(t2)~= "table" then return nil end
        local newT = t1
        for k,v in pairs(t2) do
         newT[ind] = v
         ind = ind + 1
        end 
        return newT
       end
       fuelTanksData = merge(fuelTanksData,Data:deserialize(DB_1.getStringValue("fueltanks"))) or fuelTanksData
      end
      local ftdl = #fuelTanksData
      if ftdl ~= 0 then table.sort(fuelTanksData, function(a,b) return a.name < b.name end) end
      if prevFTD ~= ftdl and ftdl ~= 0 then
       setParamsFuelTanks()
      end
      prevFTD = ftdl
      local decodeCU = decodeJSON(unit.getWidgetData())
      unitData.acceleration = decodeCU.acceleration or 0
      unitData.maxBrake = construct.getMaxBrake()
      unitData.currentBrake = construct.getCurrentBrake()
      unitData.atmoThrust = decodeCU.atmoThrust or 0
      unitData.spaceThrust = decodeCU.spaceThrust or 0
      unitData.unitOverLoad = decodeCU.showOverload or 0
      unitData.parentingInfo = decodeCU.parentingInfo
      local gMS = construct.getMaxSpeedPerAxis()
      unitData.maxSpeedMPS = gMS[3] --math.max(gMS[1],math.abs(gMS[2]),gMS[3],math.abs(gMS[4]),gMS[5],math.abs(gMS[6]))
      unitData.maxSpeedkph = unitData.maxSpeedMPS * 3.6
      Nav:updateMaxSpeed(unitData.maxSpeedkph)
      if antigrav then
       local decodeAGG = decodeJSON(antigrav.getWidgetData())
       aggData.Power = decodeAGG.antiGPower ~= nil and math.floor(decodeAGG["antiGPower"]*100) or 0
       aggData.Field = decodeAGG.antiGravityField ~= nil and math.floor(decodeAGG["antiGravityField"]*100).."Es" or "LOADING"
       aggData.Compensation = math.floor(antigrav.getCompensationRate()*1000)/10 .."%" or "N/A"
       aggData.Altitude = decodeAGG.baseAltitude ~= nil and decodeAGG.baseAltitude or 0
       aggData.State = antigrav.isActive() == true and "ON" or "OFF"
       aggData.Target = antigrav.getTargetAltitude()
      end
      if warpdrive then
       local decodeW = decodeJSON(warpdrive.getWidgetData())
       warpData.Info = decodeW.statusText or "LOADING" --old used buttonMsg
       warpData.Cells = decodeW.cellCount or 0
       warpData.Destination = decodeW.destination or "LOADING"
       warpData.Distance = decodeW.distance or "LOADING"
      end
      local dockingmode = 1
      if P.AS.dok.value == "CLOSEST" then dockingmode = 2 elseif P.AS.dok.value == "OWNER" then dockingmode = 3 end
      if construct.getDockingMode() ~= dockingmode then construct.setDockingMode(dockingmode) end

      if antigrav and P.ES.agA.value > 0 and antigrav.getTargetAltitude() ~= P.ES.agA.value then
       P.ES.agA.value = antigrav.getTargetAltitude()
      end
     end,

     onTickScreen = function()
      if ALT == false and P.w_open == false and P.QuickToolBar.w_open == false then WindowLib:update() end
     end,

     luaInput = function(text)
      if string.sub(text,1,5) == "reset" then
       if noDB() then return end
       if text:lower() == "reset all" then
        Data:ResetAll()
        p("Databank has been reset, please re-join the piloting controller.") 
        reset = true 
        unit.exit()
       elseif string.sub(text,1,11) == "reset other"  then
        Data:WipeAndReSave()
       else
        Data:ResetUser()
       end
      elseif string.sub(text,1,6) == "::pos{" then
       local px, py, pz = convertToWorldCoordinates(text)
       p(px.." : "..py.." : "..pz)
       P.AP_destination.value = {px, py, pz}
      elseif string.sub(text,1,3) == "alt" then
       HoldAltitude = extractAlt(text)
       if HoldAltitude ~= nil then Nav:prepareForFlight() end
       p("Hold Altitude set to: "..tostring(HoldAltitude))
      elseif text:lower() == "help" then 
       help.print()
      end
      
      for i, cWidget in ipairs(customWidgets) do
       if type(cWidget.onInputText) == 'function' and P["Widget_Custom"..i].w_open == true then
        local _ = processPcall(pcall(function() return cWidget:onInputText(text) end))
       end
      end

     end,

     receive = function(channel,message)
     end,

     onActionStart = function(action)
      keyBindsOnStartControl(action)
     end,

     onActionStop = function(action)
      keyBindsOnStopControl(action)
     end,

     onActionLoop = function(action)
      keyBindsOnLoopControl(action)
     end,
    }
    script.start()

  onStop:
   lua: |
    script.stop()

  onTimer:
   args: ["DATA"]
   lua: |
    script.onTickData()

  onTimer:
   args: ["SCREEN"]
   lua: |
    script.onTickScreen()

  onTimer:
   args: ["FPS"]
   lua: |
    fps = uCount
    uCount = 0

  onTimer:
   args: ["BACKUP"]
   lua: |
    if reset == false and hasFinishedLoading == true and not noDB() then setParams2DB() end

 system:
  onUpdate:
   lua: |
    script.onUpdate()
  onFlush:
   lua: |
    thrustManager()
    
  onActionStart(action):
   lua: |
    script.onActionStart(action)
    
  onActionStop(action):
   lua: |
    script.onActionStop(action)
     
  onActionLoop(action):
   lua: |
    script.onActionLoop(action)
    
  onInputText(text):
   lua: |
    script.luaInput(text)

 library:
  onStart:
   lua: |
    -- Data --
    dtbk = {}
    dtbk.__index = dtbk;
    function dtbk.new(bank)
     local self = setmetatable({}, dtbk)
     self.DB = bank
     self.concat = table.concat
     return self
    end
    function noDB()
     if #DB==0 then p("Attach Databank and re-install script");return true else return false end
    end
    function dtbk.getString(self,tag)
     if noDB() then return end
     return self.DB.getStringValue(tag)
    end
    function dtbk.setString(self,tag,value)
     if noDB() then return end
     self.DB.setStringValue(tag,value)
    end
    function dtbk.setData(self,tag,value)
     if noDB() then return end
     local str = self:serialize(value)
     self.DB.setStringValue(tag,str)
    end
    function dtbk.remove(self,key)
     if noDB() then return end
     self.DB.clearValue(key)
    end

    function dtbk.getData(self,tag)
     if noDB() then return end
     local str = processPcall(pcall(function() return self:deserialize(self.DB.getStringValue(tag)) end))
     return str
    end

    function dtbk.getLen(self,user)
     if noDB() then return end
     user = user==nil and 0 or user
     if not self.DB then return end
     local dbKeys = self.DB.getKeyList()
     local dbs = {}
     for i,v in ipairs(dbKeys) do
      local s = self.DB.getStringValue(v)
      if v ~= user then dbs[#dbs+1] = v.."="..s.."," end
     end
     return #table.concat(dbs)
    end

    function dtbk.ResetAll(self)
     if noDB() then return end
     self.DB.clear()
    end
    function dtbk.ResetUser(self)
     if noDB() then return end
     local user = player.getId()
     local masterUser = self:getData("masterUserID")
     self:remove(tostring(user))
     if masterUser and masterUser == user then
      self:remove("masterUserID")
     end
     p("Player: "..system.getPlayerName(user).."'s data has been reset") 
     reset = true 
     unit.exit()
    end
    function dtbk.WipeAndReSave(self)
     if noDB() then return end
     self:ResetAll()
     setParams2DB()
     p("current user is now the only profile on databank")
    end

    function dtbk.internalSerialize(self,table, tC, t)
     t[tC] = "{"
     tC = tC + 1
     if #table == 0 then
      local hasValue = false
      for key, value in pairs(table) do
       hasValue = true
       local keyType = type(key)
       if keyType == "string" then t[tC] = key .. "="
       elseif keyType == "number" then t[tC] = "[" .. key .. "]="
       elseif keyType == "boolean" then t[tC] = "[" .. tostring(key) .. "]="
       else t[tC] = "notsupported="
       end
       tC = tC + 1
       local check = type(value)
       if check == "table" then tC = self:internalSerialize(value, tC, t)
       elseif check == "string" then t[tC] = '"' .. value .. '"'
       elseif check == "number" then t[tC] = value
       elseif check == "boolean" then t[tC] = tostring(value)
       else t[tC] = '"Not Supported by Deserializer"'
       end
       t[tC + 1] = ","
       tC = tC + 2
      end
      if hasValue then
       tC = tC - 1
      end
     else
      for i = 1, #table do
       local value = table[i]
       local check = type(value)
       if check == "table" then tC = self:internalSerialize(value, tC, t)
       elseif check == "string" then t[tC] = '"' .. value .. '"'
       elseif check == "number" then t[tC] = value
       elseif check == "boolean" then t[tC] = tostring(value)
       else t[tC] = '"Not Supported by Deserializer"'
       end
       t[tC + 1] = ","
       tC = tC + 2
      end
      tC = tC - 1
     end
     t[tC] = "}"
     return tC
    end
    function dtbk.serialize(self,value)
     local t = {}
     local check = type(value)
     if check == "table" then
      self:internalSerialize(value, 1, t)
     elseif check == "string" then
      return '"' .. value .. '"'
     elseif check == "number" then
      return value
     elseif check == "boolean" then
      return tostring(value)
     else
      return '"Not Supported by Deserializer"'
     end
     return self.concat(t)
    end
    function dtbk.deserialize(self,s)
     return load("return " .. s)()
    end

    function dtbk.checkMasterUser(self)
     if noDB() then return end
     if not self:getData("masterUserID") then p("Setting Master user"); self:setData("masterUserID",player.getId()) end
     return self:getData("masterUserID")
    end

    function dtbk.currentUser(self)
     local masterUser = self:checkMasterUser()
     local userID = player.getId()
     local userName = player.getName()
     if not PerUserSaves and masterUser and masterUser ~= userID then --perUserSaves turned off, and I'm not master user
      local d2L = self:getData(tostring(player.getId()))
      if not d2L or type(d2L) ~= "table" then --if my data not found then I'm now "Other" user
       userID = 0
       userName = "Other"
      end
     end
     return userID, userName, masterUser
    end

    local function tableLen(t)
     local l = 0; 
     if type(t) == "table" then for _ in pairs(t) do l=l+1 end end
     return l
    end

    dP = {} -- params duplicate
    dC = {} -- colorPresets duplicate
    function setParams2DB()
     if #DB ~= 0 then
      local cP2S = {}
      for i, v in pairs(colorPresets) do
       local preset = {}
       for k, l in pairs(colorPresets[i]) do
        if l ~= dC[i][k] then preset[tostring(k)] = l end
       end
       if tableLen(preset) > 0 then cP2S[tostring(i)] = preset end
      end

      local data2Save = {
      ["V"] = script.version,
      ["CP"] = cP2S,
      ["APD"] = P.AP_destination.value,
      ["APLD"] = P.AP_lockedDestination,
      }
      local function cAs(k,a,b) --compare and save
       sa,sb = a,b
       if type(a) == "table" then sa=Data:serialize(a); sb=Data:serialize(b) end
       if sa ~= sb then data2Save[tostring(k)] = a end
      end
      cAs("MBP",P.w_pos,dP.w_pos)
      cAs("QMP",P.QuickToolBar.w_pos,dP.QuickToolBar.w_pos)
      cAs("QMS",P.QuickToolBar.w_pos,dP.QuickToolBar.w_scale)
      cAs("MBO",P.w_open,dP.w_open)
      cAs("HMP",P.help_menu.w_pos,dP.help_menu.w_pos)
      cAs("HMO",P.help_menu.w_open,dP.help_menu.w_open)
      cAs("HMS",P.help_menu.w_scale,dP.help_menu.w_scale)

      for i, v in ipairs(P) do
       if P[v].w_pos ~= nil then
        if Data:serialize(P[v].w_pos) ~= Data:serialize(dP[v].w_pos) then data2Save[tostring(v).."_w_p"] = P[v].w_pos end
        if P[v].w_open ~= dP[v].w_open then data2Save[tostring(v).."_w_o"] = P[v].w_open end
       end
       for k, l in ipairs(P[v]) do
        if P[v][l] then
         if P[v][l].value ~= nil then
          if type(P[v][l].value) ~= "function" and P[v][l].value ~= dP[v][l].value then
           data2Save[tostring(v)..tostring(l).."_v"] = P[v][l].value
          end
          if P[v][l].q ~= dP[v][l].q then data2Save[tostring(v)..tostring(l).."_q"] = P[v][l].q end
         end
        end
       end
      end
      for k, v in pairs(P) do
       if string.sub (tostring(k),1,7) == "Widget_" then
        cAs(tostring(k).."_w_p",P[k].w_pos,dP[k].w_pos)
        cAs(tostring(k).."_w_o",P[k].w_open,dP[k].w_open)
        cAs(tostring(k).."_w_s",P[k].w_scale,dP[k].w_scale)
       end
      end
      cAs("E",Engines,false)
      cAs("CT",Nav:getThrottleValue(),0)

      local userId, userName, _ = Data:currentUser()
      data2Save["name"] = userName
      local id = tostring(userId)
      local dblen = Data:getLen(id)
      local len = string.len(id.."="..Data:serialize(data2Save))
      if len+dblen > 29900 then pd("Databank too full to save more data")
      else
       Data:setData(id,data2Save)
      end

      --Custom Widget Saving
      for i, cWidget in ipairs(customWidgets) do
       if type(cWidget.saveData) == 'function' and P["Widget_Custom"..i].w_open == true then
        local _ = processPcall(pcall(function() return cWidget:saveData() end))
       end
      end

     end
    end

    local function deep_copy(original)
     local copy = {}
     for key, value in pairs(original) do
      if type(value) == "table" then
       copy[key] = deep_copy(value)
      else
       copy[key] = value
      end
     end
     return copy
    end

    function loadParamsFromDB()
     dP = deep_copy(P)
     dC = deep_copy(colorPresets)
     local SP = system.print
     local PE = function(t) SP(t.." data corrupted: using default parameter") end
     if #DB ~= 0 then
      SP("Initiating Databank loading")
      local userId, userName, masterUser = Data:currentUser()
      local d2L = Data:getData(tostring(userId))

      local nU = false --new User using master profile
      if not d2L and masterDataID == true then
       nU = true 
       d2L = Data:getData(tostring(masterUser))
      end

      if d2L and type(d2L) == "table" then
       SP("Loading parameters from Databank")
       P.AP_destination.value = d2L["APD"] or {0,0,0}
       P.AP_lockedDestination = d2L["APLD"] or nil
       if nU == false then
        val = d2L["MBP"]
        if type(val) == "table" then
         P.w_pos = vec2(val)
        end
        val = d2L["QMP"]
        if type(val) == "table" then
         P.QuickToolBar.w_pos = vec2(val)
        end
        val = d2L["QMS"]
        if type(val) == "number" then
         P.QuickToolBar.w_scale = val
        end
        val = d2L["MBO"]
        if type(val) == "boolean" then
         P.w_open = val
        end
        val = d2L["CP"]
        if type(val) == "table" then
         for i, v in pairs(val) do
          for k, l in pairs(v) do
           if val[i][k] then
            colorPresets[i][k] = l
           end
          end
         end
        end
        val = d2L["HMP"]
        if type(val) == "table" then
         P.help_menu.w_pos = vec2(val)
        end
        val = d2L["HMO"]
        if type(val) == "boolean" then
         P.help_menu.w_open = val
        end
        val = d2L["HMS"]
        if type(val) == "number" then
         P.help_menu.w_scale = val
        end
       end
       for i, v in ipairs(P) do
        if P[v].w_pos ~= nil then
         if type(d2L[tostring(v).."_w_p"]) == "table" and nU == false then
          P[v].w_pos = vec2(d2L[tostring(v).."_w_p"])
         end
         if type(d2L[tostring(v).."_w_o"]) == "boolean" and nU == false then
          P[v].w_open = d2L[tostring(v).."_w_o"]
         end
        end
        for k, l in ipairs(P[v]) do
         if P[v][l] then
          if P[v][l].value ~= nil then
           if type(P[v][l].value) ~= "function" then
            val = d2L[tostring(v)..tostring(l).."_v"]
            if type(val) == type(P[v][l].value) then
             if type(val) == "number" and val >= P[v][l].range[1] and val <= P[v][l].range[2] or type(val) ~= "number" then
              P[v][l].value = val
             end
            end
           end
           val = d2L[tostring(v)..tostring(l).."_q"]
           if type(val) == "boolean" then
            P[v][l].q = val
           end
          end
         end
        end
       end
       for i, v in pairs(P) do
        if string.sub(tostring(i),1,7) == "Widget_" then
         val = d2L[tostring(i).."_w_p"]
         if type(val) == "table" and nU == false then
          P[i].w_pos = vec2(val)
         end
         val = d2L[tostring(i).."_w_o"]
         if type(val) == "boolean" then
          P[i].w_open = val
         end
         val = d2L[tostring(i).."_w_s"]
         if type(val) == "number" and nU == false then
          P[i].w_scale = val
         end
        end
       end
       val = d2L["CT"]
       if type(val) == "number" then
        Nav:setThrottleValue(val)
       end
       val = d2L["E"]
       if type(val) == "boolean" then
        Engines = val
       end
       val = nil
       d2L = nil
       SP(userName.."'s data loaded successful.")

      else SP("No data found for player: "..userName.."! Loading default paramters")
      end
     end
    end
  onStart:
   lua: |
    -- Widgets --
    local utils = require("cpml/utils")
    local abs, floor, format, sub, acos, sqrt, cos, sin, deg, ceil, clamp ,sign= math.abs, math.floor, string.format, string.sub, math.acos, math.sqrt, math.cos, math.sin, math.deg, math.ceil, utils.clamp, utils.sign
    local widget_font = "Play"

    WidgetsPlusPlus = {}
    WidgetsPlusPlus.__index = WidgetsPlusPlus

    function WidgetsPlusPlus.new()
     local self = setmetatable({}, WidgetsPlusPlus)
     self.width = system.getScreenWidth()
     self.height = system.getScreenHeight()
     -- HUD Setup -- 
     self.hudSVGSize = {x=1600,y=1000}
     local scale = 1
     P.Widget_HUD = {
      w_title = "HUD",
      w_pos = {x=self.width/2 -(self.hudSVGSize.x*scale)/2, y=self.height/2 -(self.hudSVGSize.y*scale)/2},
      w_size = self.hudSVGSize,
      w_open = true,
      w_scale = scale
     }
     -- Platform HUD Setup -- 
     self.platSVGSize = {x=204,y=104}
     scale = 2
     P.Widget_Platform = {
      w_title = "Platform",
      w_pos = {x=self.width/2 -(self.platSVGSize.x*scale)/2, y=self.height*0.9 -(self.platSVGSize.y*scale)},
      w_size = self.platSVGSize,
      w_open = false,
      w_scale = scale
     }
     return self
    end

    local function toSu(v)
     return v == nil and 0 or v <= 10000 and format("%.0fm",v) or v > 50000 and format("%.2fsu",v/200000) or v > 10000 and format("%.1fkm",v/1000) or 0
    end
    local function altF(v)
     alt = alt == nil and 0 or alt
     return alt < 200000 and toSu(v) or "space"
    end

    -- HUD Widget --
    local SVGfuelText = {}
    local SVGfuelTextBool = {}
    local fuelCounter = 1

    function WidgetsPlusPlus.HUD_Update(self)
     local WFC = P.MS.WFC.value
     local WTC = P.MS.wTC.value
     local WAC = P.MS.wAC.value
     local WCA = P.MS.WCA.value
     local WC = P.MS.WC.value
     local SVGfinal = {}
     local si = 1
     local ds = 'style="filter: drop-shadow(1px 1px 0px black) drop-shadow(0px 0px 3px black);"'
     local SVG1 = '<div><svg viewBox="0 0 '.. self.hudSVGSize.x ..' '.. self.hudSVGSize.y ..'" '..ds..'>'
     local temp1 = 'font-family="'..widget_font..'" alignment-baseline="middle" stroke-width="0" fill="'..WTC..'"'

     local st = 'width="120" height="40" stroke="none" fill="'..WC..'" fill-opacity="'..WCA..'"'
     local p0 = '<rect x="215" y="480" '..st..'/><rect x="1265" y="480" '..st..'/>'

     local b1, b2, b3 = 'stroke:', ';stroke-dasharray: 4, 4; stroke-dashoffset: ', 'px;'
     local p1 = '<g fill="none" style="'
     local p2 = [[;">
      <polyline points="215,480 335,480 335,520 215,520 215,480 "/>
      <polyline points="1265,480 1385,480 1385,520 1265,520 1265,480 "/>
     </g>]]
     local SVG2 = p0..p1..'stroke:'..WFC..';'..p2
     if Engines == false then
      SVG2 = p0..p1..b1..'red'..b2.. 2 ..b3..p2..p1..b1..'black'..b2.. 6 ..b3..p2
     elseif brakeInput == 1 then
      SVG2 = p0..p1..b1..'red'..b2.. 2 ..b3..p2
     end

     --SVG ALTITUDE
     local SVG3 = '<text x="275" y="500" font-size="20" text-anchor="middle" '..temp1..'>'..altF(alt)..'</text>'

     --SVG BANK
     local b10,b11 = '<use xlink:href="','" transform="rotate('
     local b20,b21 = b10.."#bankthick"..b11, b10.."#bankthin"..b11
     local SVG4 = format([[
     <clipPath id="clipbankcircle400">
         <rect x="0" y="300" width="1600" height="400"/>
     </clipPath>
     <circle cx="800" cy="500" r="400" stroke-width="5" stroke="%s" fill="none" clip-path="url(#clipbankcircle400)" transform="rotate(%.1f 800 500)"/>
     <polygon id="triangle400" points="400 500, 402 505, 412 500, 402 495" stroke-width="0" fill="%s" transform="rotate(%.1f 800 500)"/>
     <use xlink:href="#triangle400" transform="rotate(180 800 500)"/>
     <line id="bankthick" x1="800" y1="97.5" x2="800" y2="102.5" stroke-width="5" stroke="%s"/>
     %s10 800 500)"/>
     %s20 800 500)"/>
     %s30 800 500)"/>
     %s-10 800 500)"/>
     %s-20 800 500)"/>
     %s-30 800 500)"/>
     <polygon id="banktriangle" points="800 97.5, 807 87.5, 793 87.5" stroke-width="0" fill="%s" transform="rotate(%s 800 500)"/>
     <use xlink:href="#banktriangle" transform="rotate(180 800 500)"/>
     <line id="bankthin" x1="800" y1="100" x2="800" y2="102.5" stroke-width="1" stroke="%s"/>
     %s2.5 800 500)"/>
     %s5 800 500)"/>
     %s7.5 800 500)"/>
     %s12.5 800 500)"/>
     %s15 800 500)"/>
     %s17.5 800 500)"/>
     %s22.5 800 500)"/>
     %s25 800 500)"/>
     %s27.5 800 500)"/>
     %s-2.5 800 500)"/>
     %s-5 800 500)"/>
     %s-7.5 800 500)"/>
     %s-12.5 800 500)"/>
     %s-15 800 500)"/>
     %s-17.5 800 500)"/>
     %s-22.5 800 500)"/>
     %s-25 800 500)"/>
     %s-27.5 800 500)"/>
     <text x="800" y="70" font-size="12" transform="rotate(%.1f 800 500)" text-anchor="middle"%s>%.1f°</text>]],
     WFC, Ay0, WFC, Ay0, WFC, b20, b20, b20, b20, b20, b20, WFC, Ay0, WFC, b21, b21, b21, b21, b21, b21, b21, b21, b21, b21, b21, b21, b21, b21, b21, b21, b21, b21, Ay0, temp1, Ay0)

     --SVG SPEEDO
     local throttleText = 0
     if MM == "TRAVEL" then 
      throttleText = format("%.0f %%", clamp(ThrottlePos,-100,100)*100)
     else 
      throttleText = format("%.0f km/h", clamp(ThrottlePos,-unitData.maxSpeedkph,unitData.maxSpeedkph))
     end
     local xyzSpeedText = format("%.0f  km/h", xyzSpeedKPH)
     if xyzSpeedKPH > unitData.maxSpeedkph then xyzSpeedText = "FTL" end
     local throttleClipY = 0
     local tPos = 0
     if MM == "TRAVEL" then
      tPos = clamp(ThrottlePos,-1,1)
      throttleClipY = 700 - 400 * floor(abs(tPos)*100)/100
     else tPos = clamp(ThrottlePos,-unitData.maxSpeedkph,unitData.maxSpeedkph)
      throttleClipY = 700 - 400 * abs(tPos)/unitData.maxSpeedkph
     end
     local currentThrust = 0
     if inspace == 0 then currentThrust = unitData.atmoThrust
     else currentThrust = unitData.spaceThrust
     end
     local forwardEnginesForce = Nav:maxForceForward()

     local fBD, bBD = brakingCalculation()
     fBD = toSu(fBD)

     local fM,gnd = "",""
     if parkingEligible() then
      local fMMs, fPMs = "",""
      if pkM then 
       fMMs = 'class="strike"'
       fPMs = 'class="bold"'
       gnd = format(" %.0fm", Gnd.height)
      else
       fMMs = 'class="bold"'
       fPMs = 'class="strike"'
      end
      fM = [[<text x="1400" y="690" font-size="20" ]]..fMMs..[[ text-anchor="start"]]..temp1..'>'..P.KP.flM.value..[[</text>
      <text x="1420" y="710" font-size="14" ]]..fPMs..[[ text-anchor="start"]]..temp1..'>'..P.KP.pkM.value..gnd..[[</text>]]
     else
      fM = [[<text x="1400" y="700" font-size="20" text-anchor="start"]]..temp1..'>'..MM..[[</text>]]
     end

     local altLock = ""
     if HoldAltitude then 
      altLock = [[<text x="1325" y="550" font-size="12" text-anchor="middle" font-family="]]..widget_font..[[" alignment-baseline="middle" stroke-width="0" fill="red">Alt locked: ]]..HoldAltitude..[[</text>]]
     end

     local brakeClipY = 200 * unitData.currentBrake/unitData.maxBrake
     local accelClipY = 500 - 200 * currentThrust/forwardEnginesForce
     local circ = '<circle cx="800" cy="500" r="610" stroke-width="20" stroke="'..WAC..'" fill="none" stroke-opacity="'..WCA..'" clip-path="url('
     local SVG5 = format([[
     <clipPath id="clipthrottle">
         <rect x="800" y="%.0f" width="800" height="%.1f" />
     </clipPath>
     <clipPath id="clipbrake">
         <rect x="0" y="500" width="800" height="%.1f" />
     </clipPath>
     <clipPath id="clipaccel">
         <rect x="0" y="%.0f" width="800" height="%.1f" />
     </clipPath>
     <text x="1325" y="500" font-size="20" text-anchor="middle"%s>%s</text>
     <text x="1425" y="500" font-size="15" text-anchor="start"%s>%s</text>
     %s
     <text x="170" y="500" font-size="15" text-anchor="end"%s>%.0f km/h</text>
     %s
     <text x="1395" y="300" font-size="15" text-anchor="start"%s>%s</text>
     %s#clipthrottle)"/>
     %s#clipbrake)"/>
     <text x="205" y="700" font-size="12" text-anchor="end"%s>%.0f / %.0f kn</text>
     %s#clipaccel)"/>
     <text x="205" y="300" font-size="12" text-anchor="end"%s>%.0f / %.0f kn</text>]],
     throttleClipY, 700 - throttleClipY,
     brakeClipY,
     accelClipY, 500 - accelClipY,
     temp1, xyzSpeedText,
     temp1, throttleText,
     altLock,
     temp1, abs(planetVertSpeedMPS) * sign(planetVertSpeedMPS),
     fM,
     temp1,fBD,
     circ, 
     circ,
     temp1, unitData.currentBrake/1000, unitData.maxBrake/1000,
     circ,
     temp1, currentThrust/1000, forwardEnginesForce/1000)

     --SVG FIXED
     local SVG6 = [[
     <clipPath id="clipcircle400"><rect x="0" y="300" width="1600" height="400" /></clipPath>
     <circle cx="800" cy="500" r="600" stroke-width="2" stroke="]]..WFC..[[" fill="none" clip-path="url(#clipcircle400)"/>
     <line id="bar1600" x1="235" y1="300" x2="214" y2= "300" stroke-width="2" stroke="]]..WFC..[["/>
     <use xlink:href="#bar1600" transform="rotate(180 800 500)"/>
     <line id="bar2600" x1="235" y1="700" x2="214" y2= "700" stroke-width="2" stroke="]]..WFC..[["/>
     <use xlink:href="#bar2600" transform="rotate(180 800 500)"/>
     <line x1="200" y1="500" x2="180" y2= "500" stroke-width="2" stroke="]]..WFC..[["/>
     <polygon id="triangle600" points="200 500, 201 505, 212 500, 201 495" stroke-width="0" fill="]]..WFC..[["/>
     <use xlink:href="#triangle600" transform="rotate(180 800 500)"/>
     <line x1="770" y1="500" x2="790" y2= "500" stroke-width="2" stroke="]]..WFC..[["/>
     <line x1="810" y1="500" x2="830" y2= "500" stroke-width="2" stroke="]]..WFC..[["/>
     <line x1="800" y1="470" x2="800" y2= "490" stroke-width="2" stroke="]]..WFC..[["/>
     <line x1="800" y1="510" x2="800" y2= "530" stroke-width="2" stroke="]]..WFC..[["/>
     <polygon points="800 897.5, 807 887.5, 793 887.5" stroke-width="0" fill="]]..WFC..[["/>
     <text x="800" y="550" font-size="25" text-anchor="middle" fill="red" font-family="]]..widget_font..[[">]]..fpsWarning..[[</text>
     ]]

     --SVG PITCHBAR
     local AHT = sign(Ax0) * abs(Ax0) / 90 * 400
     local SVGpitchbars = ""
     local i = 1
     local j = 800/18
     local svg7 = {}
     local pi = 0
     if alt < P.AS.stA.value then
      local temp2 = '" font-size="12" text-anchor="middle" alignment-baseline="middle" stroke-width="0" >'
      while (i<19) do
       if i*10 < Ax0 + 50 then
        pi = pi+1
        svg7[pi] = format([[
        <line x1="0" y1="%.0f" x2="450" y2="%0.1f" stroke-width="%0.1f" fill="none"/>
        <text x="465" y="%.0f">%d</text>
        <line x1="1600" y1="%.0f" x2="1150" y2="%0.1f" stroke-width="%0.1f" fill="none"/>
        <text x="1135" y="%0.1f">%d</text>]],
        500 - i*j, 500 - i*j, 2*(1-i/19), 500 - i*j, i*10, 500 - i*j, 500 - i*j, 2*(1-i/19), 500 - i*j, i*10)
       end
       if i*-10 > Ax0 - 50 then
        pi = pi+1
        svg7[pi] = format([[
        <line x1="1600" y1="%.0f" x2="1150" y2="%0.1f" stroke-width="%0.1f" fill="none"/>
        <text x="1135" y="%.0f">%d</text>
        <line x1="0" y1="%.0f" x2="450" y2="%0.1f" stroke-width="%0.1f" fill="none"/>
        <text x="465" y="%0.1f">%d</text>]],
        500 + i*j, 500 + i*j, 2*(1-i/19), 500 + i*j, i*-10, 500 + i*j, 500 + i*j, 2*(1-i/19), 500 + i*j, i*-10)
       end
       i = i+1
      end
        pi = pi+1
        svg7[pi] = [[
      <line x1="0" y1="500" x2="450" y2= "500" stroke-width="3" fill="none"/>
      <text x="465" y="500]]..temp2..[[0</text>
      <line x1="1600" y1="500" x2="1150" y2= "500" stroke-width="3" fill="none"/>
      <text x="1135" y="500]]..temp2..[[0</text>
      <line x1="480" y1="500" x2="700" y2= "500" stroke-width="2" />
      <line x1="1120" y1="500" x2="900" y2= "500" stroke-width="2" />]]
     end
     local SVG7 = format([[
     <clipPath id="clippitchcircle400">
         <circle cx="800" cy="500" r="400"/>
     </clipPath>
     <g clip-path="url(#clippitchcircle400)" stroke="%s" font-family="%s" fill="%s" stroke-opacity="%0.2f" fill-opacity="%0.1f">
         <g transform="rotate(%0.1f 800 500) translate(0 %0.1f)">
             %s
         </g>
     </g>
     <text x="380" y="500" font-size="12" transform="rotate(%0.1f 800 500)" text-anchor="middle"%s>%.0f°</text>]],
     WFC, widget_font, WFC, 0.25, 0.5, Ay0, AHT, table.concat(svg7) , Ay0, temp1, abs(Ax0) * utils.sign(Ax0))

     --SVG VELO
     local cAV = construct.getAbsoluteVelocity()
     local cAVx, cAVy, cAVz = norm(xSpeedKPH * 0.27777777777, ySpeedKPH * 0.27777777777, zSpeedKPH * 0.27777777777)
     local velStrokeColor = WFC
     if xyzSpeedKPH < 5 then cAVx, cAVy, cAVz = 0,0,0 else if abs(Ax) > 45 or abs(Az) > 45 then velStrokeColor = "red" end end
     local SVG8 = format([[
     <circle cx="%0.1f" cy="%0.1f" r="10" stroke-width="1.5" stroke="%s" fill="none"/>
     <line x1="800" y1="500" x2="%0.1f" y2="%0.1f" stroke-width="1" fill="none" stroke="%s"/>]],
     800+cAVx*400, 500+cAVz*-400, velStrokeColor, 800+cAVx*400, 500+cAVz*-400, velStrokeColor)

     --SVG FUEL
     local left, right = 0,0
     local SVG9 = {}
     local fi = 0
     for i , v in ipairs(fuelTanksData) do
      local fuelT = tonumber(fuelTanksData[i].timeLeft)
      local fuelTLeft = fuelT==nil and "N/A" or fuelT>1000000 and "inf" or format("%.0f min", fuelT/60) or "N/A"
      local fuelPLeft = format("%.0f %%", fuelTanksData[i].percentage)
      SVGfuelText[i] = fuelTLeft .. " ( ".. fuelPLeft .." )"
      local p6 = '" font-family="'..widget_font..'" alignment-baseline="middle" stroke-width="0" fill="'..WFC..'" >'..string.sub(fuelTanksData[i].name,1,7):upper()..'</text>'
      local p7 = format(' width="%0.1f" height="15" stroke-width="1" fill="%s" stroke="none" fill-opacity="%0.2f"/>',
      150 * tonumber(fuelTanksData[i].percentage) / 100, WAC, WCA)
      local p8 = '" width="150" height="15" stroke-width="1" stroke="'..WFC..'" fill="none" />'
      local p9 = '" font-size="12" text-anchor="middle"'..temp1..'>'..SVGfuelText[i]..'</text>'
      if string.sub(fuelTanksData[i].name, -1, -1) ~= "L" then
       fi=fi+1
       SVG9[fi] = format([[
       <text x="1350" y="%.0f" font-size="12" text-anchor="end"%s
       <rect x="1360" y="%.0f"%s
       <rect x="1360" y="%.0f"%s
       <text x="1445" y="%.0f"%s]],
       740 + (i - 1 - left) * 20, p6,
       732 + (i - 1 - left) * 20, p7,
       732 + (i - 1 - left) * 20, p8,
       740 + (i - 1 - left) * 20, p9)
       right = right + 1
      else
       fi=fi+1
       SVG9[fi] = format([[
       <text x="245" y="%.0f" font-size="12" text-anchor="start"%s
       <rect x="90" y="%.0f"%s
       <rect x="90" y="%.0f"%s
       <text x="175" y="%.0f"%s]],
       740 + (i - 1 - right) * 20,
       p6, 732 + (i - 1 - right) * 20,
       p7, 732 + (i - 1 - right) * 20,
       p8, 740 + (i - 1 - right) * 20,
       p9)
       left = left + 1
      end
     end
     return SVG1..SVG2..SVG3..SVG4..SVG5..SVG6..SVG7..SVG8..table.concat(SVG9)..'</svg></div>'
    end

    -- Platform Widget --
    function WidgetsPlusPlus.Platform_Update(self)
     local wTC = P.MS.wTC.value
     local wAC = P.MS.wAC.value
     local WCA = P.MS.WCA.value
     local WFC = P.MS.WFC.value
     local fSW = 1.5
     local op = 0.95
 
     local SVGfuel = {}
     for i , v in ipairs(fuelTanksData) do
      if i > 4 then break end --no more than 4 fuel tanks displayed
      local fuelT = tonumber(fuelTanksData[i].timeLeft)
      local fuelTLeft = fuelT==nil and "N/A" or fuelT>1000000 and "inf" or format("%.0f min", fuelT/60) or "N/A"
      local fuelPLeft = format("%.0f%%", fuelTanksData[i].percentage)
      SVGfuelText[i] =  fuelTLeft .. " ( ".. fuelPLeft .." )"
      SVGfuel[i] = [[
      <rect x="125" y="]].. 85+(i-1)*-12 ..[[" width="]].. 69*tonumber(fuelTanksData[i].percentage)/100 ..[[" height="9" stroke-width="1" fill="]]..wAC..[[" stroke="none" fill-opacity="]].. 0.25 ..[["/>
      <rect x="125" y="]].. 85+(i-1)*-12 ..[[" width="69" height="9" stroke-width="]]..fSW..[[" stroke="]]..WFC..[[" fill="none" />
      <text x="160" y="]].. 90+(i-1)*-12 ..[[" font-size="6" text-anchor="middle" font-family="]]..widget_font..[[" alignment-baseline="middle" stroke-width="0" fill="]]..wTC..[[" >]]..SVGfuelText[i]..[[</text>
      ]]
     end
     SVGfuel = table.concat(SVGfuel)
     --glass frame brackground
     local SVG_glassframe = [[
      <defs>
       <linearGradient id="grad1" x1="0" y1="0" x2="0.5" y2="0.75">
       <stop offset="0.8" style="stop-color:grey;stop-opacity:0.15" />
       <stop offset="1.2" style="stop-color:white;stop-opacity:0.1" />
       </linearGradient>
       <linearGradient id="grad2" x1="0" y1="0" x2="1" y2="1">
       <stop offset="0.1" style="stop-color:white  ;stop-opacity:0.75" />
       <stop offset="0.9" style="stop-color:grey;stop-opacity:0.5" />
       </linearGradient>
      </defs>
      <rect x="2" y="2" rx="8" ry="8" width="200" height="100" fill="url(#grad1)" stroke="none" fill-opacity="0.15" />
      <rect x="2" y="2" rx="8" ry="8" width="200" height="100" fill="none" stroke="url(#grad2)" stroke-width="2" stroke-opacity="0.5"/>
      <text x="100" y="50" font-size="10" text-anchor="middle" fill="red" font-family="]]..widget_font..[[">]]..fpsWarning..[[</text>
     ]]
 
     --vertical velocity bar --https://www.desmos.com/calculator/2qpxp2huaa
     local scale1 = 42 / math.log(maxSafeVel)
     local zVY = alt < 200000 and clamp(math.log(abs(planetVertSpeedMPS)+1)*scale1,0,42)*-sign(planetVertSpeedMPS) or 0
     local SVG_Zvel_fix = [[
      <rect x="10" y="10" width="15" height="84" style=" fill:none;stroke:]]..WFC..[[;stroke-width:]]..fSW..[["/>
     ]]
     local SVG_Zvel_anim = format('<polyline points="10,52 10,%.1f 25,%.1f 25,52" style="fill:%s";stroke:"none" fill-opacity="%s"/>',52+zVY,52+zVY,wAC,WCA)

     
     local nwVx, nwVy, nwVz = norm(wVx, wVy, wVz) -- normalized world vector (negative grav.)
     local wLx, wLy, wLz = cross(nwVx, nwVy, nwVz, cWOFx, cWOFy, cWOFz) -- world left
     local wFx, wFy, wFz = norm(cross(-nwVx, -nwVy, -nwVz, wLx, wLy, wLz)) -- world forward (forward perpendicular to grav.)
     
     local nWVx, nWVy, nWVz = norm(cWAVx, cWAVy, cWAVz) --normalized velocity vector
     local wLVx, wLVy, wLVz = cross(nwVx, nwVy, nwVz, nWVx, nWVy, nWVz) -- Velocity World Left
     local wFVx, wFVy, wFVz = norm(cross(-nwVx, -nwVy, -nwVz, wLVx, wLVy, wLVz)) -- Velocity World forward (velocity perpendicular grav)
     
     local driftAngle = acos(dotVec(wFx, wFy, wFz, wFVx, wFVy, wFVz))*constants.rad2deg
     local cx, cy, cz = cross(wFx, wFy, wFz, wFVx, wFVy, wFVz)
     if dotVec(cx, cy, cz, nwVx, nwVy, nwVz) > 0 then driftAngle = -driftAngle end

     -- Lat speed
     local pLatVel = dotVec(cWAVx, cWAVy, cWAVz, wFVx, wFVy, wFVz)
     if pLatVel < 0.1 then pLatVel = 0; driftAngle = 0 end

     local scale = 38 / math.log(maxSafeVel)
     local xVx = pLatVel and clamp(math.log(abs(pLatVel)+1)*scale,0,38)*sign(pLatVel) or 0
     if xVx ~= xVx then xVx = 0 end

     rotation = rotation and rotation < 360 and rotation + 3 or 0
     local SVG_XYvel_anim = [[<g transform="translate(75 52)">
      <g style="stroke-linecap: round; stroke-linejoin: round; " transform="rotate(]].. driftAngle-90 ..[[) translate(0 0)" fill="none" stroke="]]..wAC..[[" stroke-width="1">
       <line x1="0" y1="0" x2="]]..xVx..[[" y2="0"/>
       <rect x="]]..xVx-3 ..[[" y="-3" width="6" height="6"/>
      </g>
     </g>
     ]]
          
     local brakeStyle = 'stroke:'..WFC..';'
     local b1, b2, b3 = 'stroke:', ';stroke-dasharray: 2, 3; stroke-dashoffset: ', 'px;'
     local p1 = [[<g fill="none" style="]]
     local p2 = [[; stroke-linecap: round; stroke-linejoin: round;" stroke-width="]]..fSW..[[">
      <polyline points="33,38 33,10 61,10"/>
      <polyline points="89,10 117,10 117,38"/>
      <polyline points="117,66 117,94 89,94"/>
      <polyline points="61,94 33,94 33,66"/>
      <rect x="70" y="47" width="10" height="10"/>
     </g>]]
     local SVG_XYvel_fix = p1..brakeStyle..p2
     if Engines == false then
      SVG_XYvel_fix = p1..b1..'red'..b2.. 1 ..b3..p2..p1..b1..'black'..b2.. 3.5 ..b3..p2
     elseif brakeInput == 1 then
      SVG_XYvel_fix = p1..b1..'red'..b2.. 1 ..b3..p2
     end

     --Throttle
     local throttleClip = 0
     local tPos = 0
     if MM == "TRAVEL" then
      tPos = clamp(ThrottlePos,-1,1)
      throttleClip = 125 + 69 * floor(abs(tPos)*100)/100
     else tPos = clamp(ThrottlePos,-unitData.maxSpeedkph,unitData.maxSpeedkph)
      throttleClip = 125 + 69 * abs(tPos)/unitData.maxSpeedkph
     end
     local negThr = ThrottlePos >= 0 and 0 or 1
     local SVG_Throttle = '<polyline points="125,40 '..throttleClip..',40" style="stroke-linecap: butt; stroke-dasharray: 4, '..negThr..'; fill: none; stroke: red; stroke-opacity: 0.31; stroke-width: 4px;"/>'

     --animated text
     local parentName = unitData.parentingInfo.parentName

     local docking = ""
     if parentName ~= "" then
      if string.len(parentName) > 16 then parentName = string.sub(parentName,1,15) .. "..." end
      docking = [[
       <text x="37" y="83" >DOCKED:</text>
       <text x="37" y="90" >]]..parentName..[[</text>
      ]]
     end

     local xyzSpeedText = format("%.0f", xyzSpeedKPH)
     if xyzSpeedKPH > unitData.maxSpeedkph then xyzSpeedText = "FTL" end
     local gndH = Gnd.height > 0 and floor(round(Gnd.height)).."m" or " N/A"
     local SVG_text_anim = [[<g text-anchor="end" font-family="]]..widget_font..[[" alignment-baseline="bottom" stroke-width="0" fill="]]..wAC..[[">
      <text x="170" y="25" font-size="21">]]..xyzSpeedText..[[</text>
      <text x="195" y="17.5" font-size="10">km/h</text>
     </g>
     <g font-size="7" text-anchor="start" font-family="]]..widget_font..[[" alignment-baseline="bottom" stroke-width="0" fill="]]..wAC..[[">
      <text x="125" y="35" >alt:]]..altF(alt)..[[</text>
      <text x="169" y="35" >tel:]]..gndH..[[</text>
      ]]..docking..[[
     </g>]]

     return '<div><svg viewBox="0 0 '.. self.platSVGSize.x ..' '.. self.platSVGSize.y ..'" style="position:absolute; filter: drop-shadow(2px 2px 3px black);">'..SVGfuel..SVG_Zvel_fix..SVG_XYvel_fix..SVG_XYvel_anim..SVG_Throttle..SVG_text_anim..SVG_glassframe..SVG_Zvel_anim..'</svg></div>'
    end
  onStart:
   lua: |
    --minified winlib--.lua
    WLP = {}
    WLP.__index = WLP
    local DWN_Position_X = 0
    local DWN_Position_Y = 0
    local DWN_Width = 300
    local DWN_Height = 150
    local DWN_TitleBar_Height = 25
    local DBu_Position_X = 0
    local DBu_Position_Y = 0
    local DBu_Width = 96
    local DBu_Height = 24
    
    
    WLP.css = {}
    WLP.buttonsNew = {}
    
    function WLP.init()
     local self = setmetatable({}, WLP)
     self.index = 0
     self.windows = {}
     self.buttonLock = nil
     self.wlib_drag = false
     self.CLICK = false
     self.mouseWheel = 0
     self.previousGenerated = ""
     return self
    end
    
    function WLP.winlibCSSUpdate(self)
     local WC = P.MS.WC.value
     local WCA = P.MS.WCA.value
     local WTC = P.MS.WTC.value
     local TCA = P.MS.TCA.value
     local TTC = P.MS.TTC.value
     local BCA = P.MS.BCA.value
     local BTC = P.MS.BTC.value
     local wTC = P.MS.wTC.value
     local wAC = P.MS.wAC.value
     local titleR, titleG, titleB = webColors.namedColor2RGB(P.MS.TC.value)
     local titleRGB = tostring(titleR)..","..tostring(titleG)..","..tostring(titleB)
     local windowR, windowG, windowB = webColors.namedColor2RGB(WC)
     local windowRGB = tostring(windowR)..","..tostring(windowG)..","..tostring(windowB)
     local buttonR, buttonG, buttonB = webColors.namedColor2RGB(P.MS.BC.value)
     local buttonRGB = tostring(buttonR)..","..tostring(buttonG)..","..tostring(buttonB)
     local buttonborderR, buttonborderG, buttonborderB = webColors.namedColor2RGB(P.MS.BBC.value)
     local buttonborderRGB = tostring(buttonborderR)..","..tostring(buttonborderG)..","..tostring(buttonborderB)
    
     self.css.base = [[
      BODY {
       background:rgba(0, 0, 0, 0);
       color:#000000;
       width:100vw;
       height:100vh;
      }
      DIV.WinLib_window {
       position:absolute;
       background:rgba(]]..windowRGB..[[, ]]..WCA..[[);
       color:]]..WTC..[[;
       box-shadow:0px 1px rgba(128, 128, 128, 0.5);
       text-align:middle;
       fill:]]..WTC..[[;
      }
      DIV.WinLib_w_title {
       height:20px;
       background-color: rgba(]]..titleRGB..[[, ]]..TCA..[[);
       background-image: white;
       color:]]..TTC..[[;
       text-align:center;
       vertical-align: middle;
       padding-left:4px;
       font-family:"Bank";
      }
      DIV.WinLib_window>.WinLib_content {
       padding:4px;
       color:]]..WTC..[[;
       fill:]]..WTC..[[;
      }
      DIV.WinLib_button {
       position:absolute;
       background: rgba(]]..buttonRGB..[[, ]]..BCA..[[);
       border:1px solid rgb(]]..buttonborderRGB..[[);
       font-family:"Play";
       text-align: center;
       vertical-align: middle;
       color:]]..BTC..[[;
       overflow:hidden;
       padding-top:5px;
      }
      .widgets {
       background:rgba(0, 0, 0, 0) !important;
       box-shadow:0px 0px rgba(0, 0, 0, 0) !important;
      }
      .widgetnopadding {
       padding: 0px !important;
       padding-top: 0px !important;
       padding-left: 0px !important;
      }
      .separator {
       background:rgba(0, 0, 0, 0) !important;
       border:0px solid rgba(0, 0, 0, 0) !important;
       font-size:0px !important;
       color:rgba(0, 0, 0, 0) !important;
       box-shadow:0px 0px rgba(0, 0, 0, 0) !important;
       border: 0px solid rgba(0, 0, 0, 0) !important;
      }
      .Help_Menu {
       font-family:"Play" !important;
       font-size:14px !important;
      }
      .buttonHover {
       position:absolute;
       border: 3px solid rgb(]]..buttonborderRGB..[[) !important;
       font-family:"Play" !important;]]..
       [[text-align: center !important;
       vertical-align: text-top !important;
       box-shadow:3px 2px rgba(50, 50, 50, 0.5) !important;
       color:]]..BTC..[[ !important;
       overflow:hidden !important;
       padding-top:2px !important;
      }
      .fixed {
       z-index:1 !important;
      }
      .strike {
       text-decoration:line-through underline;
       opacity: 0.3;
      }
      .bold {
       font-family:"Play" !important;
       font-weight:bold;
      }
      .help_container {
          border-radius: 8px;
          border-style: solid;
          border-width: 1px;
          border-color: black;
          background-color: lightGray;
          padding: 10px;
          color: black;
          transform: translate(15px, -125px);
       }
      ]]
    end

    WLP.css.w_block = [[
     #{wlib_id} {
      width:{wlib_width}px;
      height:{wlib_height}px;
      top:{wlib_posY}px;
      left:{wlib_posX}px;
      z-index:{wlib_zIndex};
     }
     #{wlib_id}>.WinLib_w_title {
      height:{wlib_title_height}px;
      line-height:{wlib_title_height}px;
     }
     {wlib_buttons_generated}]]
    WLP.css.button_block = [[
    
     #{wlib_id} {
      width:{wlib_width}px;
      height:{wlib_height}px;
      top:{wlib_posY}px;
      left:{wlib_posX}px;
     }]]
    WLP.css.generated_block = [[
     <style>
    {wlib_css_generated}
     </style>
    ]]
    
    -- WLP HTML
    WLP.html = {}
    WLP.html.base = [[
    <style type="text/css">
    {wlib_css}
    {wlib_css_generated}
    </style>
    {wlib_html_generated}
    ]]
    WLP.html.window = [[
     <style>
       .w_font_style{w_font_id} {
         font-size: {w_wlib_font}px;
       }
     </style>
    <DIV class="WinLib_window w_font_style{w_fs_id} {wlib_custom_class}" id="{wlib_id}">
    {wlib_title_bar}
     <DIV class="WinLib_content">
    {wlib_html}
    {wlib_buttons_generated}
     </DIV>
    </DIV>]]
    WLP.html.w_title = [[
     <style>
       .t_font_style{t_font_id} {
         font-size: {t_wlib_font}px !important;
       }
     </style>
     <DIV class="WinLib_w_title t_font_style{t_fs_id}" id="title_bar">
      {wlib_title}
     </DIV>]]
    WLP.html.button = [[
     <style>
       .font_style{font_id} {
         font-size: {wlib_font}px;
       }
     </style>
     <DIV class="WinLib_button font_style{fs_id} {wlib_custom_class}" id="{wlib_id}">
      {wlib_html}
     </DIV>]]

    local function gsubAlt(in_S, f_S, r_S) --gsub alternative for % characters (string, find, replace)
     local r, f_l, i_l, i = "", #f_S, #in_S, 1
     while i <= i_l do
      local c = in_S:sub(i, i + f_l - 1)
      if c == f_S then
       r = r .. r_S
       i = i + f_l
      else
       r = r .. in_S:sub(i, i)
       i = i + 1
      end
     end
     return r
    end

    function WLP.new(self,html,o,buttons)
     local wn = {} 
     wn.name = nil
     wn.title = nil
     wn.class = nil
     wn.posX = DWN_Position_X
     wn.posY = DWN_Position_Y
     wn.width = DWN_Width * P.MS.MSS.value
     wn.height = DWN_Height * P.MS.MSS.value
     wn.titleHeight = DWN_TitleBar_Height
     wn.draggable = false
     wn.alwaysOnTop = false
     wn.fixed = false
     wn.scalable = true
     wn.scale = 1
     if o ~= nil then
      if o.scalable == nil or o.scalable == false then wn.scalable = false else wn.scalable = true end
      if wn.scalable == true then
       if o.scale == nil then
        wn.scale = P.MS.MSS.value
       else
        wn.scale = o.scale
       end
      end
      wn.name = (o.name ~= nil) and o.name or wn.name
      wn.title = (o.title ~= nil) and o.title or wn.title
      wn.class = (o.class ~= nil) and o.class or wn.class
      wn.posX = o.posX ~= nil and (o.scalable == true and o.posX or o.posX) or wn.posX
      wn.posY = o.posY ~= nil and (o.scalable == true and o.posY or o.posY) or wn.posY
      wn.width =  o.width ~= nil and (o.scalable == true and o.width * wn.scale or o.width) or wn.width
      wn.height  = o.height ~= nil and (o.scalable == true and o.height * wn.scale or o.height) or wn.height
      wn.titleHeight = o.titleHeight ~= nil and (o.scalable == true and o.titleHeight * wn.scale or o.titleHeight) or wn.titleHeight* wn.scale
      if o.draggable == nil or o.draggable == true then wn.draggable = true else wn.draggable = false end
      if o.alwaysOnTop == nil or o.alwaysOnTop == false then wn.alwaysOnTop = false else wn.alwaysOnTop = true end
      if o.fixed == nil or o.fixed == false then wn.fixed = false else wn.fixed = true end
     end

     wn.buttons = (buttons == nil) and {} or buttons
     if #wn.buttons > 0 then
        for i, v in ipairs(wn.buttons) do
            wn.buttons[i].scale = wn.scale
        end
     end

     self.index = self.index + 1
     wn.id = "wlib_w_" .. self.index
     wn.html = (html == nil) and "" or html

     if wn.fixed == true then
      wn.zIndex = -100
     else
      wn.zIndex = (wn.alwaysOnTop == true) and 999999 + self.index or self.index
     end

     wn.css = ""
     wn.content = ""

     wn.refresh = function()
      local button_html = ""
      local button_css  = ""

      for i, button in pairs(wn.buttons) do
       button:refresh()
       button_html = button_html .. button.content
       button_css = button_css .. button.css
      end

      wn.css = self.css.w_block
       :gsub("{wlib_id}",wn.id)
       :gsub("{wlib_width}",wn.width)
       :gsub("{wlib_height}",wn.height)
       :gsub("{wlib_posX}",wn.posX)
       :gsub("{wlib_posY}",wn.posY)
       :gsub("{wlib_zIndex}",wn.zIndex)
       :gsub("{wlib_title_height}",wn.titleHeight)
       :gsub("{wlib_buttons_generated}",button_css)

      local t_html = wn.title ~= nil and wn.title:gsub("%%","{p}") or "" --％
      local title_bar = wn.title == nil and "" or self.html.w_title
       :gsub("{t_font_id}",wn.id)
       :gsub("{t_wlib_font}",P.MS.TFS.value*wn.scale)
       :gsub("{t_fs_id}",wn.id)
       :gsub("{wlib_title}",t_html)
      local custom_class = wn.class == nil and "" or wn.class
      local w_html = wn.html:gsub("%%","{p}")
      wn.content = self.html.window
       :gsub("{w_font_id}",wn.id)
       :gsub("{w_wlib_font}",P.MS.WFS.value*wn.scale)
       :gsub("{w_fs_id}",wn.id)
       :gsub("{wlib_id}",wn.id)
       :gsub("{wlib_custom_class}",custom_class)
       :gsub("{wlib_title_bar}",title_bar)
       :gsub("{wlib_html}",w_html)
       :gsub("{wlib_buttons_generated}",button_html)
     end

     wn.setHTML = function(content)
      wn.html = content
     end

     wn.setTitle = function(content)
      wn.title = content
     end

     wn.setPos = function(x,y)
      wn.posX = x
      wn.posY = y
     end

     wn.delete = function()
      self.windows[wn.id] = nil
     end

     self.windows[wn.id] = wn
     return wn
    end

    function WLP.toggleClick(self,bool)
     self.CLICK = bool
    end

    function WLP.cursorUpdate(self)
     local c_svg = [[
     <div><svg>
     <polygon points="0,0 25,22.5 10,20 5,32.5" 
     stroke="lightsteelblue" stroke-width="1.5" fill="white"/>
     </svg></div>]]
     if P.WS.HELP_MENU.value == "Hover" and self.help ~= nil then
      c_svg = c_svg .. [[<div class="help_container">]]
      if type(self.help) == "table" then
       for i,v in ipairs(self.help) do
        if type(v) == "table" then
         for ii,vv in ipairs(v) do
          local br = ii == #v and "<br><br>" or "<br>"
          c_svg = c_svg .. vv .. br
         end
        else
         local br = i ~= #self.help and "<br><br>" or ""
         c_svg = c_svg .. v .. br
        end
       end
      elseif type(self.help) == "string" then
       c_svg = c_svg .. self.help
      end
      c_svg = c_svg .. [[</div>]]
     end
     return c_svg
    end

    function WLP.update(self)
     self:mouseListener()
     for k, window in pairs(self.windows) do
      if (P.w_open == true or P.QuickToolBar.w_open == true) and window.name == "cursor" then
        local svg = self:cursorUpdate()
        if svg then window.setHTML(svg) else window.setHTML("") end
      elseif P.w_open == false then
       if P.Widget_HUD.w_open == true and window.name == P.Widget_HUD.w_title then
        local svg = widget:HUD_Update()
        if svg then window.setHTML(svg) else window.setHTML("") end
       end
       if P.Widget_Platform.w_open == true and window.name == P.Widget_Platform.w_title then
        local svg = widget:Platform_Update()
        if svg then window.setHTML(svg) else window.setHTML("") end
       end
       for i, v in ipairs(customWidgets) do
        if P["Widget_Custom"..i].w_open == true and window.name == P["Widget_Custom"..i].w_title then
         local svg = processPcall(pcall(function() return v:SVG_Update() end))
         if svg then
          window.setHTML(svg)
          if #v.buttons > 0 then
           for k2, v2 in pairs(window.buttons) do
            for k3, v3 in pairs(v.buttons) do
             if window.buttons[k2].name and v.buttons[k3][3].name and window.buttons[k2].name == v.buttons[k3][3].name then
              self.windows[k].buttons[k2].posX = v3[3].posX
              self.windows[k].buttons[k2].posY = v3[3].posY
              self.windows[k].buttons[k2].width = v3[3].width
              self.windows[k].buttons[k2].height = v3[3].height
              self.windows[k].buttons[k2].__click = v3[2]
              self.windows[k].buttons[k2].scale = self.windows[k].scale
              self.windows[k].buttons[k2]:refresh()
             end
            end
           end
          end
         else
          window.setHTML("")
         end
        end
       end
      end
     end
     local gen_css = ""
     local windows = ""
     for _, window in pairs(self.windows) do
      window:refresh()
      gen_css = gen_css .. window.css 
      windows = windows .. window.content
      if window.name == "cursor" then
       window.posX = cursorX
       window.posY = cursorY
      end
     end
     local generated = self.html.base
      :gsub("{wlib_css}",self.css.base)
      :gsub("{wlib_css_generated}",gen_css)
      :gsub("{wlib_html_generated}",windows)
      :gsub("{p}","%%")
     if self.previousGenerated ~= generated then
      system.setScreen(generated)
      if screen_1 then screen_1.setHTML(generated) end
     end
     self.previousGenerated = generated
    end

    function WLP.mouseListener(self)
     if P.w_open == true or P.QuickToolBar.w_open == true then
      local mouse = self:getMousePos()
      mouseWheel = system.getMouseWheel()
      if mouseWheel ~= 0 then self.CLICK = true end
      if self.grabbed == nil then 
       for _, window in pairs(self.windows) do
        if window.name ~= "cursor" then
         local bound = { x1 = window.posX, y1 = window.posY,
          x2 = (window.posX + window.width), y2 = window.posY + window.height }
         if(mouse.x >= bound.x1 and mouse.y >= bound.y1
           and mouse.x <= bound.x2 and mouse.y <= bound.y2) then
          if(self.grabbed == nil) then
           self.grabbed = window
          else
           if(window.zIndex > self.grabbed.zIndex) then
            self.grabbed = window
           end
          end
         end
        end
       end

       if(self.grabbed ~= nil) then
        self:buttonCheck()
        if self.grabbed.zIndex ~= self.index and self.CLICK ~= false then
         if(self.grabbed.alwaysOnTop ~= true) then
          self.index = self.index + 1
          self.grabbed.zIndex = self.index
         end
        end

        if(self.grabbed.title == nil) then
         self:beginDrag()
        elseif(mouse.y <= self.grabbed.posY + self.grabbed.titleHeight) then
         self:beginDrag()
        else
         self.grabbed = nil
        end
       end
      else
       self.buttonLock = nil
      end
      if mouseWheel ~= 0 then
       self.CLICK = false
      end
     end
    end

    function WLP.beginDrag(self)
      local mouse = self:getMousePos()
      self.grabbed.offset = {x = mouse.x - self.grabbed.posX,
           y = mouse.y - self.grabbed.posY}
     self.wlib_drag = true
    end

    function WLP.performDrag(self)
     if self.CLICK == true and mouseWheel == 0 and self.grabbed.draggable == true then
      local mouse = self:getMousePos()
      local new_x = tonumber(string.format("%.2f",mouse.x - self.grabbed.offset.x))
      local new_y = tonumber(string.format("%.2f",mouse.y - self.grabbed.offset.y))
      self.grabbed.posX = (self.grabbed.posX ~= new_x) and new_x or self.grabbed.posX
      self.grabbed.posY = (self.grabbed.posY ~= new_y) and new_y or self.grabbed.posY
      Save_Window_Pos(self.grabbed.name,self.grabbed.posX,self.grabbed.posY)
     elseif mouseWheel ~= 0 then
      for i, v in pairs(P) do
       if i and P[i] and P[i].w_scale and P[i].w_title and P[i].w_title == self.grabbed.name then
        P[i].w_scale = P[i].w_scale + 0.05 * mouseWheel
        pd(P[i].w_title.." widget scale: "..P[i].w_scale)
        self.CLICK = false
        windowsShow()
       end
      end
     else
      self:releaseWindow()
     end
    end

    function WLP.releaseWindow(self)
     self.grabbed = nil
     self.wlib_drag = false
    end

    function WLP.buttonCheck(self)
     for _, button in pairs(self.grabbed.buttons) do
      local mouse = self:getMousePos()
      local bs = button.scale
      mouse.x = mouse.x
      mouse.y = mouse.y
      local bound = { x1 = button.posX*bs + self.grabbed.posX,
          y1 = button.posY*bs + self.grabbed.posY,
          x2 = button.posX*bs + self.grabbed.posX + button.width*bs,
          y2 = button.posY*bs + self.grabbed.posY + button.height*bs }
      if(mouse.x >= bound.x1 and mouse.x <= bound.x2 and
        mouse.y >= bound.y1 and mouse.y <= bound.y2 and
        self.buttonLock ~= button) then
       for k1, window in pairs(self.windows) do
        for i1, wbutton in ipairs(window.buttons) do
         if button.id == wbutton.id and button.custom_class == "" then
          self.windows[k1].buttons[i1].class = "buttonHover"
          if self.windows[k1].name and self.windows[k1].buttons[i1] and self.windows[k1].buttons[i1].name and help[self.windows[k1].name] and help[self.windows[k1].name][self.windows[k1].buttons[i1].name] then
            self.help = help[self.windows[k1].name][self.windows[k1].buttons[i1].name]
          end
         end
        end
       end
       if self.CLICK == true then
        self.buttonLock = button
        button:__click()
        self.CLICK = false
       end
      else
       for k1, window in pairs(self.windows) do
        for i1, wbutton in ipairs(window.buttons) do
         if button.id == wbutton.id and button.custom_class == "buttonHover" then
          self.windows[k1].buttons[i1].class = ""
          self.help = nil
         end
        end
       end
      end
     end
    end

    function WLP.getMousePos(self)
      cursorX = system.getMousePosX()
      cursorY = system.getMousePosY()
     return {x = cursorX,y = cursorY}
    end
    
    function WLP.buttonsNew(self, html, onclick, o)
     local b = {}
     b.name = ""
     b.class = nil
     b.posX = DBu_Position_X
     b.posY = DBu_Position_Y
     b.width = DBu_Width
     b.height = DBu_Height
     b.scale = 1

     if(o ~= nil) then
      b.name = (o.name ~= nil) and o.name or b.name
      b.class = (o.class ~= nil) and o.class or b.class
      b.posX = (o.posX ~= nil) and o.posX or b.posX
      b.posY = (o.posY ~= nil) and o.posY or b.posY
      b.width = (o.width ~= nil) and o.width or b.width
      b.height  = (o.height ~= nil) and o.height or b.height
     end

     self.index = self.index + 1
     b.id = "wlib_bt_" .. self.index
     if b.name == "" then b.name = b.id end
     b.html = (html == nil) and "" or html

     b.css = ""
     b.previousCSS = ""
     b.previousContent = ""
     b.refresh = function()
      b.css = self.css.button_block
       :gsub("{wlib_id}",b.id)
       :gsub("{wlib_width}",b.width*b.scale)
       :gsub("{wlib_height}",b.height*b.scale)
       :gsub("{wlib_posX}",b.posX*b.scale)
       :gsub("{wlib_posY}",b.posY*b.scale)
      b.custom_class = b.class or ""
      local b_html = b.html:gsub("%%","{p}")
      b.content = self.html.button
       :gsub("{font_id}",b.id)
       :gsub("{wlib_font}",P.MS.BFS.value*b.scale)
       :gsub("{fs_id}",b.id)
       :gsub("{wlib_id}",b.id)
       :gsub("{wlib_custom_class}",b.custom_class)
       :gsub("{wlib_html}",b_html)
     end
     b.previousCSS = b.css
     b.previousContent = b.content

     b.__click = onclick

     b.setClick = function(clickMethod)
      b.__click = clickMethod
     end

     b.setHTML = function(content)
      b.html = content
     end

     b.setClass = function(content)
      b.class = content
     end
     return b
    end
  onStart:
   lua: |
    -- webcolors
    local function index(t,val)
     for i,v in ipairs(t) do
      if v == val then 
       return i
      end
     end
     return nil
    end
    webColors = {}
    webColors.namedColors = {"aliceblue","antiquewhite","aqua","aquamarine","azure","beige","bisque","black","blanchedalmond","blue","blueviolet","brown","burlywood","cadetblue","chartreuse","chocolate","coral","cornflowerblue","cornsilk","crimson","cyan","darkblue","darkcyan","darkgoldenrod","darkgray","darkgreen","darkgrey","darkkhaki","darkmagenta","darkolivegreen","darkorange","darkorchid","darkred","darksalmon","darkseagreen","darkslateblue","darkslategray","darkslategrey","darkturquoise","darkviolet","deeppink","deepskyblue","dimgray","dimgrey","dodgerblue","firebrick","floralwhite","forestgreen","fuchsia","gainsboro","ghostwhite","gold","goldenrod","gray","green","greenyellow","grey","honeydew","hotpink","indianred","indigo","ivory","khaki","lavender","lavenderblush","lawngreen","lemonchiffon","lightblue","lightcoral","lightcyan","lightgoldenrodyellow","lightgray","lightgreen","lightgrey","lightpink","lightsalmon","lightseagreen","lightskyblue","lightslategray","lightslategrey","lightsteelblue","lightyellow","lime","limegreen","linen","magenta","maroon","mediumaquamarine","mediumblue","mediumorchid","mediumpurple","mediumseagreen","mediumslateblue","mediumspringgreen","mediumturquoise","mediumvioletred","midnightblue","mintcream","mistyrose","moccasin","navajowhite","navy","oldlace","olive","olivedrab","orange","orangered","orchid","palegoldenrod","palegreen","paleturquoise","palevioletred","papayawhip","peachpuff","peru","pink","plum","powderblue","purple","red","rosybrown","royalblue","saddlebrown","salmon","sandybrown","seagreen","seashell","sienna","silver","skyblue","slateblue","slategray","slategrey","snow","springgreen","steelblue","teal","thistle","tomato","turquoise","violet","wheat","white","whitesmoke","yellow","yellowgreen"}
    webColors.RGBColors = {{240, 248, 255},{250, 235, 215},{ 0, 255, 255},{127, 255, 212},{240, 255, 255},{245, 245, 220},{255, 228, 196},{ 0, 0, 0},{255, 235, 205},{ 0, 0, 255},{138, 43, 226},{165, 42, 42},{222, 184, 135},{ 95, 158, 160},{127, 255, 0},{210, 105, 30},{255, 127, 80},{100, 149, 237},{255, 248, 220},{220, 20, 60},{ 0, 255, 255},{ 0, 0, 139},{ 0, 139, 139},{184, 134, 11},{169, 169, 169},{ 0, 100, 0},{169, 169, 169},{189, 183, 107},{139, 0, 139},{ 85, 107, 47},{255, 140, 0},{153, 50, 204},{139, 0, 0},{233, 150, 122},{143, 188, 143},{ 72, 61, 139},{ 47, 79, 79},{ 47, 79, 79},{ 0, 206, 209},{148, 0, 211},{255, 20, 147},{ 0, 191, 255},{105, 105, 105},{105, 105, 105},{ 30, 144, 255},{178, 34, 34},{255, 250, 240},{ 34, 139, 34},{255, 0, 255},{220, 220, 220},{248, 248, 255},{255, 215, 0},{218, 165, 32},{128, 128, 128},{128, 128, 128},{ 0, 128, 0},{173, 255, 47},{240, 255, 240},{255, 105, 180},{205, 92, 92},{ 75, 0, 130},{255, 255, 240},{240, 230, 140},{230, 230, 250},{255, 240, 245},{124, 252, 0},{255, 250, 205},{173, 216, 230},{240, 128, 128},{224, 255, 255},{250, 250, 210},{211, 211, 211},{144, 238, 144},{211, 211, 211},{255, 182, 193},{255, 160, 122},{ 32, 178, 170},{135, 206, 250},{119, 136, 153},{119, 136, 153},{176, 196, 222},{255, 255, 224},{ 0, 255, 0},{ 50, 205, 50},{250, 240, 230},{255, 0, 255},{128, 0, 0},{102, 205, 170},{ 0, 0, 205},{186, 85, 211},{147, 112, 219},{ 60, 179, 113},{123, 104, 238},{ 0, 250, 154},{ 72, 209, 204},{199, 21, 133},{ 25, 25, 112},{245, 255, 250},{255, 228, 225},{255, 228, 181},{255, 222, 173},{ 0, 0, 128},{253, 245, 230},{128, 128, 0},{107, 142, 35},{255, 165, 0},{255, 69, 0},{218, 112, 214},{238, 232, 170},{152, 251, 152},{175, 238, 238},{219, 112, 147},{255, 239, 213},{255, 218, 185},{205, 133, 63},{255, 192, 203},{221, 160, 221},{176, 224, 230},{128, 0, 128},{255, 0, 0},{188, 143, 143},{ 65, 105, 225},{139, 69, 19},{250, 128, 114},{244, 164, 96},{ 46, 139, 87},{255, 245, 238},{160, 82, 45},{192, 192, 192},{135, 206, 235},{106, 90, 205},{112, 128, 144},{112, 128, 144},{255, 250, 250},{ 0, 255, 127},{ 70, 130, 180},{ 0, 128, 128},{216, 191, 216},{255, 99, 71},{ 64, 224, 208},{238, 130, 238},{245, 222, 179},{255, 255, 255},{245, 245, 245},{255, 255, 0},{154, 205, 50}}
    function webColors.namedColor2RGB(name)
     if type(name) == "string" then
      local i = index(webColors.namedColors,name)
      return webColors.RGBColors[i][1],webColors.RGBColors[i][2],webColors.RGBColors[i][3]
     end
    end

  onStart:
   lua: |
    -- help menu
    help = {}
    local format = string.format
    local fs = 12 --font size
    help.ls = 15 --lineSpace
    local ls = help.ls
    help.h1 = '<tspan x="500" dy="'
    help.h2 = '</tspan>'
    local h1 = help.h1
    local h2 = help.h2
    local body = format([[
     <text x="500" y="30" font-size="%.0f" text-anchor="middle">
      <tspan x="500" font-size="%.0f">{tittle}%s
      {body}
      </text>]],
      fs,
      fs*2,h2)
    help.body = body

    help.info = {
     body = format([[
     <text x="500" y="30" font-size="%.0f" text-anchor="middle">
      <tspan x="500" font-size="%.0f">'INSTRUCTION MANUAL'%s

      %s%0f" style="font-weight: bold; " font-size="%0.1f">'Default -- Flight Script'%s
      %s%0f">'The touch screen revolutionary hud and flight script!'%s
      %s%0f">'By Jeronimo 2016-2024, minified by TheGreatSardini 2023'%s

      %s%0f">> "ALT + 1" to open and close Main menu.%s
      %s%0f">> "LEFT CLICK" as main CLICK.%s
      %s%0f">> "MOUSE WHEEL SCROLL" over button to change its VALUE.%s
      %s%0f">> "LEFT CLICK" on button to change its INCREMENT.'%s
      %s%0f">> "CTRL + LEFT CLICK" to save a button in the QUICK TOOL BAR%s
      %s%0f">(asterisk "*" confirms the shortcut is active).%s
      %s%0f">> "double tap + hold ALT" to access QUICK TOOL BAR.%s

      %s%0f">> All the DEFAULT -- windows and widgets are dragable%s
      %s%0f">either by their title or background.%s
      %s%0f">> And resizeable using mouse wheel%s

      %s%0f">> Discord: thegreatsardini%s
      %s%0f">> GitHub: https://github.com/TheGreatSardini/Default--%s

      %s%0f" style="font-weight: bold; " font-size="%0.1f">'ENJOY!'%s
     </text>]],
     fs,
     fs*2,h2,

     h1,ls*2,fs*1.8,h2,
     h1,ls,h2,
     h1,ls,h2,

     h1,ls*2,h2,
     h1,ls,h2,
     h1,ls,h2,
     h1,ls,h2,
     h1,ls,h2,
     h1,ls,h2,
     h1,ls,h2,

     h1,ls*2,h2,
     h1,ls,h2,
     h1,ls,h2,

     h1,ls*2,h2,
     h1,ls,h2,

     h1,ls*2,fs*1.5,h2)}

    help.MS = {
     TC = 'Title bar color',
     TCA = 'Title bar opacity',
     TTC = 'Title bar text color',
     TFS = 'Tittle bar font size',

     WC = 'Windows background color',
     WCA = 'Windows background opacity',
     WTC = 'Windows text color',
     WFS = 'Windows font size',

     BC = 'Buttons background color',
     BBC = 'Buttons border color',
     BCA = 'Buttons background opacity',
     BTC = 'Buttons text color',
     BFS = 'Buttons font size',

     wTC = 'Widgets background color',
     wAC = 'Widgets SVG color 1',
     WFC = 'Widgets SVG color 2',

     MSS = 'UI global scale factor',

     PRESET = 'Up to 5 presets that can be customized at will',
    }

    help.ES = {
     pSF = 'Pitch speed factor',
     ySF = 'Yaw speed factor',
     rSF = 'Roll speed factor',
     anD = 'Anti rotational drift factor',

     loF = 'Longitudinal engines power factor',
     laF = 'Lateral engines power factor',
     vtF = 'Vertical engines power factor',

     loB = 'Longitudinal brakes intensity factor',
     laB = 'Lateral brakes intensity factor',
     vtB = 'Vertical brakes intensity factor',
     spB = 'Space brakes intensity scaling factor',

     gyr = {{'CROSS: brake vector manipulation', 'Needs the gyro be positionned rolled left 90 degrees'},
      'SPACE_AUTO: Auto activates in space'},
     pAd = 'Construct default pitch tilting',
     rAd = 'Construct default roll tilting',

     hov = 'Hover engines toggle',
     hoM = {'DYNAMIC: Without constraints hover mode',
      'STATIC: Hover locked to set altitude',
      'AUTO: Constrained only under set altitude'},
     hoA = 'Hover default distance to obstacle(used by STATIC and AUTO modes)',
     hoS = 'Hover strength factor applied during altitude stabilisation',
     agA = 'Anti Gravity Generator hovering altitude(-1 = deactivated)',

     eng = 'Construct engines and adjusters toggle(long press C to shut off)',
     aMS = {{'Atmospheric safety max speed limiter'}, 
      '-2: Automatic speed calculation',
      '-1: Disable (no speed limiter)'},

     dCA = 'Default Drone mode cruise angle(in degrees)',
     dSA = 'Default Drone mode rocket angle(in degrees)',

     fpP = 'Low FPS flush security control(flush is paused under set fps)',
    }

    help.AS = {
     aBS = 'TRAVEL flight mode auto brake minimum speed',

     stA = 'Altitude max for all stabilisation assistances',
     auR = 'Flat roll stabilisation assistance',
     tuA = 'Automatic pitch and yaw when rolling',
     tAR = 'Flat roll stabilisation threshold angle(in degrees)',
     tAP = 'Max pitch allowed for TURN ASSIST',

     auP = 'Flat pitch stabilisation assistance',
     aPA = 'Flat pitch stabilisation threshold angle(in degrees)',
     atS = 'Auto altitude hold toggle',
     anS = 'Anti stall yaw security toggle',

     iAB = 'Inertia dampening anti drift toggle',
     lIF = 'Lateral drift angle(in degrees) to begin braking',
     vIF = 'Vertical drift angle(in degrees) to begin braking',
     sAD = 'Space drift angle(in degrees) to begin braking',
     iAI = 'Inertia dampening braking strengh',
     aPG = 'Auto pitch and yaw in space toward velocity vector',
     aOS = 'Auto speed adjustment for planets orbit',

     rMS = {'Speed limiter for rocket boosters in atmo(-1 to deactivate)',
      '(Rocket engines need to be tagged "rocket"(B) or "v_rocket"(SPACE + B))',
      '(Overide default tags ticked)'},

     dok = {'MANUAL: No auto docking',
      'CLOSEST: Auto dock to any potential constructs',
      'OWNER: uto dock to personally or orgs owned constructs'},

     bBu = 'DRONE mode auto pitch to counter velocity with engines power',
     aLR = 'Auto Land speed factor(press G for auto landing)',
     grO = 'Auto Land distance above ground to slow down(in meters)',
     aSO = 'Auto Land controls auto disconnection toggle',

     aAP = 'Auto Altitude Hold desired atmo density(doubel tap ALT+6)',
    }

    help.widgets = {
     body = format([[
     <text x="500" y="30" font-size="%0f" text-anchor="middle">
      <tspan x="500" font-size="%0f">WIDGETS SETTINGS%s

      %s%0f">- All widgets are resizeable, repositionable,%s
      %s%0f">by using the "Quick tool Bar" menu.%s

      %s%0f">- Widgets with the "ALT" option on will only popup%s
      %s%0f">when "Quick tool Bar" menu is opened.%s

      %s%0f">- Widgets with the "AUTO" option on will only popup%s
      %s%0f"> when the needed conditions they requiere are active.%s

      %s%0f">- Too many opened widgets can cause CPU overload%s
      %s%0f">Use them wisely!%s

      %s%0f">- Custom widgets are fully customizable and modular%s
      %s%0f">they can be found and edited in the WIDGETS folder.%s
      %s%0f">File name number must be consecutive%s

      %s%0f">- Custom Widgets are usingwindows system to display custom SVGs,%s
      %s%0f">they can also include custom buttons and thrust overide.%s

      %s%0f">> Find already developped ones on Github:%s
      %s%0f">> https://github.com/TheGreatSardini/Default--%s
     </text>]],
     fs,
     fs*2,h2,

     h1,ls*2,h2,
     h1,ls,h2,

     h1,ls*2,h2,
     h1,ls,h2,

     h1,ls*2,h2,
     h1,ls,h2,

     h1,ls*2,h2,
     h1,ls,h2,
     
     h1,ls*2,h2,
     h1,ls,h2,

     h1,ls*2,h2,
     h1,ls,h2,
     h1,ls,h2,

     h1,ls*2,h2,
     h1,ls,h2,

     h1,ls*2,h2,
     h1,ls,h2)}

    help.KP = {
      flM = {'CRUISE: Speed controled by throttle',
       'TRAVEL: Thrust controled by throttle',
       {'DRONE: Movements managed by vertical thrust only(WASD keys control)', 'Hover eng must be set to disable thrust along gravity.'},
       'PLATFORM: Multidirectional flight with locked pitch and roll(WASD keys control)'},
      pkM = {'PLATFORM: Auto switch to PLATFORM mode when close to ground',
       {'DRONE: Auto switch to DRONE mode when close to ground', 'Hover eng must be set to disable thrust along gravity.'}},
      pMS = 'Max speed limiter while in parking mode',

      iCo = 'Inverts keybind for yaw and roll',
      mCI = 'Inverts Mouse Controle Y axis',
      kWU = 'Control keys warmup time to full value(in sec)',
      dTT = 'Control keys double tap sensibility(in sec)',
      shL = 'SHIFT key to lock other control keys toggle',
      geL = 'G key for exiting PARKING mode toggle',
      mmb = {'MAX_THROTTLE: Secondary use of middle mouse button to set it to full throttle',
       'BRAKE: Secondary use of middle mouse button to activate brakes'},
      bTM = 'Brakes keybind toggleable toggle',

      mvL = 'Freeze player mouvement toggle(unseated remote control needs it to be true)',
      viL = 'Freeze player camera toggle(not working while using remotes)',

      moC = 'Pitch and Yaw controled by mouse(needs FREEZE VIEW = true)',
      mCS = 'MOUSE CONTROL mouse sensibility',

      flightModeKB = 'ALT + 3456789 constomizable keybinds for selected features',
      mouseControlKB = 'ALT + 3456789 constomizable keybinds for selected features',
      movementLockKB = 'ALT + 3456789 constomizable keybinds for selected features',
      altitudeAP = 'ALT + 3456789 constomizable keybinds for selected features',
      viewLockKB = 'ALT + 3456789 constomizable keybinds for selected features',
      speedLockKB = 'ALT + 3456789 constomizable keybinds for selected features',
      showScreenKB = 'ALT + 3456789 constomizable keybinds for selected features',
     }

    help.q = {
     body = format([[
     <text x="500" y="30" font-size="%0f" text-anchor="middle">
      <tspan x="500" font-size="%0f">QUICK TOOL BAR%s

      %s%0f">- While in the "ALT+1" main menu, hold "CTRL" then click to add%s
      %s%0f">or remove shortcut buttons from the Quick Tool Bar%s
      
      %s%0f">- Quick Tool Bar is accessible by double taping and holding "ALT" key while on the main screen%s
      
      %s%0f">- Widgets are interactible while Quick Tool Bar is opened%s
      
      %s%0f">- Certain widgets with "ALT" parameters will only popup with the Quick Tool Bar%s
     </text>]],
     fs,
     fs*2,h2,

     h1,ls*2,h2,
     h1,ls,h2,

     h1,ls*2,h2,

     h1,ls*2,h2,

     h1,ls*2,h2)}

    help.print = function()
     local b = "------------------------"
     p(b)p(b)p("CHAT COMMANDS")p(b)
     p("help: print the help menu")
     p("alt 1000: set Hold Altitude")
     p("reset all: formats databank to factory settings")
     p("reset others: remove other user saves")
     p("reset: Reset only my saved settings")
     p("type in a ::pos{} coordinate to translate it to world coordinate")
     p(b)
    end

  onStart:
   lua: |
    Kinematic = {} -- Part of Jaylebreak's flight files, modified slightly

    local clamp = utils.clamp
   
    function Kinematic.computeAccelerationTime(initial, acceleration, final)
     -- ans: t = (vf - vi)/a
     return (final - initial)/acceleration
    end

    function Kinematic.BrakeDistanceAndTime(initial,final,mass,thrust,maxBrakeForce,atmosDensity,gravityA,zAxis,zBrakeClamp)
     maxBrakeForce = maxBrakeForce or 0
     atmosDensity = atmosDensity or 1
     gravityA = gravityA or 9.89
     zAxis = zAxis or false
     zBrakeClamp = zBrakeClamp or 0.14 --0.1592 -- can't fall slower than this m/s 

     local gF = gravityA*mass
     local gA = gF/mass
     local tA = thrust / -mass
     local t, d = 0,0
     local zBrakeScale = 1
     if zAxis then zBrakeScale = clamp(gF/(maxBrakeForce*zBrakeClamp),0,1) end
     local bA = -(maxBrakeForce*atmosDensity*zBrakeScale)/mass

     if initial <= final then
      return 0, 0, 0  -- trivial
     elseif tA+bA >= 0 then
      return -1, -1, -1 -- no solution
     end
    
     if final < 100 then
      -- first calculate distance to 100 m/s
      local t1 = 0
      local d1 = 0
      if initial > 100 then 
       local a = tA+bA+gA
       t = Kinematic.computeAccelerationTime(initial, a, 100)
       d = initial*t + a*t*t/2
       initial = 100
      end

      -- iterate over remaining speed
      local initialVel = initial
      local stepSize = 2
      while initialVel > final do
       local t2, d2 = 0,0
       local targetVel = initialVel - stepSize > final and initialVel - stepSize or final
       local aveVel = (targetVel + initialVel)/2
       local brakeForce = 0
       if zAxis then 
        local bBottom = aveVel/(100/clamp(1+(6.28-(maxBrakeForce/gF)),1,100))*maxBrakeForce
        local bUpper = maxBrakeForce * clamp(aveVel/100,0.09,1)^1.01
        brakeForce = math.min(bBottom,bUpper) * zBrakeScale * atmosDensity
       else
        brakeForce = maxBrakeForce * clamp(aveVel/100,0.1,1) * atmosDensity
       end
       local bA2 = -brakeForce/mass
       local a = tA+bA2+gA
       if a > 0 then return d, t, initialVel end -- can't slow to target vel
       t2 = Kinematic.computeAccelerationTime(initialVel, a, targetVel)
       d2 = initialVel*t2 + a*t2*t2/2
       t = t2 + t
       d = d2 + d
       initialVel = targetVel
      end
     else
      --Directly calculate since end is > 100
      local a = tA+gA+bA
      t = Kinematic.computeAccelerationTime(initial, a, final)
      d = initial*t + a*t*t/2
     end
     return d, t, 0 --distance, time, minfall speed
    end

    function Kinematic.computeTravelTime(initial, acceleration, distance)
     -- quadratic equation: t=(sqrt(2ad+v^2)-v)/a
     if distance == 0 then return 0 end
     if acceleration ~= 0 then
      return (math.sqrt(2*acceleration*distance+initial^2) - initial)/acceleration
     end
     assert(initial > 0, 'Acceleration and initial speed are both zero.')
     return distance/initial
    end

    function Kinematic.maxInitialVelocity(distance,final,mass,thrust,hov,hoverDist,maxBrakeForce,atmosDensity,gravityA,zAxis,zBrakeClamp)
     if distance <= 0 then return -1 end
     
     hov = hov or 0
     hoverDist = hoverDist or 0
     maxBrakeForce = maxBrakeForce or 0
     atmosDensity = atmosDensity or 1
     gravityA = gravityA or 9.89
     zAxis = zAxis or false
     zBrakeClamp = zBrakeClamp or 0.14 --0.1592 -- can't fall slower than this m/s 

     local gF = gravityA*mass
     local gA = gF/mass
     local tA = thrust / -mass
     local hA = hov / -mass
     local bA = -maxBrakeForce/mass

     local function brakeAcceleration(velocity)
      if maxBrakeForce <= 0 or velocity == 0 then return 0 end
      local brakeForce = 0
      if zAxis then 
       local zBrakeScale = clamp(gF/(maxBrakeForce*zBrakeClamp),0,1)
       local bBottom = velocity/(100/clamp(1+(6.28-(maxBrakeForce/gF)),1,100))*maxBrakeForce
       local bUpper = maxBrakeForce * clamp(velocity/100,0.09,1)^1.01
       brakeForce = math.min(bBottom,bUpper) * zBrakeScale * atmosDensity
      else
       brakeForce = maxBrakeForce * clamp(velocity/100,0.1,1) * atmosDensity
      end
      return -brakeForce/mass
     end
     
     local increment = 2
     local distTraveled = 0
     local vCurrent = final

     while distTraveled < distance do
      local hAs = distTraveled <= hoverDist and hA or 0
      local bAs = brakeAcceleration(vCurrent)
      local a = tA+bAs+gA+hAs
      if a > 0 then return vCurrent end
      local distStep = distTraveled + increment < distance and increment or distance - distTraveled
      local vInitial = vCurrent
      local ts = Kinematic.computeTravelTime(vInitial, -a, distStep)
      vCurrent = vCurrent + (-a) * ts
      distTraveled = distTraveled + distStep
     end
     return vCurrent
    end
  onStart:
   lua: |
    -- navigator --
    local utils = require("cpml/utils")
    local pid = require("cpml/pid")

    local sign, clamp, abs, sqrt, min, max = utils.sign, utils.clamp, math.abs, math.sqrt, math.min, math.max
    local C = construct

    NPP = {} --NavigatorPlusPlus
    NPP.__index = NPP

    function NPP.new()
     local self = setmetatable({}, NPP)

     self.boosterState = 0
     self.boosterStateHasChanged = false
     self.boosterMaxSpeed = 1200 --TODO Use this?

     self.mM = "CRUISE" --MasterMode
     self.tV = 0 --ThrottleValue
     self.mouseWheelValue = 0
     self.mSK = unitData.maxSpeedkph --maxSpeedKMPH

     self.tSRS = {5,10,20,40,100,200,500,1000,5000} --targetSpeedRangesSteps
     self.tSR = {20,60,140,300,800,2000,7000,15000,unitData.maxSpeedkph} --targetSpeedRanges
     self.cTSS = 0 --currentTargetSpeedStep
     self.aMS = -2 --atmoMaxSpeed

     self.targetGAC = unit.computeGroundEngineAltitudeStabilizationCapabilities()
     return self
    end

    function NPP.setAtmoMaxSpeed(self,speed)
     self.aMS = speed
    end

    function NPP.getAtmoMaxSpeed(self)
     return self.aMS
    end

    ------------------
    -- Throttle setup
    ------------------
    function NPP.setupCustomTargetSpeedRanges(self, customTargetSpeedRanges)
     self.customTargetSpeedRanges = customTargetSpeedRanges
    end

    function NPP.getTargetSpeedRangeStep(self,value)
     for i, v in ipairs(self.tSR) do
      self.cTSS = self.tSRS[i]
      if value > 0 then
       if abs(self.tV) < v then
        return self.cTSS
       end
      else
       if abs(self.tV) <= v then
        if self.tSRS[i-1] ~= nil then
         if abs(self.tV) - self.cTSS <= self.tSR[i-1] then
          self.cTSS = abs(self.tV) - self.tSR[i-1]
         end
        end
        return self.cTSS
       end
      end
     end
    end

    function NPP.updateThrottleValue(self,value)
     if value ~= 0 then self:prepareForFlight() end
     if self.mM == "CRUISE" then
      self.tV = clamp(self.tV + value * self:getTargetSpeedRangeStep(value),-self.mSK,self.mSK)
     elseif self.mM == "TRAVEL" then
      self.tV = clamp(self.tV + value/10,-1,1)
     else self.tV = 0
     end
     if abs(self.tV) < 0.01 then self.tV = 0 end
    end

    function NPP.setThrottleValue(self,value)
     if value ~= 0 then self:prepareForFlight() end
     if self.mM == "CRUISE" then
      self.tV = clamp(value,-self.mSK,self.mSK)
     elseif self.mM == "TRAVEL" then
      self.tV = clamp(value,-1,1)
     else self.tV = 0
     end
    end

    function NPP.prepareForFlight(self)
     autoLand, autoStart = false,false
     enginesToggle()
     if pkM then
      pkM = false
      forwardInput = 0
      if P.KP.flM.value ~= self.mM then
       self:setMasterMode(P.KP.flM.value)
      end
     end
    end

    function NPP.resetThrottleValue(self)
     self.tV = 0
    end

    function NPP.getThrottleValue(self)
     return self.tV
    end

    -- Master Mode --
    function NPP.setMasterMode(self,mode)
     if self.mM == mode then return end
     self.mM = mode
     if self.mM == "CRUISE" then
      self.tV = ySpeedKPH > 10 and ySpeedKPH or 0
     elseif self.mM == "TRAVEL" or self.mM == "PLATFORM" or self.mM == "DRONE" then
      self:resetThrottleValue()
     end
     self.TargetLongitudinalSpeedPID:reset()
     self.TargetLateralSpeedPID:reset()
     self.TargetVerticalSpeedPID:reset()
     MM = self.mM
    end

    function NPP.buildPIDs(self)
     self.TargetLongitudinalSpeedPID = pid.new(10*P.ES.loF.value, 0, 10*P.ES.loF.value)
     self.TargetLateralSpeedPID = pid.new(10*P.ES.laF.value, 0, 10*P.ES.laF.value)
     self.TargetVerticalSpeedPID = pid.new(10*P.ES.vtF.value, 0, 10*P.ES.vtF.value)
    
     self.LongitudinalBrakePID = pid.new(1, 0, 10)
     self.LateralBrakePID = pid.new(1, 0, 10)
     self.VerticalBrakePID = pid.new(1, 0, 10)
    end

    function NPP.getMasterMode(self)
     return self.mM
    end

    -- Update --
    function NPP.throttleUpdate(self)
     local ThrottleInputFromMouseWheel = system.getThrottleInputFromMouseWheel()
      if self.mouseWheelValue ~= ThrottleInputFromMouseWheel then
       self:updateThrottleValue(ThrottleInputFromMouseWheel)
      end
     self.mouseWheelValue = ThrottleInputFromMouseWheel
    end
    function NPP.updateMaxSpeed(self,speed)
     self.mSK = speed
     self.tSR = {20,60,140,300,800,2000,7000,15000,unitData.maxSpeedkph}
    end

    -----------------
    -- Acceleration 
    ----------------
    function NPP.maxForceForward(self)
     local cOF = {cOFx, cOFy, cOFz}
     local maxKPAlongAxis = C.getMaxThrustAlongAxis('thrust analog longitudinal', cOF)
     local spaceT = maxKPAlongAxis[3]~= nil and maxKPAlongAxis[3] or 0
     local atmoT = maxKPAlongAxis[1]~= nil and maxKPAlongAxis[1] or 0
     if not inAtmo then
      return spaceT
     elseif inspace == 0 then
      return atmoT
     else
      return spaceT + atmoT
     end
    end

    function NPP.maxForceBackward(self)
     local cOF = {cOFx, cOFy, cOFz}
     local maxKPAlongAxis = C.getMaxThrustAlongAxis('thrust analog longitudinal', cOF)
     local spaceT = maxKPAlongAxis[4]~= nil and maxKPAlongAxis[4] or 0
     local atmoT = maxKPAlongAxis[2]~= nil and maxKPAlongAxis[2] or 0
     if not inAtmo then
      return spaceT
     elseif inspace == 0 then
      return atmoT
     else
      return spaceT + atmoT
     end
    end

    function NPP.getMaxKPA(self)
     return self:maxForceForward(), self:maxForceBackward()
    end

    function NPP.maxForceUp(self)
     local cOUP = {cOUPx, cOUPy, cOUPz}
     local tags = 'thrust analog not_ground '
     if bCM and gyro.isActive() == true then tags = tags .. 'lateral' else tags = tags .. 'vertical' end
     local maxKPAlongAxis = C.getMaxThrustAlongAxis(tags, cOUP)
     local spaceT = maxKPAlongAxis[3]~= nil and maxKPAlongAxis[3] or 0
     local atmoT = maxKPAlongAxis[1]~= nil and maxKPAlongAxis[1] or 0
     if not inAtmo then
      return spaceT
     elseif inspace == 0 then
      return atmoT
     else
      return spaceT + atmoT
     end
    end

    local function computeAxisAccel(AWDx, AWDy, AWDz, type)
     local cAV = C.getWorldVelocity()
     local cAVx, cAVy, cAVz = cAV[1], cAV[2], cAV[3]
     local WAFA = C.getWorldAirFrictionAcceleration()
     local WAFAx, WAFAy, WAFAz = WAFA[1], WAFA[2], WAFA[3]
     local gravityV = core.getWorldGravity()
     local gx, gy, gz = gravityV[1], gravityV[2], gravityV[3]

     if aggData.State == "ON" then
      local aggAD = alt - aggData.Altitude
      if abs(aggAD) < 240 and upInput == 0 then 
       if vectorLen(gx, gy, gz) > 0.01 and abs(aggAD) > 0.01 then
        local ngx, ngy, ngz = norm(gx, gy, gz) --toward the AGG height
        local velg = clamp(dotVec(cAVx, cAVy, cAVz, ngx, ngy, ngz),0,100) --current vel toward gravity (good)
        local tt = 1 --time to target height
        if type == "brake" then tt = clamp(abs(aggAD)/(velg*3),0,1) end--time to target
        local gVx, gVy, gVz = multiplyVec(ngx, ngy, ngz,velg*tt) --vector to nullify (because we want it)
        cAVx, cAVy, cAVz = cAVx-gVx, cAVy-gVy, cAVz-gVz
       end
       gx, gy, gz = 0,0,0
      end
     end

     local AxisSpeed = dotVec(cAVx, cAVy, cAVz, AWDx, AWDy, AWDz)
     local gravityAcc = dotVec(gx, gy, gz, AWDx, AWDy, AWDz)
     local fAirAcc = dotVec(WAFAx, WAFAy, WAFAz, AWDx, AWDy, AWDz)
     return AxisSpeed, gravityAcc, fAirAcc
    end

    local function awdAxis(axis)
     local AWDx, AWDy, AWDz = 0, 0, 0 --AxisWorldDirection
     if axis == "longitudinal" then
      AWDx, AWDy, AWDz = cWOFx, cWOFy, cWOFz
     elseif axis == "lateral" then
      AWDx, AWDy, AWDz = cWORx, cWORy, cWORz
     elseif axis == "vertical" then
      AWDx, AWDy, AWDz = cWOUPx, cWOUPy, cWOUPz
     end
     return AWDx, AWDy, AWDz
    end

    function NPP.burnMaxSpd(self) --in mps
     local spd = construct.getFrictionBurnSpeed()*3.6*0.8
     if atmosDensity < 0.05 then
      local p = 350
      spd = (-p*math.log(atmosDensity*20)+(1-(atmosDensity*20))*-p)+spd
     end
     return spd
    end

    function NPP.speedMPS(self,speed)
     speed = speed ~= nil and clamp(speed, -self.mSK+10, self.mSK-10) or 0
     if inAtmo and speed ~= 0 then
      local acMS = self.aMS == -2 and self:burnMaxSpd() or self.aMS > 0 and self.aMS or self.mSK
      speed = clamp(speed, -acMS, acMS)
     end
     return speed * 0.27777777777
    end

    function NPP.composeAccelerationFromTargetSpeed(self,axis,speed) --axis: longitudinal / lateral / vertical // speed: in kmph
     local tSpeed = self:speedMPS(speed)
     local AWDx, AWDy, AWDz = awdAxis(axis)
     local AxisSpeed, gravityAcc, fAirAcc = computeAxisAccel(AWDx, AWDy, AWDz,"thrust")

     local Acc = 0
     if axis == "longitudinal" then
      self.TargetLongitudinalSpeedPID:inject(tSpeed - AxisSpeed)
      Acc = self.TargetLongitudinalSpeedPID:get()
     elseif axis == "lateral" then
      self.TargetLateralSpeedPID:inject(tSpeed - AxisSpeed)
      Acc = self.TargetLateralSpeedPID:get()
     elseif axis == "vertical" then
      self.TargetVerticalSpeedPID:inject(tSpeed - AxisSpeed)
      Acc = self.TargetVerticalSpeedPID:get()
     end
     if self.mM == "DRONE" then
      Acc = (tSpeed - AxisSpeed)
     end
     if autoLand == true and velMag > 3 and (planetVertSpeedMPS < 0 or not inAtmo) then
      Acc = (tSpeed - AxisSpeed) * 5
     end

     local AAG = Acc - gravityAcc - fAirAcc
     local FAx = AAG * AWDx
     local FAy = AAG * AWDy
     local FAz = AAG * AWDz
     return FAx, FAy, FAz
    end


    function NPP.composeBrakeAcceleration(self,axis,speed)
     local tSpeed = self:speedMPS(speed)
     local AWDx, AWDy, AWDz = awdAxis(axis)
     local AxisSpeed, gravityAcc, fAirAcc = computeAxisAccel(AWDx, AWDy, AWDz,"brake")

     local Acc = tSpeed - AxisSpeed
     
     if (brakeInput == 1 or autoLand == true) and velMag > 3 and (planetVertSpeedMPS < 0 or not inAtmo) then Acc = (tSpeed - AxisSpeed) * 10 end
     local aRAC = Acc - gravityAcc - fAirAcc
     return aRAC * AWDx, aRAC * AWDy, aRAC * AWDz
    end

    function NPP.composeAccelerationFromThrottle(self)
     local cM = C.getTotalMass()
     local throttleForce = 0
     if self.tV > 0 then
      local maxAtmoForceForward = self:maxForceForward()
      throttleForce = self.tV * maxAtmoForceForward
     elseif self.tV < 0 then
      local maxAtmoForceBackward = self:maxForceBackward()
      throttleForce = -self.tV * maxAtmoForceBackward
     end
     local Acc = throttleForce / cM
     local FAx = Acc * cWOFx
     local FAy = Acc * cWOFy
     local FAz = Acc * cWOFz

     if inAtmo and (self.aMS > 0 and xyzSpeedKPH > self.aMS * 0.95 or self.aMS == -2 and xyzSpeedKPH > self:burnMaxSpd() * 0.95) then
      local FAx1, FAy1, FAz1 = self:composeAccelerationFromTargetSpeed('longitudinal',self:burnMaxSpd())
      if dotVec(FAx1, FAy1, FAz1, norm(FAx, FAy, FAz)) < vectorLen(FAx, FAy, FAz) then return FAx1, FAy1, FAz1 end
     end
     return FAx, FAy, FAz
    end
    function NPP.updateHovHeight(self,input)
     if P.ES.hoM.value == "STATIC" then
      P.ES.hoA.value = clamp(round(P.ES.hoA.value + input,1),0,self.targetGAC[1])
     end
    end

    function NPP.updateAggHeight(self,input)
     if aggData.State == "ON" and antigrav and P.ES.agA.value > 0 then
      P.ES.agA.value = clamp(math.floor(P.ES.agA.value + input),P.ES.agA.range[1],P.ES.agA.range[2])
      antigrav.setTargetAltitude(P.ES.agA.value) 
     end
    end

  onStart:
   lua: |
    -- CUSTOM WINDOWS --
    windowWidth = 260
    titleHeight = 25
    buttonWidth = 160
    buttonHeight = 25
    buttonGape = 5

    local TABLE = {}
    TABLE = {
     index = function (t,val)
      for i,v in ipairs(t) do
       if v == val then 
        return i
       end
      end
      return nil
     end,

     valUp = function (t,val)
      local index = TABLE.index(t,val)
      local newVal 
      if index == nil then
       newVal = t[1]
      elseif t[index+1] == nil then
       newVal = t[1]
      else
       newVal = t[index+1]
      end
      return newVal
     end,

     valDown = function (t,val)
      local index = TABLE.index(t,val)
      local newVal
      if index == nil then
       newVal = t[1]
      elseif t[index-1] == nil then
       newVal = t[#t]
      else
       newVal = t[index-1]
      end
      return newVal
     end,
    }

    function Save_Window_Pos(name,posX,posY)
     local ws = P.MS.MSS.value
     for i, v in ipairs(P) do
      if P.w_title == name then
       P.w_pos.x = posX/ws
       P.w_pos.y = posY/ws
       return
      else
       for k, l in ipairs(P[v]) do
        if P[v].w_title == name then
         P[v].w_pos.x = posX/ws
         P[v].w_pos.y = posY/ws
         return
        end
       end
      end
     end
     if name == P.help_menu.w_title then 
      P.help_menu.w_pos.x = posX
      P.help_menu.w_pos.y = posY
      return
     elseif name == P.QuickToolBar.w_title then 
      P.QuickToolBar.w_pos.x = posX
      P.QuickToolBar.w_pos.y = posY
      return
     end
     
     for i, v in pairs(P) do
      if string.sub (tostring(i),1,7) == "Widget_" and P[i].w_title == name then
       P[i].w_pos.x = posX
       P[i].w_pos.y = posY
       return
      end
     end
    end

    SubMenusButtonsClickFunction = function(v, l)
     return function()
      local tv = type(P[v][l].value)
      if CTRL == false then
       if mouseWheel == 0 then
        if tv == "number" then
         P[v][l].increment = TABLE.valUp(P[v][l].step, P[v][l].increment)
        elseif tv == "string" then
         P[v][l].value = TABLE.valUp(P[v][l].range, P[v][l].value)
        elseif tv == "boolean" then
         P[v][l].value = not P[v][l].value
        elseif tv == "function" then
         P[v][l].value()
        end
       elseif mouseWheel > 0 then
        if tv == "number" then
         P[v][l].value = P[v][l].value + P[v][l].increment
         P[v][l].value = utils.clamp(P[v][l].value,P[v][l].range[1],P[v][l].range[2])
         if math.abs(P[v][l].value) < 0.0009 then P[v][l].value = 0 end
        elseif tv == "string" then
         P[v][l].value = TABLE.valUp(P[v][l].range, P[v][l].value)
        elseif tv == "boolean" then
         P[v][l].value = not P[v][l].value
        end
       elseif mouseWheel < 0 then
        if tv == "number" then
         P[v][l].value = P[v][l].value - P[v][l].increment
         P[v][l].value = utils.clamp(P[v][l].value,P[v][l].range[1],P[v][l].range[2])
         if math.abs(P[v][l].value) < 0.0009 then P[v][l].value = 0 end
        elseif tv == "string" then
         P[v][l].value = TABLE.valDown(P[v][l].range, P[v][l].value)
        elseif tv == "boolean" then
         P[v][l].value = not P[v][l].value
        end
       end
      else
       if P.w_open == true then
        P[v][l].q = not P[v][l].q
       end
      end
      updateParams()
      if v == "MS" then WindowLib:winlibCSSUpdate() end
      if P.QuickToolBar.w_open == true then checkWidgets() end
      windowsShow()
     end
    end

    function Cursor_Builder()
     if P.w_open == true or P.QuickToolBar.w_open == true then
      local cursorPos = WindowLib:getMousePos()
      local window = WindowLib:new("",{class = "widgets", name = "cursor", width = 350, height = 350, posX = cursorPos[1], posY = cursorPos[2], fixed = false, draggable = false, alwaysOnTop = true, scalable = false})
     end
    end

    function Quick_Menu_Builder()
     if P.w_open == false and ALT == true then
     system.showHelper(0)
      local svg = [[<style>
      .button {fill:]]..P.MS.WTC.value..[[; font-size:12px; text-anchor:end; font-family:Play; alignment-baseline:middle}
      </style>]]
      local buttons = {}
      local ind = 0
      -- Creating favorit buttons
      for i, v in ipairs(P) do
       for k, l in ipairs(P[v]) do
        if l ~= "separator" then
         if P[v][l].q == true then
          local increment = ""
          if P[v][l].increment ~= nil then increment = " (+-"..tostring(P[v][l].increment)..")" end
          if type(P[v][l].value) ~= "function" then
           svg = svg .. [["<text class="button" x="]]..windowWidth - 10 ..[[" y="]].. 15 + ind * (buttonHeight + buttonGape*1.2) ..[[" >]]..string.sub (tostring(P[v][l].value),1,10):upper()..increment..[[</text>"]]
          end
          local nb = WindowLib:buttonsNew(P[v][l].name, SubMenusButtonsClickFunction(v,l), {width = buttonWidth, height = buttonHeight, posX = 5, posY = (titleHeight + 5 + ind * (buttonHeight + buttonGape))})
          ind = ind + 1
          buttons[ind] = nb
         end
        end
       end
      end
      -- Creating the window t1
      if ind > 0 then
       local ww = windowWidth
       local wh = (titleHeight + ind*(buttonHeight+buttonGape)+buttonGape)
       local window = WindowLib:new(
        [[<div style='background:rgba(0, 0, 0, 0); text-align:middle; vertical-align: text-top'>
        <svg viewBox="0 0 ]]..ww..[[ ]]..wh..[[">
        ]]..svg..[[
        </svg></div>
        ]],
        {name = P.QuickToolBar.w_title, title = P.QuickToolBar.w_title, width = ww, height = wh, posX = P.QuickToolBar.w_pos.x, posY = P.QuickToolBar.w_pos.y, fixed = false, draggable = true, alwaysOnTop = false, scalable = true, scale = P.QuickToolBar.w_scale},buttons)
      end
     end
    end

    function Params_Menu_Builder()
     if P.w_open == true then
      system.showHelper(0)
      local mainMenuButtons = {}
      local buttonClickFunction = nil
      local indMMB = 0
      local ind = 0
      local ws = P.MS.MSS.value
      --ComposeQuickToolMenu()
      for i, v in ipairs(P) do
       ind = 0
       local svg = [[<style>
       .button {fill:]]..P.MS.WTC.value..[[; font-size:]]..P.MS.WFS.value..[[px; text-anchor:end; font-family:Play; alignment-baseline:middle}
       </style>]]
       local buttons = {}
       --Building the main menu bar buttons
       if P[v] ~= P.QuickToolBar then
        buttonClickFunction = function()
         P[v].w_open = not P[v].w_open
         WindowLib = WLP.init()
         Params_Menu_Builder()
         Help_Menu_Builder()
         Cursor_Builder()
        end
        local mmb = WindowLib:buttonsNew(P[v].w_title, buttonClickFunction, {name = P[v].w_title, width = windowWidth, height = buttonHeight, posX = (5 + indMMB * (windowWidth + buttonGape)), posY = 5})
        indMMB = indMMB + 1
        mainMenuButtons[indMMB] = mmb
       end
       --Building the windows buttons
       for k, l in ipairs(P[v]) do
        local increment = ""
        local QTBtag = ""
        if P[v].w_open == true then
         if l ~= "separator" then
          if P[v][l].increment ~= nil then increment = " (+-"..tostring(P[v][l].increment)..")" end
          if P[v][l].q == true then QTBtag = "*" end
          local nb = WindowLib:buttonsNew(P[v][l].name..QTBtag, SubMenusButtonsClickFunction(v,l), {name = tostring(l), width = buttonWidth, height = buttonHeight, posX = 5, posY = (titleHeight + 5 + (k-1) * (buttonHeight + buttonGape))})
          ind = ind + 1
          buttons[ind] = nb
          if type(P[v][l].value) ~= "function" then
           svg = svg .. [["<text class="button" x="]]..windowWidth - 5 ..[[" y="]].. (15 + (k-1) * (buttonHeight + buttonGape*1.2)) ..[[" >]]..string.sub(tostring(P[v][l].value),1,10):upper()..increment..[[</text>"]]
          end
         else
          local nb = WindowLib:buttonsNew("", nil, {class= "separator", width = 0, height = 0, posX = 0, posY = (titleHeight + 5 + (k-1) * (buttonHeight + buttonGape))})
          ind = ind + 1
          buttons[ind] = nb
          svg = svg .. [["<line x1="5" y1="]].. 12 + (k-1) * (buttonHeight + buttonGape*1.2) ..[[" x2="]]..windowWidth - 10 ..[[" y2="]].. 12 + (k-1) * (buttonHeight + buttonGape*1.2) ..[[" stroke="]]..P.MS.BBC.value..[[" fill="None" stroke-width="0.5"/>"]]
         end
        end
       end
       
       -- Creating the sub menu window
       if ind > 0 and v ~= P.QuickToolBar then
        local ww = windowWidth
        local wh = (titleHeight + ind *(buttonHeight+buttonGape)+buttonGape)
        local wclass = nil
        local whtml = ""
        local window = WindowLib:new(
        [[<div><svg viewBox="0 0 ]]..ww..[[ ]]..wh..[[">
        ]]..svg..whtml..[[
        </svg></div>
        ]],
        {name = tostring(v), title = P[v].w_title, width = ww, height = wh, posX = P[v].w_pos.x * ws, posY = P[v].w_pos.y * ws, draggable = true, scalable = true, scale = ws},buttons)
       end
      end
      
      -- Creating the main menu bar window
      local sw = system.getScreenWidth()
      local window = WindowLib:new(
        [[<div><svg viewBox="0 0 ]].. sw ..[[ ]].. buttonHeight ..[[">
        <text x="]]..sw - 5 ..[[" y="]].. 5 *ws ..[[" font-size="]].. 13*ws ..[[" font-family="Play" text-anchor="end" alignment-baseline="hanging" fill="]]..P.MS.BTC.value..[[">DEFAULT-- ]]..script.version..[[ by TheGreatSardini</text>
        </svg></div>
        ]],{name = P.w_title, width = sw/ws, height = buttonHeight + buttonGape , posX = P.w_pos.x, posY = P.w_pos.y, draggable = false, scalable = true, scale = ws},mainMenuButtons)
     end
    end

    function Help_Menu_Builder()
     if P.help_menu.w_open == true then
      local buttons = {}
      local svg = ""
      local ind = 0
      for i, v in ipairs(P.help_menu) do
       if v ~= "separator" then
        local help_button_function = function(v)
         return function()
           P.help_menu.w_html = P.help_menu[v].html
           WindowLib = WLP.init()
           Params_Menu_Builder()
           Help_Menu_Builder()
           Cursor_Builder()
           end
        end
        local nb = WindowLib:buttonsNew(P.help_menu[v].name, help_button_function(v), {name = P.help_menu[v].name,width = buttonWidth, height = buttonHeight, posX = 5, posY = (titleHeight + 5 + (i-1) * (buttonHeight + buttonGape))})
        ind = ind + 1
        buttons[ind] = nb
       else
        local nb = WindowLib:buttonsNew("", nil, {name = "separator",class= "separator", width = 0, height = 0, posX = 0, posY = (titleHeight + 5 + (i-1) * (buttonHeight + buttonGape*1.2))})
        ind = ind + 1
        buttons[ind] = nb
        svg = svg .. [["<line x1="5" y1="]].. 12 + (i-1) * (buttonHeight + buttonGape*1.2) ..[[" x2="]]..buttonWidth - 5 ..[[" y2="]].. 12 + (i-1) * (buttonHeight + buttonGape*1.2) ..[[" stroke="]]..P.MS.BBC.value..[[" fill="None" stroke-width="0.5"/>"]]
       end
      end
      
      local btf = function() return function() P.help_menu.w_open = not P.help_menu.w_open windowsShow() end end
      local ww = 800
      local wh = (titleHeight + ind *(buttonHeight+buttonGape)+buttonGape) + 75
      local whtml = P.help_menu.w_html
      
      local nb = WindowLib:buttonsNew("T", btf(),{name = "hm_x", width = 15, height = 15, posX = ww - 20, posY = 5})
      ind = ind + 1
      buttons[ind] = nb
      
      local window = WindowLib:new(
      [[<div><svg viewBox="0 0 ]]..ww..[[ ]]..wh..[[">
      ]]..svg..whtml..[[
      </svg></div>
      ]],
      {name = P.help_menu.w_title, title = P.help_menu.w_title, width = ww, height = wh, posX = P.help_menu.w_pos.x, posY = P.help_menu.w_pos.y, draggable = true, scalable = true, scale = P.help_menu.w_scale},buttons)
     end
    end

    function processPcall(success, response)
     if not success then
      --pd("ERROR:"..response)
      return nil
     else
      return response
     end
    end

    function Widgets_Builder()
     if P.w_open == false then
      for i, v in ipairs(customWidgets) do
       if P["Widget_Custom"..i].w_open == true then
        local svg = processPcall(pcall(function() return v:SVG_Update() end))
        local bt = processPcall(pcall(function() return v:getButtons() end))
        local tt = processPcall(pcall(function() return v:getTitle() end))
        if svg and bt then
         local wSize = processPcall(pcall(function() return v:getSize() end))
         if P["Widget_Custom"..i].w_size.x ~= wSize.x or P["Widget_Custom"..i].w_size.y ~= wSize.y then P["Widget_Custom"..i].w_size = wSize end
         local nbt = {}
         for i2, v2 in ipairs(bt) do
          nbt[i2] = WindowLib:buttonsNew(v2[1], v2[2], v2[3])
         end
         if #nbt == 0 then nbt = nil end
         local wScale = P["Widget_Custom"..i].w_scale
         local window = WindowLib:new(svg,
          {class = v.class,
          name = P["Widget_Custom"..i].w_title,
          title = tt,
          width = P["Widget_Custom"..i].w_size.x,
          height = P["Widget_Custom"..i].w_size.y,
          posX = P["Widget_Custom"..i].w_pos.x,
          posY = P["Widget_Custom"..i].w_pos.y,
          draggable = v.draggable,
          fixed = v.fixed,
          scalable = v.scalable,
          scale = wScale,
          },
          nbt)
        end
       end
      end

      widget.width = system.getScreenWidth()
      widget.height = system.getScreenHeight()
      if P.Widget_HUD.w_open == true then
       local svg = widget:HUD_Update()
       local window = WindowLib:new(svg,{class = "widgets", name = P.Widget_HUD.w_title, width = P.Widget_HUD.w_size.x*P.Widget_HUD.w_scale, height = P.Widget_HUD.w_size.y*P.Widget_HUD.w_scale, posX = widget.width/2 -(widget.hudSVGSize.x*P.Widget_HUD.w_scale*P.MS.MSS.value)/2, posY = widget.height/2 -(widget.hudSVGSize.y*P.Widget_HUD.w_scale*P.MS.MSS.value)/2, draggable = false, fixed = true, scalable = true})
      end
      if P.Widget_Platform.w_open == true then
       local svg = widget:Platform_Update()
       local window = WindowLib:new(svg,{class = "widgets", name = P.Widget_Platform.w_title, width = P.Widget_Platform.w_size.x*P.Widget_Platform.w_scale, height = P.Widget_Platform.w_size.y*P.Widget_Platform.w_scale, posX = P.Widget_Platform.w_pos.x, posY = P.Widget_Platform.w_pos.y, draggable = true, scalable = true})
      end
     end
    end
  onStart:
   lua: |
    -- ON START PARAMS -- Globals
    function onStartParams()
     pd("Loading onStartParams")
     unit.deactivateGroundEngineAltitudeStabilization()
     hasFinishedLoading = false
     system.showScreen(1)

     fps = 0
     uCount = 0

     cursorX = 860
     cursorY = 440
     reset = false
     mouseWheel = 0
     mwCLICK = false
     CLICK = false
     CTRL = false
     ALT = false
     SHIFT = false
     GEAR = false
     blockArrows = false

     pitchInput = 0
     rollInput = 0
     yawInput = 0
     brakeInput = 0
     strafeInput = 0
     upInput = 0
     forwardInput = 0
     boosterInput = 0
     v_boosterInput = 0
     boosterTime = system.getArkTime()
     ThrottlePos = 0

     previousDeltaY = 0
     previousDeltaX = 0

     xSpeedKPH = 0
     ySpeedKPH = 0
     zSpeedKPH = 0
     xyzSpeedKPH = 0
     velMag = 0
     Az = 0
     Ax = 0
     Ax0 = 0
     Ay0 = 0
     cWOUPx, cWOUPy, cWOUPz = 0, 0, 0
     cWOFx, cWOFy, cWOFz = 0, 0, 0
     cWORx, cWORy, cWORz = 0, 0, 0

     cOUPx, cOUPy, cOUPz = 0, 0, 0
     cOFx, cOFy, cOFz = 0, 0, 0
     cORx, cORy, cORz = 0, 0, 0

     planetVertSpeedMPS = 0
     cWAVx, cWAVy, cWAVz = 0,0,0
     wVx, wVy, wVz = 0,0,0
     gravity = 0

     MM = "TRAVEL"
     pkM = true

     VStabAltLock = nil
     turnAssist_toggle = false
     atmoSpeedLock = true

     PKP = ""
     PKPT = 999
     DTK = ""
     Engines = false

     fuelTanksData = {}
     unitData = {}
     aggData = {}
     warpData = {}

     --DRONE
     modeRocket = false
     rocketWarmup = false

     --AUTO LAND
     autoLand = false
     autoStart = false
     autoStartTime = 0
     landTime = 0

     -- BRAKING
     gravityA = 0
     atmosDensity = 0
     LastMaxBrakeInAtmo = 0
     LastMaxBrake = 0
     Gnd = AboveGroundLevel()
     hasGndDet = telemeter ~= nil and true or vBooster ~= nil and true or hover ~= nil and true or false
     hasATelemeter = telemeter ~= nil and true
     bCM = false -- brake CROSS Mode
     approachSpeed = 0
     approachSpeedZ = 0
     BrakeToggle = false

     -- THRUST
     TargetSpeed = {0,0,0}
     ThrustAcc = {0,0,0}
     BrakeAcc = {0,0,0}

     -- Autopilot
     LowOrbitHeight = 2000
     nearPlanet = true
     ahDoubleClick = 0

     maxSafeVel = 0

     fpsWarning = ""

     BackBurnToggle = false
     PreviousMasterMode = ""
     parkingModeLockOut = false

     vec2 = require "cpml.vec2"
     Data = dtbk.new(DB_1)
     Atlas = require "atlas"
     Helios = Atlas[0]
     --Atlas = nil
     pd("Atlas loaded")
     Nav = NPP.new()
     Nav:buildPIDs()
     pd("Navigator-- new created")
     widget = WidgetsPlusPlus.new()
     pd("Widgets-- new created")

     local function tp(s) 
      if string.find(s,"no file '" .. widgetsFolder .. ".widget--custom",1,true) then return end
      pd(s) --comment to block printing prequires
     end
     local function pRequire(libName)
      return xpcall( require, tp, libName)--xpcall( require, system.print, libName)
     end
     customWidgets = {}
     
     for inc=1, 25 do --number of customWidgets
      local fileName = widgetsFolder .. ".widget--custom"..inc
      local i = #customWidgets+1
      if pRequire(fileName) ~= false then
       pd("Widgets-- Custom"..inc.." found")
       require (fileName)
       customWidgets[i] = processPcall(pcall(function() return WidgetsPlusPlusCustom.new(core, unit, (DB_1 ~= nil) and DB_1 or nil, (antigrav ~= nil) and antigrav or nil, (warpdrive ~= nil) and warpdrive or nil, (shield ~= nil) and shield or nil, (switch ~= nil) and switch or nil, player, telemeter) end))
       P.Widgets_Custom[i] = "w_custom"..i
       P.Widgets_Custom["w_custom"..i] = {name = "CUSTOM 1", value = "None", range = {"Default --", "ALT", "None"}, q = false}
       P.Widgets_Custom["w_custom"..i].name = processPcall(pcall(function() return customWidgets[i]:getName() end))
       P["Widget_Custom"..i] = {
        w_title = processPcall(pcall(function() return customWidgets[i]:getName() end)),
        w_pos = processPcall(pcall(function() return customWidgets[i]:getPos() end)),
        w_size = processPcall(pcall(function() return customWidgets[i]:getSize() end)),
        w_scale = pcall( function () return type(customWidgets[i]:getScale()) end ) and customWidgets[i]:getScale() or 1,
        w_open = false,
       }
       pd("Widgets-- Custom"..inc.." new created")
       if type(customWidgets[i].loadData) == 'function' and DB_1 ~= nil then
        local _ = processPcall(pcall(function() return customWidgets[i]:loadData() end))
        pd("Widgets-- Custom"..inc.." data loaded")
       end
      else
       --break
      end
     end

     WindowLib = WLP.init()
     pd("winlib-- new created")

     gearExtended = (unit.isAnyLandingGearDeployed() == true)
     if gearExtended then
      unit.deployLandingGears()
     else
      unit.retractLandingGears()
     end
     unit.switchOnHeadlights()

     local function decodeJSON(json)
      local decodedInput = string.gsub(json, "%\\u(%x%x%x%x)", function(a) return utf8.char(tonumber(a,16))end)
      return load('return ' .. decodedInput:gsub('[[]', '{'):gsub('[]]', '}'):gsub('"(%w+)":', '["%1"]='))()
     end
     local RemoteControl = false
     local helperId = decodeJSON(unit.getWidgetData())["helperId"] if helperId == nil then helperId = "nan" end
     if helperId == "basic_control_unit" or unit.isRemoteControlled() == true then RemoteControl = true end
     if RemoteControl == true then
      player.freeze(1)
      pd("Is remote controled")
      P.KP.mvL.value = true
      P.KP.mvL.q = true
     end

     local function merge(t1, t2)
      if type(t1) ~= "table" or type(t2)~= "table" then return nil end
      local newT = t1
      local ind = #t1
      for k,v in pairs(t2) do
       ind = ind + 1
       newT[ind] = v
      end 
      return newT
     end
     fueltanks_size = atmofueltank_size + spacefueltank_size + rocketfueltank_size
     fueltanks = {}
     fueltanks = merge(fueltanks,atmofueltank) or fueltanks
     fueltanks = merge(fueltanks,spacefueltank) or fueltanks
     fueltanks = merge(fueltanks,rocketfueltank) or fueltanks
     pd("Merged fuel tanks")
     prevFTD = 0
    end
  onStart:
   lua: |
    -- Keybinds library --
    local function density_alt(d,a)--density,altitude
     if d <= 0 or d > 1 or a <= 0 then return nil end
     return (-0.041 * math.log(d) + (1 - d) * 0.357)*a*1.295
    end
    local sSS = true
    local tFactor = 1
    local altPreset = 0
    local function checkKeybinds(option)
     if string.sub(P.KP.mouseControlKB.value,-1,-1) == option then
      P.KP.moC.value = not P.KP.moC.value
      p("mouse control "..tostring(P.KP.moC.value))
     elseif string.sub(P.KP.movementLockKB.value,-1,-1) == option then
      P.KP.mvL.value = not P.KP.mvL.value
      p("movement lock "..tostring(P.KP.mvL.value))
     elseif string.sub(P.KP.viewLockKB.value,-1,-1) == option then
      P.KP.viL.value = not P.KP.viL.value
      p("view lock "..tostring(P.KP.viewLockKB.value))
     elseif string.sub(P.KP.flightModeKB.value,-1,-1) == option then
      if P.KP.flM.value == "CRUISE" then
        setControlMasterMode("TRAVEL")
      elseif P.KP.flM.value == "TRAVEL" then
        setControlMasterMode("CRUISE")
      end
     elseif string.sub(P.KP.altitudeAP.value,-1,-1) == option then
      if (ArkTime - ahDoubleClick) < 1.5 then
       if hasAtmosphere then
        if inAtmo then
         local h_alt = density_alt(P.AS.aAP.value/100,noAtmosphericDensityAltitude)+currentPlanetAtmoOffset
         --system.print("h_alt: "..tostring(h_alt).." %: "..P.AS.aAP.value/100)
         if h_alt then
          HoldAltitude = h_alt
          p("Altitude Locked to "..P.AS.aAP.value.."% atmo.")
         end
        else
         if nearPlanet then
          HoldAltitude = noAtmosphericDensityAltitude + LowOrbitHeight
         end
        end
        ahDoubleClick = -1
        if HoldAltitude ~= nil then return end
       end
      else
       ahDoubleClick = ArkTime
      end
      if HoldAltitude ~= nil then 
       HoldAltitude = nil 
       ahDoubleClick = 0
      elseif ahDoubleClick > -1 then --not in deep space
       HoldAltitude = round(alt) 
      end
      autoLand, autoStart = false,false
      if HoldAltitude ~= nil then Nav:prepareForFlight() end
      return
     elseif string.sub(P.KP.speedLockKB.value,-1,-1) == option then
      atmoSpeedLock = not atmoSpeedLock
      if atmoSpeedLock == true then Nav:setAtmoMaxSpeed(P.ES.aMS.value) p("Atmospheric speed limit activated")
      else Nav:setAtmoMaxSpeed(-1) p("Atmospheric speed limit deactivated") end
     elseif string.sub(P.KP.showScreenKB.value,-1,-1) == option then
      p("Toggling system.showScreen")
      sSS = not sSS
      if sSS == true then system.showScreen(1) else system.showScreen(0) end
     end
     updateParams()
    end
    
    local function qead(a)
     if P.KP.iCo.value == true then 
      return a=='yawright' and 'right' or a=='yawleft' and 'left' or a=='right' and 'yawright' or a=='left' and 'yawleft' or a
     else
      return a
     end
    end

    local ticks = {}
    function keyBindsOnStartControl(a) -- action
     a = qead(a)
     local mTime = system.getArkTime()-0.03 -- usually the aproximate repeat interval
     if not ticks[a] then ticks[a] = {} end
     ticks[a]["t"] = mTime
     if a ~= nil then
      --system.print('on a start: '..a)
      for i, cWidget in ipairs(customWidgets) do
       if type(cWidget.onActionStart) == 'function' and P["Widget_Custom"..i].w_open == true then
        local _ = processPcall(pcall(function() return cWidget:onActionStart(a) end))
       end
      end
     end
     if a == 'option1' then
      P.w_open = not P.w_open
      P.QuickToolBar.w_open = false
      if P.w_open == false then
       windowsHide()
      else windowsShow() end
      ALT = false
     elseif a == 'option2' then
      -- TODO use this?
     elseif a == 'option3' then
      checkKeybinds("3")
     elseif a == 'option4' then
      checkKeybinds("4")
     elseif a == 'option5' then
      checkKeybinds("5")
     elseif a == 'option6' then
      checkKeybinds("6")
     elseif a == 'option7' then
      checkKeybinds("7")
     elseif a == 'option8' then
      checkKeybinds("8")
     elseif a == 'option9' then
      checkKeybinds("9")
     elseif a ~= 'lalt' and a ~= 'lshift' and not (a == 'brake' and velMag < 1) and a ~= 'gear' and 
     ((a=='up' or a=='down' or a=='strafeleft' or a=='straferight') and not blockArrows)
     then
      enginesToggle()
     end
     if P.w_open == true then
      system.showHelper(0)
      if a == 'stopengines' or a == 'leftmouse' then
       WindowLib:toggleClick(true)
      elseif a == 'brake' then
       CTRL = true
      end
     elseif P.QuickToolBar.w_open == true then
      system.showHelper(0)
      if a == 'stopengines' or a == 'leftmouse' then
       WindowLib:toggleClick(true)
      end
     elseif MM == "CRUISE" or MM == "TRAVEL" then
      if a == 'brake' then
       if DTK ~= "brake" and Nav:getMasterMode() == "CRUISE" then
        if Nav:getThrottleValue() > constants.epsilon then
         --Nav:updateThrottleValue(-0.5)
        end
       end
      end
     elseif MM == "PLATFORM" then
      if a == 'stopengines' then
       if pkM then modeRocket = false else modeRocket = not modeRocket end
      end
     elseif MM == "DRONE" then
      if a == 'stopengines' then
       if pkM then modeRocket = false else modeRocket = not modeRocket end
       if modeRocket then self.warmup = true else self.warmup = false VStabAltLock = nil end
      end     
     end

     -- Shared Actions for all Modes --
     --system.print(tostring(P.w_open))
     if P.w_open == false and P.QuickToolBar.w_open == false then
      tFactor = 1
      if PKP == a and ArkTime - PKPT < P.KP.dTT.value then 
       DTK = a 
       --system.print("Double tap: "..a) 
      end
      PKP = a -- previous keypress
      PKPT = ArkTime

      if a == 'speedup' then
       Nav:updateThrottleValue(0.1)
      elseif a == 'speeddown' then
       Nav:updateThrottleValue(-0.1)
      elseif a == 'stopengines' then
       if P.KP.mmb.value == 'MAX THROTTLE' then
        if Nav:getThrottleValue() == 0 then
         Nav:setThrottleValue(unitData.maxSpeedkph)
        else
         Nav:resetThrottleValue()
         Nav:setThrottleValue(0)
        end
       else
        if P.KP.mmb.value == 'BRAKE' then brakeInput = 1 end
        Nav:resetThrottleValue()
        Nav:setThrottleValue(0)
       end
       mwCLICK = true
       autoLand, autoStart = false,false
      elseif a == 'forward' or a == 'backward' then
       autoLand, autoStart = false,false
       modeRocket = false 
       if MM~="PLATFORM" then HoldAltitude = nil end
      elseif a == 'right' or a == 'left' then
       autoLand, autoStart = false,false
      elseif a == 'straferight' or a == 'strafeleft' then
       autoLand, autoStart = false,false
       modeRocket = false
      elseif a == 'up' then
       autoLand, autoStart = false,false
       HoldAltitude = nil
      elseif a == 'down' then
       autoLand, autoStart = false,false
       HoldAltitude = nil
       landTime = ArkTime
      elseif a == 'lshift' then
       SHIFT = true
      elseif a == 'lalt' then
       system.showHelper(0)
       ALT = true
       if DTK == 'lalt' then
        P.QuickToolBar.w_open = true
        windowsShow()
       end
      elseif a == 'brake' then
       CTRL = true
       brakeInput = 1
       autoLand, autoStart = false,false
      elseif a == 'gear' then
       GEAR = true
       modeRocket = false
       HoldAltitude = nil
       toggleLandingGearCheck()
       if geL then 
        if not withinParkingRange() or autoLand or DTK == 'gear' or P.KP.flM.value == "DRONE" or P.KP.flM.value == "PLATFORM" then 
         enableAutoLand()
        else
         setParkingMode(not pkM)
         parkingModeLockOut = not pkM
        end
       else
        if withinParkingRange() and Engines == false then
         enginesToggle()
         enableAutoStart()
        else
         enableAutoLand()
        end
       end
      elseif a == 'light' then
       if unit.isAnyHeadlightSwitchedOn() == true then
        unit.switchOffHeadlights()
       else
        unit.switchOnHeadlights()
       end
      elseif a == 'booster' then
       if upInput ~= 0 then v_boosterInput = 1
       else boosterInput = 1
       end
      elseif a == 'antigravity' then
       if antigrav ~= nil then antigrav.toggle() end
      elseif a == 'warp' then
      end
     end
    end

    local ctrl_alt = false
    function keyBindsOnStopControl(a)
     a = qead(a)
     if a ~= nil then
      for i, cWidget in ipairs(customWidgets) do
       if type(cWidget.onActionStop) == 'function' and P["Widget_Custom"..i].w_open == true then
        local _ = processPcall(pcall(function() return cWidget:onActionStop(a) end))
       end
      end
     end
     if a == DTK then 
      --system.print("Double tap released: "..DTK) 
      DTK = "" 
     end
     if P.w_open == true then
      if a == 'stopengines' or a == 'leftmouse' then
       WindowLib:toggleClick(false)
      elseif a == 'brake' then
       CTRL = false
      end
     elseif P.QuickToolBar.w_open == true then
      system.showHelper(1)
      if a == 'stopengines' or a == 'leftmouse' then
       WindowLib:toggleClick(false)
      elseif a == 'lalt' then
       P.QuickToolBar.w_open = false
       ALT = false
       windowsHide()
      end
     end
     if (a ~= 'lshift' and (SHIFT == false or SHIFT == true and P.KP.shL.value == false) and MM ~= "DRONE") or MM == "DRONE" or a=='lshift' then else return end
     -- Shared Actions for all modes
     if P.w_open == false and P.QuickToolBar.w_open == false then
      if a == 'stopengines' then
       if P.KP.mmb.value == 'BRAKE' and CTRL == false then brakeInput = 0 end
       mwCLICK = false
      elseif a == 'forward' or a == 'backward' then
       if MM=="PLATFORM" then forwardInput = 0 else pitchInput = 0 end
      elseif a == 'yawright' or a == 'yawleft' then
       yawInput = 0
      elseif a == 'right' or a == 'left' then
       if MM=="PLATFORM" then strafeInput = 0 else rollInput = 0 end
      elseif a == 'straferight' or a == 'strafeleft' then
       strafeInput = 0
      elseif a == 'up' or a == 'down' then
       upInput = 0
      elseif a == 'brake' then
       CTRL = false
       if ALT == false and ctrl_alt == false and P.KP.bTM.value == false then brakeInput = 0 end
       if ctrl_alt then ctrl_alt = false end
       if P.KP.bTM.value then 
        BrakeToggle = not BrakeToggle
        brakeInput = BrakeToggle and 1 or 0
       end
      elseif a == 'gear' then
       GEAR = false
      elseif a == 'lshift' then
       SHIFT = false
      elseif a == 'lalt' then
       if CTRL then ctrl_alt = true else ctrl_alt = false end
       ALT = false
      elseif a == 'booster' then
       boosterInput = 0
       v_boosterInput = 0
      end
     end
    end

    local clamp = utils.clamp
    local function inc(a)
     if DTK == a then return 1 end
     return ticks[a].d / P.KP.kWU.value
    end
    local function yI(val,a) yawInput = clamp(yawInput + val*inc(a),-1,1) end
    local function rI(val,a) rollInput = clamp(rollInput + val*inc(a),-1,1) end
    local function pI(val,a) pitchInput = clamp(pitchInput + val*inc(a),-1,1) end
    local function uI(val,a) upInput = clamp(upInput + val*inc(a),-1,1) end
    local function fI(val,a) forwardInput = clamp(forwardInput + val*inc(a),-1,1) end
    local function sI(val,a) strafeInput = clamp(strafeInput + val*inc(a),-1,1) end

    function keyBindsOnLoopControl(a)
     a = qead(a)
     tFactor = utils.clamp(tFactor * 1.01 + 0.1,1,1000)
     if a == nil then return end
     local mTime = system.getArkTime()
     ticks[a]["d"] = mTime - ticks[a].t
     ticks[a]["t"] = mTime

     for i, cWidget in ipairs(customWidgets) do
      if type(cWidget.onActionLoop) == 'function' and P["Widget_Custom"..i].w_open == true then
       local _ = processPcall(pcall(function() return cWidget:onActionLoop(a) end))
      end
     end

     --shared
     if P.w_open == false and P.QuickToolBar.w_open == false then
      if a == 'straferight' then
       if not blockArrows then sI(1,a) end
      elseif a == 'strafeleft' then
       if not blockArrows then sI(-1,a) end
      elseif a == 'up' then
       if not blockArrows then uI(1,a) end
      elseif a == 'down' then
       if not blockArrows then uI(-1,a); checkLanded() end
      elseif a == 'speedup' then
       Nav:updateThrottleValue(0.02*tFactor)
      elseif a == 'speeddown' then
       Nav:updateThrottleValue(-0.02*tFactor)
      elseif a == 'groundaltitudeup' then
       Nav:updateHovHeight(0.1*tFactor)
       if HoldAltitude then HoldAltitude = math.floor(HoldAltitude + (5 * tFactor)) end
       Nav:updateAggHeight(1*tFactor)
      elseif a == 'groundaltitudedown' then
       Nav:updateHovHeight(-0.1*tFactor)
       if HoldAltitude then HoldAltitude = math.floor(HoldAltitude - (5 * tFactor)) end
       Nav:updateAggHeight(-1*tFactor)
      --separate
      else
       if a == 'forward' then
        if MM=="PLATFORM" then fI(1,a) else pI(-1,a) end
       elseif a == 'backward' then
        if MM=="PLATFORM" then fI(-1,a) else pI(1,a) end
       elseif a == 'yawright' then
        yI(-1,a)
       elseif a == 'yawleft' then
        yI(1,a)
       elseif a == 'right' then
        if MM=="PLATFORM" then sI(1,a) else rI(1,a) end
       elseif a == 'left' then
        if MM=="PLATFORM" then sI(-1,a) else rI(-1,a) end
       elseif a == 'booster' then
       end
      end
     end


    end
    
  onStart:
   lua: |
    -- Divers Functions --
    function getGlobals()
     currentWorldPos = vec3(construct.getWorldPosition())
     closestPlanetIndex = 0
     local planetDistance = 999999999999
     for i, v in pairs(Helios) do
      if (currentWorldPos - vec3(v.center)):len() < planetDistance then
       planetDistance = (currentWorldPos - vec3(v.center)):len()
       closestPlanetIndex = i
      end
     end
     planet = Helios[closestPlanetIndex]
     currentPlanetName = planet.name[1]
     currentPlanetRadius = planet.radius
     currentPlanetAtmoRadius = planet.atmosphereRadius or 0
     currentPlanetAtmoThick = planet.atmosphereThickness or 0
     currentPlanetAtmoOffset = currentPlanetAtmoRadius - currentPlanetRadius - currentPlanetAtmoThick
     currentPlanetCenter = planet.center
     currentPlanetGM = planet.GM
     currentPlanetMaxStatic = planet.maxStaticAltitude or 1000
     hasAtmosphere = planet.hasAtmosphere
     local altTable = { [1]=6637, [2]=3426, [4]=7580, [26]=4242, [27]=4150, [3]=21452, [6]=4498, [7]=6285, [8]=3434, [9]=5916 } -- Measured min space engine altitudes for: Madis, Alioth, Talemai, Sanctuary, Haven, Sicari, Sinnen, Thades, Teoma, Jago
     spaceEngineMinAltitude = altTable[planet.id] or 0.5353125*(currentPlanetAtmoThick)
     noAtmosphericDensityAltitude = currentPlanetAtmoThick

     local function vectorLen(x,y,z)
      return math.sqrt(x * x + y * y + z * z)
     end
     local cWCOM = construct.getWorldCenterOfMass()
     local cWCOMx, cWCOMy, cWCOMz = cWCOM[1], cWCOM[2], cWCOM[3]
     local cPCx, cPCy, cPCz = currentPlanetCenter[1], currentPlanetCenter[2], currentPlanetCenter[3]
     alt = vectorLen(cWCOMx-cPCx, cWCOMy-cPCy, cWCOMz-cPCz) - planet.radius or 0

     atmosDensity = unit.getAtmosphereDensity()
     inspace = atmosDensity < 0.099 and 1 or 0
     inAtmo = false or (alt < noAtmosphericDensityAltitude and atmosDensity > 0.00001 )

     nearPlanet = unit.getClosestPlanetInfluence() > 0 or (alt > 0 and alt < 200000)

     MM = Nav:getMasterMode()
     coreMass = construct.getTotalMass()
     maxSafeVel = inAtmo and construct.getFrictionBurnSpeed() or unitData.maxSpeedMPS ~= nil and unitData.maxSpeedMPS or 900
    end

    function paramsSetColorsRange()
     for i, v in ipairs (P.MS) do
      if type(P.MS[v]) == "table" then
       if P.MS[v].value then
        if type( P.MS[v].value) == "string" and #P.MS[v].range == 0 then
         P.MS[v].range = webColors.namedColors
        end
       end
      end
     end
    end

    function checkWidgets()
     hideAllDefaultWidgets()
     -- SPEEDOMETER 
     if P.w_open == false then
      -- HUD
      if P.WS.w_hud.value == "None" then
       P.Widget_HUD.w_open = false
      else
       P.Widget_HUD.w_open = true
      end

      -- Platform
      if P.WS.w_platform.value == "None" then
       P.Widget_Platform.w_open = false
      else
       P.Widget_Platform.w_open = true
      end

      -- SPEEDO
      if P.WS.w_speedometer.value == "Default" then
       if unit then unit.showWidget() end
      end

      -- GYRO
      if P.WS.w_gyro.value == "Default" then
       if gyro then gyro.showWidget() end
      end

      -- FUEL
      if P.WS.w_fuel.value == "Default" then
       if atmofueltank then
        if atmofueltank_size > 0 then
         _autoconf.displayCategoryPanel(atmofueltank, atmofueltank_size, L_TEXT("ui_lua_w_atmofuel", "Atmo Fuel"), "fuel_container")
        end
       end
       if spacefueltank then
        if spacefueltank_size > 0 then
         _autoconf.displayCategoryPanel(spacefueltank, spacefueltank_size, L_TEXT("ui_lua_w_spacefuel", "Space Fuel"), "fuel_container")
        end
       end
       if rocketfueltank then
        if rocketfueltank_size > 0 then
         _autoconf.displayCategoryPanel(rocketfueltank, rocketfueltank_size, L_TEXT("ui_lua_w_rocketfuel", "Rocket Fuel"), "fuel_container")
        end
       end
      end

      -- CORE
      if (P.WS.w_core.value == "Default" and ALT == false) or (P.WS.w_core.value == "ALT" and ALT == true)then
       if core then core.showWidget() end
      end

      -- RADAR
      if (P.WS.w_radar.value == "Default" and ALT == false) or (P.WS.w_radar.value == "ALT" and ALT == true)then
       if #radar ~= 0 then
        _autoconf.displayCategoryPanel(radar, radar_size, L_TEXT("ui_lua_widget_radar", "Radar"), "radar")
       end
      end

      -- PERISCOPE
      if (P.WS.w_periscope.value == "Default" and ALT == false) or (P.WS.w_periscope.value == "ALT" and ALT == true)then
       if #radar ~= 0 then
        local rdr = radar_1.getOperationalState() == 1 and {radar_1} or {radar_2} or {radar_1}
        if rdr then _autoconf.displayCategoryPanel(rdr, 1, L_TEXT("ui_lua_w_periscope", "Periscope"), "periscope") end
       end
      end

      -- AGG
      if (P.WS.w_agg.value == "Default" and ALT == false) or (P.WS.w_agg.value == "ALT" and ALT == true)then
       if antigrav then antigrav.showWidget() end
      end

      -- WARP
      if (P.WS.w_warp.value == "Default" and ALT == false) or (P.WS.w_warp.value == "Auto" and warpData.Info:lower() == "activate warp") or (P.WS.w_warp.value == "ALT" and ALT == true)then
       if warpdrive then warpdrive.showWidget() end
      end

      -- PARENTING
      if (P.WS.w_parenting.value == "Default" and ALT == false) or (P.WS.w_parenting.value == "ALT" and ALT == true)then
       parentingPanelId = system.createWidgetPanel("Docking")
       parentingWidgetId = system.createWidget(parentingPanelId,"parenting")
       system.addDataToWidget(unit.getWidgetDataId(),parentingWidgetId)
      end

      -- COMBAT STRESS
      if (P.WS.w_cstress.value == "Default" and ALT == false) or (P.WS.w_cstress.value == "ALT" and ALT == true)then
       coreCombatStressPanelId = system.createWidgetPanel("Core combat stress")
       coreCombatStressgWidgetId = system.createWidget(coreCombatStressPanelId,"core_stress")
       system.addDataToWidget(core.getWidgetDataId(),coreCombatStressgWidgetId)
      end

      -- SHIELD
      if (P.WS.w_shield.value == "Default" and ALT == false) or (P.WS.w_shield.value == "ALT" and ALT == true) then
       if shield then shield.showWidget() end
      end

      -- HELP MENU
      if P.WS.HELP_MENU.value == "Open" or (P.WS.HELP_MENU.value == "ALT" and ALT == true) then
       P.help_menu.w_open = true
      else
       P.help_menu.w_open = false
      end

      for i, v in ipairs(P.Widgets_Custom) do
       if (P.Widgets_Custom["w_custom"..i].value == "Default --" and ALT == false) or (P.Widgets_Custom["w_custom"..i].value == "ALT" and ALT == true) then
        P["Widget_Custom"..i].w_open = true
       elseif P.Widgets_Custom["w_custom"..i].value == "None" or (P.Widgets_Custom["w_custom"..i].value == "ALT" and ALT == false) then
        P["Widget_Custom"..i].w_open = false
       end
      end
     end
    end

    function hideAllDefaultWidgets()
     if core then core.hideWidget() end
     if unit then unit.hideWidget() end
     if gyro then gyro.hideWidget() end
     if antigrav then antigrav.hideWidget() end
     if warpdrive then warpdrive.hideWidget() end
     if shield then shield.hideWidget() end
     _autoconf.hideCategoryPanels()
     system.destroyWidgetPanel(parentingPanelId)
     system.destroyWidgetPanel(coreCombatStressPanelId)
    end

    function windowsShow()
     system.lockView(1)
     player.freeze(1)
     WindowLib = WLP.init()
     checkWidgets()
     Cursor_Builder()
     Params_Menu_Builder()
     Help_Menu_Builder()
     Widgets_Builder()
     Quick_Menu_Builder()
    end

    function windowsHide()
     if P.KP.mvL.value == false then player.freeze(0) else player.freeze(1) end
     if P.KP.viL.value == false then system.lockView(0) else system.lockView(1) end
     WindowLib = WLP.init()
     checkWidgets()
     Params_Menu_Builder()
     Help_Menu_Builder()
     Widgets_Builder()
     Quick_Menu_Builder()
     Cursor_Builder()
    end

    function setParamsFuelTanks()
     for i, v in ipairs(fuelTanksData) do
      P["Widget_FuelTank_"..i] = {
       w_title = "FUEL TANK "..i,
       w_pos = {x=150+i*99, y=150},
       w_open = false,
       w_scale = 1.5
       }
     end
    end

    function enginesToggle()
     if P.ES.eng.value == "AUTO" then 
      if Engines == false then
       Engines = true
       pd("Engines ON")
      end
     elseif P.ES.eng.value == "OFF" and Engines == true then
      Engines = false
      pd("Engines OFF")
     elseif P.ES.eng.value == "ON" and Engines == false then
      Engines = true
      pd("Engines ON")
     end
    end

    function setControlMasterMode(mode)
     Nav:setMasterMode(mode)
     if mode ~= P.KP.flM.value then
      P.KP.flM.value = mode
      pd(mode.." mode set")
      updateEngines()
     end
    end

    colorPresets = {
     preset0 = {TC = "olive",
      TCA = 1,
      TTC = "black",
      WC = "dimgray",
      WCA = 0.9,
      WTC = "gold",
      BC = "navajowhite",
      BBC = "darkslategray",
      BCA = 0.4,
      BTC = "saddlebrown",
      wTC = "gold",
      wAC = "burlywood",
      WFC = "olive",
     },
     preset1 = {TC = "white",
      TCA = 1,
      TTC = "black",
      WC = "black",
      WCA = 0.4,
      WTC = "skyblue",
      BC = "white",
      BBC = "lightgray",
      BCA = 0.1,
      BTC = "white",
      wTC = "skyblue",
      wAC = "darkred",
      WFC = "white",
     },
     preset2 = {TC = "yellowgreen",
      TCA = 1,
      TTC = "black",
      WC = "dimgrey",
      WCA = 0.8,
      WTC = "greenyellow",
      BC = "lightgrey",
      BBC = "lightgrey",
      BCA = 0.3,
      BTC = "white",
      wTC = "greenyellow",
      wAC = "greenyellow",
      WFC = "lightgrey",
     },
     preset3 = {TC = "black",
      TCA = 0.5,
      TTC = "chartreuse",
      WC = "black",
      WCA = 0.1,
      WTC = "chartreuse",
      BC = "black",
      BBC = "chartreuse",
      BCA = 0.3,
      BTC = "chartreuse",
      wTC = "chartreuse",
      wAC = "chartreuse",
      WFC = "chartreuse",
     },
     preset4 = {TC = "darkorange",
      TCA = 0.6,
      TTC = "yellow",
      WC = "black",
      WCA = 0.5,
      WTC = "yellow",
      BC = "darkorange",
      BBC = "darkorange",
      BCA = 0.5,
      BTC = "yellow",
      wTC = "yellow",
      wAC = "yellow",
      WFC = "darkorange",
     },
     preset5 = {TC = "black",
      TCA = 0,
      TTC = "white",
      WC = "black",
      WCA = 0,
      WTC = "white",
      BC = "black",
      BBC = "white",
      BCA = 0,
      BTC = "white",
      wTC = "white",
      wAC = "white",
      WFC = "white",
     },
    }
    function saveColorPreset()
     for k, l in pairs(P.MS) do
      if type(l) == "table" and l.value ~= nil and type(l.value) == "string" and k ~= "PRESET" and k ~= "HELP_MENU" then
       colorPresets[previousPreset][k] = P.MS[k].value
      end
     end
     
    end

    function loadColorPreset()
     for k, l in pairs(P.MS) do
      if type(l) == "table" and l.value ~= nil and type(l.value) == "string" and k ~= "PRESET" and k ~= "HELP_MENU" then
       P.MS[k].value = colorPresets[P.MS.PRESET.value][k]
      end
     end
     previousPreset = P.MS.PRESET.value
    end

    function updateEngines()
    end

    function updateParams()
     setControlMasterMode(P.KP.flM.value)
     if Nav:getAtmoMaxSpeed() ~= P.ES.aMS.value and atmoSpeedLock == true then
      Nav:setAtmoMaxSpeed(P.ES.aMS.value)
     end
     updateGyro()
     Nav:updateAggHeight(0)
     saveColorPreset()
     loadColorPreset()
     unit.setTimer("SCREEN",P.WS.w_refresh.value)
     if P.KP.mvL.value == false then player.freeze(0) else player.freeze(1) end
     if P.KP.viL.value == false then system.lockView(0) else system.lockView(1) end
     Nav:buildPIDs()
    end

    function updateGyro()
     if gyro then
      if P.ES.gyr.value == "ON" and gyro.isActive() == false then gyro.activate()
      elseif P.ES.gyr.value == "OFF" and gyro.isActive() == true then gyro.deactivate()
      elseif P.ES.gyr.value == "CROSS" then
       if bCM and gyro.isActive() ~= true then 
        gyro.activate()
       elseif not bCM and gyro.isActive() == true then
        gyro.deactivate()
       end
      elseif P.ES.gyr.value == "SPACE AUTO" then
        if inspace == 1 and gyro.isActive() == false then gyro.activate()
        elseif inspace == 0 and gyro.isActive() == true then gyro.deactivate()
        end
      end
     elseif P.ES.gyr.value ~= "OFF" then
      P.ES.gyr.value = "OFF"
      p("No Gyro attached.")
     end
    end

    function updateGear()
     if hasGndDet then
      toggleLandingGearCheck() -- no flush
     end
    end

    function withinParkingRange()
     return hasGndDet and (Gnd.height < 100 or Gnd.ground < 100) and Gnd.height > 0
    end
    
    function setParkingMode(pm)
     pkM = pm == true and true or false 
     local mode = nil
     if pkM and P.KP.pkM.value ~= "OFF" then 
      mode = P.KP.pkM.value
     else
      mode = P.KP.flM.value
     end
     if mode ~= Nav:getMasterMode() then
      Nav:setMasterMode(mode)
     end
    end
    
    function parkingEligible()
      return P.KP.pkM.value ~= "OFF" and P.KP.flM.value ~= "PLATFORM" and P.KP.flM.value ~= "DRONE"
    end
    
    local lPx, lPy, lPz = 0,0,0
    function checkLanded()
     local dist = math.abs(vectorLen(cWPx, cWPy, cWPz) - vectorLen(lPx, lPy, lPz))
     if ArkTime - landTime > 0.5 
     and dist < 0.1 
     and accMag < 0.1 
     and Engines == true 
     then
      if P.ES.eng.value == "AUTO" then
       Engines = false
       autoLand = false
       updateEngines()
      elseif autoLand then
       pd("Auto Land Completed")
       autoLand = false
       updateEngines()
      end
      if P.AS.aSO.value == true then
       unit.exit()
      end
     elseif dist >= 0.1 then
      lPx, lPy, lPz = cWPx, cWPy, cWPz
      landTime = ArkTime
     else
      --
     end
    end

    function enableAutoLand()
     if autoLand then return end
     autoLand = true; autoStart = false
     pd('Auto landing mode activated')
     if hasGndDet == false then p("WARNING no telemeter detected! Crash landing") end
     landTime = ArkTime
    end

    function enableAutoStart()
     if autoStart then return end
     autoStart = true; autoLand = false
     autoStartTime = ArkTime
     pd('Auto start eng activated')
    end
    
    function toggleLandingGearCheck()
     if hasGndDet == false then -- no ground detection, manually toggle
      gearExtended = not gearExtended
      if gearExtended then
       unit.deployLandingGears()
      else
       unit.retractLandingGears()
      end
     else -- has ground detection, auto choose when
      local eligible = withinParkingRange() and not parkingModeLockOut and (velMag < 28 or autoLand)
      if eligible and not gearExtended then
       gearExtended = true
       unit.deployLandingGears()
      elseif not eligible and gearExtended then
       gearExtended = false
       unit.retractLandingGears()
      end
     end
    end

    function updateHelpMenu()
     local h1 = help.h1
     local h2 = help.h2
     local ls = help.ls
     local concat = table.concat
     local function updateHelpHTML(menu)
      local s = ''
      local nt = {}
      local ind = 0
      for i , v in ipairs(P[menu]) do
       if P[menu][i] ~= "separator" then
       local mn = '> '..P[menu][v].name .. ': '
        if(i == 1 or P[menu][i-1] == "separator") then
         s = h1 .. ls*2
        else
         s = h1 .. ls
        end

        if help[menu][v] and type(help[menu][v]) == 'table' then
         local b = {}
         local bi = 0
         for ii, iiv in ipairs(help[menu][v]) do
          local d = help[menu][v][ii]
          if d and type(d) == 'table' then
           for iii, iiiv in ipairs(d) do
            local dd = help[menu][v][ii][iii]
            if bi == 0 then
             bi = bi+1
             b[bi] = s .. '">' .. mn .. dd .. h2
            else
             bi = bi+1
             b[bi] = h1 .. ls .. '">' .. dd .. h2
            end
           end
          else
           if bi == 0 then
            bi = bi+1
            b[bi] = s .. '">' .. mn .. d .. h2
           else
            bi = bi+1
            b[bi] = h1 .. ls .. '">' .. d .. h2
           end
          end
         end
         ind = ind+1
         nt[ind] = concat(b)

        else
         if help[menu][v] then
          ind = ind+1
          nt[ind] = s .. '">' .. mn .. help[menu][v] .. h2
         end
        end
       end
      end
      local body = concat(nt)
      local tt = P[menu].w_title
      local bd = body:gsub("%%","{p}")
      local html = help.body:gsub("%%","{p}")
      :gsub("{tittle}",tt)
      :gsub("{body}",bd)
      return html
     end
     P.help_menu.Info_Page.html = help.info.body
     P.help_menu.MS.html = updateHelpHTML("MS")
     P.help_menu.ES.html = updateHelpHTML("ES")
     P.help_menu.AS.html = updateHelpHTML("AS")
     P.help_menu.KP.html = updateHelpHTML("KP")
     P.help_menu.WS.html = help.widgets.body
     P.help_menu.QuickToolBar.html = help.q.body
     P.help_menu.w_html = P.help_menu.Info_Page.html
    end

    local cos, sin, max, min = math.cos, math.sin, math.max, math.min
    local numP = ' *([+-]?%d+%.?%d*e?[+-]?%d*)'
    function convertToWorldCoordinates(posString)
     local posPattern = '::pos{'..numP..','..numP..','..numP..','..numP..','..numP..'}'
     local systemId, bodyId, latitude, longitude, altitude = string.match(posString,posPattern)
     systemId = tonumber(systemId)
     bodyId = tonumber(bodyId)
     latitude = tonumber(latitude)
     longitude = tonumber(longitude)
     altitude = tonumber(altitude)
     if tonumber(bodyId) == 0 then
      return latitude,longitude,altitude
     end
     latitude = 0.0174532925199 * max(min(latitude, 90), -90)
     longitude = 0.0174532925199 * (longitude % 360)
     local center, radius = Helios[bodyId].center, tonumber(Helios[bodyId].radius)
     local xproj = cos(latitude)
     local px, py, pz = center[1]+(radius+altitude) * xproj*cos(longitude),
          center[2]+(radius+altitude) * xproj*sin(longitude),
          center[3]+(radius+altitude) * sin(latitude)
     return px, py, pz
    end

    function extractAlt(altStr)
     local posPattern = 'alt'..numP
     local tAlt = tonumber(string.match(altStr,posPattern))
     return tAlt
    end

    function stringToTable(String, Separator)
     local Separator = Separator or ','
     local axes = {}
     for axis in String:gmatch('[^'..Separator..']+') do
      axes[#axes + 1] = axis
     end
     return axes
    end

    function mouseControlUpdate()
     system.lockView(1)
     if system.getMouseDeltaY() ~= 0 or previousDeltaY ~= 0 then 
      if MM ~= "DRONE" and MM ~= "PLATFORM" then --TODO make mouse Y work for drone
       local f = P.KP.mCI.value == false and 1 or -1
       pitchInput = system.getMouseDeltaY() * P.KP.mCS.value *-0.25 * f
       previousDeltaY = pitchInput
      end
     end
     if system.getMouseDeltaX() ~= 0 or previousDeltaX ~= 0 then 
      yawInput = system.getMouseDeltaX() * P.KP.mCS.value *-0.25
      previousDeltaX = yawInput
     end
    end

  onStart:
   lua: |
    local abs, floor, asin, sqrt, cos, acos, sin, deg, atan, rad, sign, clamp, rad2deg, max, ceil = math.abs, math.floor, math.asin, math.sqrt, math.cos, math.acos, math.sin, math.deg, math.atan, math.rad, utils.sign, utils.clamp, constants.rad2deg, math.max, math.ceil
    local C = construct
    -- Thrust Management library --
    function vectorLen(x,y,z)
     return sqrt(x*x+y*y+z*z)
    end
    
    function brakingCalculation()
     local MaxBrakesForce = C.getMaxBrake() or 0
     local maxSpeed = 50000*0.27777777777
     local cAV = C.getVelocity()
     local cAVx, cAVy, cAVz = cAV[1], cAV[2], cAV[3]
     local cWAV = C.getWorldAbsoluteVelocity()
     local velMag = sqrt(cAVx^2+cAVy^2+cAVz^2)
     local cM = C.getTotalMass()
     local forwardEnginesForce, backwardEnginesForce = Nav:getMaxKPA()
     local gravityV = core.getWorldGravity()
     local g = core.getGravityIntensity()
     local G_axis = -1*utils.sign(cWAV[1]*gravityV[1] + cWAV[2]*gravityV[2] + cWAV[3]*gravityV[3])
     local brakesAcceleration = MaxBrakesForce + g*G_axis * cM
     local forwardAcceleration = forwardEnginesForce + g*G_axis * cM
     local backwardAcceleration = backwardEnginesForce + g*G_axis * cM
     local forwardBrakeDistance = cM * maxSpeed^2 / (brakesAcceleration + backwardAcceleration/2) * (1 - sqrt(1 - ((velMag)^2 / maxSpeed^2)))
     local backburnBrakeDistance = cM * maxSpeed^2 / (brakesAcceleration + forwardAcceleration/2) * (1 - sqrt(1 - ((velMag)^2 / maxSpeed^2)))
     forwardBrakeDistance = forwardBrakeDistance == forwardBrakeDistance and xyzSpeedKPH > 70 and math.abs(forwardBrakeDistance) or 0
     backburnBrakeDistance = backburnBrakeDistance == backburnBrakeDistance and xyzSpeedKPH > 70 and math.abs(backburnBrakeDistance) or 0
     return forwardBrakeDistance, backburnBrakeDistance
    end

    function sf(s)
     return string.format("%.4f", s)
    end

    function norm(x,y,z)
     local l = sqrt(x*x + y*y + z*z)
     return x/l, y/l, z/l
    end

    function dotVec(x1,y1,z1,x2,y2,z2)
     return x1*x2 + y1*y2 + z1*z2
    end

    function multiplyVec(x,y,z,factor)
     return x*factor, y*factor, z*factor
    end
  
    local function world2local(x,y,z)
     local v = library.systemResolution3({cWORx, cWORy, cWORz},{cWOFx, cWOFy, cWOFz},{cWOUPx, cWOUPy, cWOUPz},{x,y,z})
     return v[1],v[2],v[3]
    end

    local function rotateVec(vx, vy, vz, phi, ax, ay, az)
     local l = sqrt(ax*ax + ay*ay + az*az)
     local ux, uy, uz = ax/l, ay/l, az/l
     local cs, s = cos(phi), sin(phi)
     local m1x, m1y, m1z = (cs + ux * ux * (1-cs)), (ux * uy * (1-cs) - uz * s), (ux * uz * (1-cs) + uy * s)
     local m2x, m2y, m2z = (uy * ux * (1-cs) + uz * s), (cs + uy * uy * (1-cs)), (uy * uz * (1-cs) - ux * s)
     local m3x, m3y, m3z = (uz * ux * (1-cs) - uy * s), (uz * uy * (1-cs) + ux * s), (cs + uz * uz * (1-cs))
     return m1x*vx+m1y*vy+m1z*vz, m2x*vx+m2y*vy+m2z*vz, m3x*vx+m3y*vy+m3z*vz
    end

    function cross(x, y, z, vx, vy, vz)
     return y*vz - z*vy, z*vx - x*vz, x*vy - y*vx
    end

    -- Rotations control --
    local function getConstructRot(x, y, z)
     if x == nil then x, y, z = -1,0,0 end
     x, y, z = norm(x,y,z)
     local CRx, CRy, CRz = cWORx, cWORy, cWORz
     local CUx, CUy, CUz = cWOUPx, cWOUPy, cWOUPz
     local cx, cy, cz = cross(x, y, z, CUx, CUy, CUz)
     local rAx, rAy, rAz = norm(cx, cy, cz)
     local ConstructRot = acos(clamp(dotVec(rAx, rAy, rAz,CRx, CRy, CRz), -1, 1)) * rad2deg
     cx, cy, cz = cross(rAx, rAy, rAz, CRx, CRy, CRz)
     if dotVec(cx, cy, cz, CUx, CUy, CUz) < 0 then ConstructRot = -ConstructRot end
     return ConstructRot
    end

    local function getConstructPitch(x, y, z)
     if x == nil then x, y, z = 0,0,1 end
     x, y, z = norm(x,y,z)
     local CRx, CRy, CRz = cWORx, cWORy, cWORz
     local CFx, CFy, CFz = cWOFx, cWOFy, cWOFz
     local cx, cy, cz = cross(x, y, z, CRx, CRy, CRz)
     local pAx, pAy, pAz = norm(cx, cy, cz)
     local ConstructPitch = acos(clamp(dotVec(pAx, pAy, pAz, CFx, CFy, CFz), -1, 1)) * rad2deg
     cx, cy, cz = cross(pAx, pAy, pAz, CFx, CFy, CFz)
     if dotVec(cx, cy, cz, CRx, CRy, CRz) < 0 then ConstructPitch = -ConstructPitch end
     return ConstructPitch
    end

    local function getConstructRoll(x,y,z)
     if x == nil then x, y, z = 0,0,1 end
     x, y, z = norm(x,y,z)
     local CRx, CRy, CRz = cWORx, cWORy, cWORz
     local CFx, CFy, CFz = -cWOFx, -cWOFy, -cWOFz
     local cx, cy, cz = cross(x, y, z, CFx, CFy, CFz)
     local rAx, rAy, rAz = norm(cx, cy, cz)
     local ConstructRoll = acos(clamp(dotVec(rAx, rAy, rAz, CRx, CRy, CRz), -1, 1)) * rad2deg
     cx, cy, cz = cross(rAx, rAy, rAz, CRx, CRy, CRz)
     if dotVec(cx, cy, cz, CFx, CFy, CFz) < 0 then ConstructRoll = -ConstructRoll end
     return ConstructRoll
    end
    
    local function getConstructRoll90(x,y,z) --for the auto yaw when pitch = 90
     if x == nil then x, y, z = 0,0,1 end
     x, y, z = norm(x,y,z)
     local CRx, CRy, CRz = cWORx, cWORy, cWORz
     local CUx, CUy, CUz = -cWOUPx, -cWOUPy, -cWOUPz
     local cx, cy, cz = cross(x, y, z, CUx, CUy, CUz)
     local rAx, rAy, rAz = norm(cx, cy, cz)
     local ConstructRoll = acos(clamp(dotVec(rAx, rAy, rAz, CRx, CRy, CRz), -1, 1)) * rad2deg
     cx, cy, cz = cross(rAx, rAy, rAz, CRx, CRy, CRz)
     if dotVec(cx, cy, cz, CUx, CUy, CUz) < 0 then ConstructRoll = -ConstructRoll end
     return ConstructRoll
    end

    local function rollAngularVelocity90(x,y,z, angle, speed)
     if x == nil then x, y, z = 0,0,1 end
     x, y, z = norm(x,y,z)
     local CUx, CUy, CUz = -cWOUPx, -cWOUPy, -cWOUPz
     if angle ~= 0 then x, y, z = rotateVec(x, y, z, rad(-angle), CUx, CUy, CUz) end
     local RollDeg = getConstructRoll90(x, y, z)
     if (RollPID90 == nil) then 
      RollPID90 = pid.new(0.05, 0, 1)
     end
     RollPID90:inject(0 - RollDeg)
     local PIDget = RollPID90:get()
     return PIDget * CUx * speed, PIDget * CUy * speed, PIDget * CUz * speed
    end

    local function rollAngularVelocity(x,y,z, angle, speed)
     if x == nil then x, y, z = 0,0,1 end
     x, y, z = norm(x,y,z)
     local CFx, CFy, CFz = -cWOFx, -cWOFy, -cWOFz
     if angle ~= 0 then x, y, z = rotateVec(x, y, z, rad(-angle), CFx, CFy, CFz) end
     local RollDeg = getConstructRoll(x, y, z)
     local PIDget = 0-RollDeg*0.05*speed
     return PIDget * CFx, PIDget * CFy, PIDget * CFz
    end

    local function pitchAngularVelocity(x,y,z, angle, speed)
     if x == nil then x, y, z = 0,0,1 end
     x, y, z = norm(x,y,z)
     local CRx, CRy, CRz = cWORx, cWORy, cWORz
     if angle ~= 0 then x, y, z = rotateVec(x, y, z, rad(-angle), CRx, CRy, CRz) end
     local PitchDeg = getConstructPitch(x, y, z)
     local PIDget = 0-PitchDeg*0.05*speed
     return PIDget * CRx, PIDget * CRy, PIDget * CRz
    end

    local function yawAngularVelocity(x,y,z, angle, speed)
     if x == nil then x, y, z = -1,0,0 end
     x, y, z = norm(x,y,z)
     local CUx, CUy, CUz = cWOUPx, cWOUPy, cWOUPz
     if angle ~= 0 then x, y, z = rotateVec(x, y, z, rad(angle), CUx, CUy, CUz) end
     local YawDeg = getConstructRot(x, y, z)
     local PIDget = 0-YawDeg*0.5*speed
     return PIDget * CUx, PIDget * CUy, PIDget * CUz
    end

    local function getAAR(ox, oy, oz, nx, ny, nz, px, py, pz)
     ox, oy, oz = norm(ox, oy, oz)
     nx, ny, nz = norm(nx, ny, nz)
     local ax, ay, az = cross(ox, oy, oz, nx, ny, nz)
     local axisLen = vectorLen(ax, ay, az)
     local angle = 0
     ax, ay, az = norm(ax, ay, az)
     if axisLen > 0.000001
     then
      angle = asin(clamp(axisLen, 0, 1))
     else
      ax, ay, az = px, py, pz
     end
     if dotVec(ox, oy, oz, nx, ny, nz) < 0
     then
      angle = math.pi - angle
     end
     return ax, ay, az, angle
    end

    function round(num, numDecimalPlaces)
     local mult = 10 ^ (numDecimalPlaces or 0)
     return floor(num * mult + 0.5) / mult
    end

    function fn(v) --fixNan
     return v~=v and 0 or v
    end

    local lastG = 0
    local lastVel = 0
    local function RefreshLastMaxBrake()
     local gravityR = round(gravityA, 5)
     local speedR = round(velMag)
     if lastG == nil or lastG ~= gravityR or lastVel ~= speedR then
      local maxBrake = C.getMaxBrake()
      if maxBrake ~= nil and maxBrake > 0 and inAtmo then 
       maxBrake = maxBrake / clamp(speedR/100, 0.1, 1) / atmosDensity
       if atmosDensity > 0.10 then 
        LastMaxBrakeInAtmo = maxBrake 
       end
      end
      if maxBrake ~= nil and maxBrake > 0 then
       LastMaxBrake = maxBrake
      end
      lastG = gravityR
      lastVel = speedR
     end
    end

    local pHD = 0 --previous
    function AboveGroundLevel()
     local function hoverDetectGround()
      local function getDist(e)
       local dist,max,d = -1,-1,-1
       if e then
        d,max = e.getDistance(), e.getMaxDistance()
        d = abs(d) < 0.01 and 0 or d -- round to 0
        if d == 0 and pHD ~= 0 then
         dist = pHD
        else
         dist = d
        end
        pHD = d
       end
       return dist,max
      end
      local vGndDist,vGndMax = getDist(vBooster)
      local hGndDist,hGndMax = getDist(hover)
      if vGndDist ~= -1 and hGndDist ~= -1 then
       if vGndDist < hGndDist then
        return vGndDist, math.max(vGndMax,hGndMax)
       else
        return hGndDist, math.max(vGndMax,hGndMax)
       end
      elseif vGndDist ~= -1 then
       return vGndDist, vGndMax
      elseif hGndDist ~= -1 then
       return hGndDist, hGndMax
      else
       return -1, math.max(vGndMax,hGndMax)
      end
     end
     local hovGndDet, hovGndMax = hoverDetectGround() 
     local grnd = {height=hovGndDet,max=hovGndMax,ground=hovGndDet,tel=-1}
     if telemeter then 
      grnd.tel = telemeter.raycast().distance
      if grnd.tel > 0 then grnd.height = grnd.tel end
     end
     return grnd
    end

    local lastApTickTime = system.getArkTime()
    local deltaTick = 0
    local brakingLastTime = lastApTickTime
    local brakingLastSpd = 0
    local brakingLastGnd = -1
    local landSpeed = -1
    local StopDistance = -1
    local minFallSpeed = -1

    function thrustManager()
     ArkTime = system.getArkTime()
     deltaTick = ArkTime - lastApTickTime
     lastApTickTime = ArkTime
     if deltaTick < 0.004 then return end

     -- Final inputs --
     local finalPitchInput = pitchInput + system.getControlDeviceForwardInput()
     local finalRollInput = rollInput + system.getControlDeviceYawInput()
     local finalYawInput = yawInput - system.getControlDeviceLeftRightInput()
     local finalRotationInput = finalPitchInput + finalRollInput + finalYawInput

     -- Globals --
     local cWOUP = C.getWorldOrientationUp()
     local cWOF = C.getWorldOrientationForward()
     local cWOR = C.getWorldOrientationRight()
     local cOUP = C.getOrientationUp()
     local cOF = C.getOrientationForward()
     local cOR = C.getOrientationRight()
     if bCM and gyro.isActive() == true then
      cWOUPx, cWOUPy, cWOUPz = cWOR[1], cWOR[2], cWOR[3]
      cWOFx, cWOFy, cWOFz = cWOF[1], cWOF[2], cWOF[3]
      cWORx, cWORy, cWORz = -cWOUP[1], -cWOUP[2], -cWOUP[3]
      --local
      cOUPx, cOUPy, cOUPz = cOR[1], cOR[2], cOR[3]
      cOFx, cOFy, cOFz = cOF[1], cOF[2], cOF[3]
      cORx, cORy, cORz = -cOUP[1], -cOUP[2], -cOUP[3]
     else
      cWOUPx, cWOUPy, cWOUPz = cWOUP[1], cWOUP[2], cWOUP[3]
      cWOFx, cWOFy, cWOFz = cWOF[1], cWOF[2], cWOF[3]
      cWORx, cWORy, cWORz = cWOR[1], cWOR[2], cWOR[3]
      --local
      cOUPx, cOUPy, cOUPz = cOUP[1], cOUP[2], cOUP[3]
      cOFx, cOFy, cOFz = cOF[1], cOF[2], cOF[3]
      cORx, cORy, cORz = cOR[1], cOR[2], cOR[3]
     end
     atmosDensity = unit.getAtmosphereDensity()
     gravityA = core.getGravityIntensity()

     -- Flush Variables --
     local cWP = C.getWorldPosition()
     cWPx, cWPy, cWPz = cWP[1], cWP[2], cWP[3]
     local cWCOM = C.getWorldCenterOfMass()
     local cWCOMx, cWCOMy, cWCOMz = cWCOM[1], cWCOM[2], cWCOM[3]
     local gravityV = core.getWorldGravity()
     local gx, gy, gz = gravityV[1], gravityV[2], gravityV[3]
     local cAV = C.getVelocity()
     local cAVx, cAVy, cAVz = cAV[1], cAV[2], cAV[3]
     local cWAV = C.getWorldVelocity()
     cWAVx, cWAVy, cWAVz = cWAV[1], cWAV[2], cWAV[3]
     local WAFA = C.getWorldAirFrictionAcceleration()
     local WAFAx, WAFAy, WAFAz = WAFA[1], WAFA[2], WAFA[3]
     local cWAngV = C.getWorldAngularVelocity()
     local cWAngVx, cWAngVy, cWAngVz = cWAngV[1], cWAngV[2], cWAngV[3]
     local wAFAA = C.getWorldAirFrictionAngularAcceleration()
     local wAFAAx, wAFAAy, wAFAAz = wAFAA[1], wAFAA[2], wAFAA[3]
     local cMAS = C.getMaxAngularSpeed()
     local cWA = C.getWorldAcceleration()

     local cPCx, cPCy, cPCz = currentPlanetCenter[1], currentPlanetCenter[2], currentPlanetCenter[3]
     wVx, wVy, wVz = cWCOMx-cPCx, cWCOMy-cPCy, cWCOMz-cPCz --world vertical
     local nwVx, nwVy, nwVz = norm(wVx, wVy, wVz) -- normalized
     gravity = dotVec(gx, gy, gz, nwVx, nwVy, nwVz)
     local cWAVDirx, cWAVDiry, cWAVDirz = norm(cWAVx,cWAVy,cWAVz)
     velMag = vectorLen(cAVx, cAVy, cAVz) --xyzSpeedMPS
     accMag = vectorLen(cWA[1], cWA[2], cWA[3])
     xyzSpeedKPH = velMag*3.6
     xSpeedKPH = dotVec(cWAVx, cWAVy, cWAVz, cWORx, cWORy, cWORz)*3.6
     ySpeedKPH = dotVec(cWAVx, cWAVy, cWAVz, cWOFx, cWOFy, cWOFz)*3.6
     zSpeedKPH = dotVec(cWAVx, cWAVy, cWAVz, cWOUPx, cWOUPy, cWOUPz)*3.6
     planetVertSpeedMPS = dotVec(cWAVx, cWAVy, cWAVz, nwVx, nwVy, nwVz)
     local planetLatSpeedMPS = sqrt(vectorLen(cWAVx, cWAVy, cWAVz)^2-planetVertSpeedMPS^2)
     alt = vectorLen(cWCOMx-cPCx, cWCOMy-cPCy, cWCOMz-cPCz) - planet.radius or 0
   
     Ax0 = 0 --pitch angle in deg
     Ay0 = 0 --roll angle in deg
     if alt < P.AS.stA.value then
      Ax0 = getConstructPitch(wVx, wVy, wVz)
      Ay0 = getConstructRoll(wVx, wVy, wVz)
     end

     Az = deg(atan(xSpeedKPH, ySpeedKPH)) -- drift rot angle in deg
     Ax = deg(atan(zSpeedKPH, ySpeedKPH)) -- drift pitch angle in deg

     ThrottlePos = (Nav:getThrottleValue() ~= nil) and Nav:getThrottleValue() or 0

     if type(AutoPilot) == 'table' and AutoPilot.enabled == true and type(applyShipInputs) == 'function' then 
      local _ = processPcall(pcall(function() return applyShipInputs() end))
      return nil
     end

     -- Gnd Detection --
     if hasGndDet then
      Gnd = AboveGroundLevel()

      -- Parking Mode --
      local noInputs = finalPitchInput==0 and finalRollInput==0 and finalYawInput==0 and upInput==0 and forwardInput==0 and not modeRocket and not autoLand

      if parkingEligible() and ThrottlePos == 0 then
       if withinParkingRange() and (xyzSpeedKPH < P.AS.aBS.value or pkM) and HoldAltitude == nil and alt < P.AS.stA.value then
        if not parkingModeLockOut and noInputs then
         setParkingMode(true)
        end
       else --not in range
        parkingModeLockOut = false
        if pkM and noInputs then Nav:prepareForFlight() end
       end
      else --not eligible
       parkingModeLockOut = false
       setParkingMode(false)
      end

      -- Turn on brakeCrossMode --
      if 
      P.ES.gyr.value == "CROSS" 
      and gyro 
      and Gnd.height < 100 and Gnd.height > 0
      and (autoLand or brakeInput > 0)
      then -- prerequisites for turning on bCM
       local downVel = dotVec(cWAVx,cWAVy,cWAVz,-cWOUPx,-cWOUPy,-cWOUPz)
       local limitB, limitT = approachSpeedZ > 0 and approachSpeedZ or 2, approachSpeedZ+10
       if downVel > limitT and downVel > 15 then
        bCM = true
       elseif bCM and downVel < limitB then
        bCM = false
       end
      elseif bCM then
       bCM = false
      end

      if (ArkTime - brakingLastTime > 0.5 or abs(brakingLastGnd - Gnd.height) > 2)then
       -- update approach speed based on stop distance --
       RefreshLastMaxBrake()
       local fUP = Nav:maxForceUp()*0.5
       local cOUP = {cOUPx, cOUPy, cOUPz}
       local maxKinematicGnd = C.getMaxThrustAlongAxis("ground", cOUP)[1]
       local gDist = Gnd.height > 0 and Gnd.height*clamp(P.AS.aLR.value-0.1,0.1,1) or hasATelemeter and 101 or Gnd.max > 0 and Gnd.max

       local delayDist = 0.1 * velMag
       local dist      = gDist-P.AS.grO.value-delayDist
       local final      = 0.1
       local mass      = coreMass
       local thrust     = fUP
       local hov   = maxKinematicGnd
       local hoverDist    = Gnd.max-P.AS.grO.value
       local maxBrakeForce  = LastMaxBrakeInAtmo
       local atmosDensity  = clamp(atmosDensity,0.4,2) --0.994
       local gravityA    = gravityA --9.8893
       local zAxis      = true
       approachSpeedZ = Kinematic.maxInitialVelocity(dist,final,mass,thrust,hov,hoverDist,maxBrakeForce,atmosDensity,gravityA,zAxis)
       if P.ES.gyr.value == "CROSS" then
        zAxis      = false
        approachSpeed = Kinematic.maxInitialVelocity(dist,final,mass,thrust,hov,hoverDist,maxBrakeForce,atmosDensity,gravityA,zAxis)
       end 
       local minSpd = 3
       landSpeed = P.ES.gyr.value == "CROSS" and approachSpeed > minSpd and -approachSpeed or approachSpeedZ > minSpd and -approachSpeedZ or -(minSpd+gDist*0.1)

       brakingLastTime = ArkTime
       brakingLastGnd = Gnd.height
      end
     else
      pkM = false
      approachSpeed = 0
      approachSpeedZ = 0
     end
     MM = Nav:getMasterMode()

     if Engines == true and fps > P.ES.fpP.value then
      fpsWarning = ""
      -- Starting Values
      local overRide = false
      local widgets_overRide = false
      local tAVx, tAVy, tAVz = 0,0,0
      local targetLongSpeed, targetLatSpeed, targetVertSpeed = 0,0,0
      local longAx, longAy, longAz = 0, 0, 0 --long acceleration
      local latAx, latAy, latAz = 0, 0, 0 --lat acceleration
      local vertAx, vertAy, vertAz = 0, 0, 0 --vert acceleration
      local longBx, longBy, longBz = 0, 0, 0 --long brake
      local latBx, latBy, latBz = 0, 0, 0 --lat brake
      local vertBx, vertBy, vertBz = 0, 0, 0 --vert brake
      local SBF = inspace == 1 and P.ES.spB.value or 1
      local LBF, lBF, vBF = P.ES.loB.value, P.ES.laB.value, P.ES.vtB.value
      local laDr = inspace == 0 and P.AS.lIF.value or P.AS.sAD.value
      local vDr = inspace == 0 and P.AS.vIF.value or P.AS.sAD.value
      local brakeAx, brakeAy, brakeAz = 0, 0, 0
      
      -- widgets complete thrust override
      for i, cWidget in ipairs(customWidgets) do
       if type(cWidget.flushOverRide) == 'function' and P["Widget_Custom"..i].w_open == true then
        local lo, la, ve, x, y, z = nil,nil,nil,nil,nil,nil
        local status, err = pcall(function () lo, la, ve, x, y, z = cWidget:flushOverRide() end)
        if not status then pd(err) end
        if lo ~= nil and la ~= nil and ve ~= nil and x ~= nil and y ~= nil and z ~= nil then
         tAVx, tAVy, tAVz = x, y, z
         targetLatSpeed = la
         targetLongSpeed = lo
         targetVertSpeed = ve
         widgets_overRide = true
         break
        end
       end
      end
      if widgets_overRide == false then
       if MM == "CRUISE" or MM == "TRAVEL" then
        -- Anti yaw stall --
        if P.AS.anS.value == true and abs(Az) > 35 and ySpeedKPH > 50 and ySpeedKPH > zSpeedKPH and inspace == 0 and abs(Ax0) < 30 and abs(Ay0) < 30 then
         finalYawInput = finalYawInput * -0.1
        end
       end
       
       if MM == "DRONE" then
        --P.AS.iAB.value = false
        P.KP.shL.value = false
       end      

       -- Control Keys Rotation --
       local pFact = finalPitchInput * cMAS * P.ES.pSF.value
       local rFact = finalRollInput * cMAS * P.ES.rSF.value
       local yFact = finalYawInput  * cMAS * P.ES.ySF.value
       if MM == "DRONE" and modeRocket == true then
        tAVx = rFact * cWOFx + yFact * -cWOFx
        tAVy = rFact * cWOFy + yFact * -cWOFy
        tAVz = rFact * cWOFz + yFact * -cWOFz
       elseif MM == "DRONE" and modeRocket == false then
        tAVx = yFact * cWOUPx
        tAVy = yFact * cWOUPy
        tAVz = yFact * cWOUPz
       else
        tAVx = pFact * cWORx + rFact * cWOFx + yFact * cWOUPx
        tAVy = pFact * cWORy + rFact * cWOFy + yFact * cWOUPy
        tAVz = pFact * cWORz + rFact * cWOFz + yFact * cWOUPz
       end

       -- THRUST COMPOSER --
       local strafeSpeed = unitData.maxSpeedkph
       local strafeStep = clamp(100,0,strafeSpeed)

       -- Auto Rotations --
       if autoLand == true and MM ~= "DRONE"then
        local rAVx, rAVy, rAVz = rollAngularVelocity(wVx, wVy, wVz, 0, P.ES.rSF.value)
        local pAVx, pAVy, pAVz = pitchAngularVelocity(wVx, wVy, wVz, 0 , P.ES.pSF.value)
        tAVx = tAVx + pAVx + rAVx
        tAVy = tAVy + pAVy + rAVy
        tAVz = tAVz + pAVz + rAVz
       elseif MM == "CRUISE" or MM == "TRAVEL" then
        -- Pitch and roll stabilization
        if alt < P.AS.stA.value then
         if P.AS.auR.value == true 
          and abs(Ay0 + P.ES.rAd.value*-1) > 0.25
          and finalRollInput == 0 and abs(Ax0) < 30
          and turnAssist_toggle == false
          and abs(Ay0 + P.ES.rAd.value) < P.AS.tAR.value then
          local rAVx, rAVy, rAVz = rollAngularVelocity(wVx, wVy, wVz, 0 - P.ES.rAd.value, P.ES.rSF.value)
          tAVx = tAVx + rAVx
          tAVy = tAVy + rAVy
          tAVz = tAVz + rAVz
         end
         if HoldAltitude ~= nil then
          VStabAltLock = floor(HoldAltitude)
          local pitchOffset = clamp(((alt - HoldAltitude)+(planetVertSpeedMPS*4))*0.05,-30,30)
          local pAVx, pAVy, pAVz = pitchAngularVelocity(wVx, wVy, wVz, pitchOffset + P.ES.pAd.value, P.ES.pSF.value)
          tAVx = tAVx + pAVx
          tAVy = tAVy + pAVy
          tAVz = tAVz + pAVz
         elseif P.AS.auP.value == true 
          and abs(Ax0) < (P.AS.aPA.value + abs(P.ES.pAd.value))
          and finalPitchInput == 0 
          and upInput == 0 
          and turnAssist_toggle == false
          and abs(Ax0) < 45 
          and abs(Ay0) < 10
          then

          -- auP alt Stabilization
          if xyzSpeedKPH > 250 and P.AS.atS.value == true then
           if VStabAltLock == nil and abs(Ax0) < 0.05 then 
            VStabAltLock = floor(alt)
            pd("Altitude locked at: "..VStabAltLock)
           end
          else VStabAltLock = nil
          end
          local pAVx, pAVy, pAVz = pitchAngularVelocity(wVx, wVy, wVz, 0 + P.ES.pAd.value, P.ES.pSF.value)
          tAVx = tAVx + pAVx
          tAVy = tAVy + pAVy
          tAVz = tAVz + pAVz
         else if VStabAltLock ~= nil then VStabAltLock = nil pd("Pitch stabilisation unlocked") end
         end

         -- Turn assist
         if P.AS.tuA.value == true 
          and abs(Ay0) > P.AS.tAR.value
          and abs(Ax0) < P.AS.tAP.value
          and finalPitchInput == 0
          and finalYawInput == 0
          and finalRollInput == 0
          and inspace == 0 
          then
          turnAssist_toggle = true
          if (TApitchPID == nil) then 
           TApitchPID = pid.new(0.2, 0, 10)
          end
          TApitchPID:inject(0 - Ax0)
          local PIDget = TApitchPID:get()
          local pAAx, pAAy, pAAz = PIDget * cWORx, PIDget * cWORy, PIDget * cWORz
          --targetAngularVelocity = cWOUP * 0.25 * sign(Ay0) * -1 + pitchAngularAcceleraion
          tAVx = cWOUPx * 0.25 * sign(Ay0) + pAAx
          tAVy = cWOUPy * 0.25 * sign(Ay0) + pAAy
          tAVz = cWOUPz * 0.25 * sign(Ay0) + pAAz
         else turnAssist_toggle = false
         end
        end

        -- BackBurn --
        if finalYawInput == 0 and finalPitchInput == 0 and finalRollInput == 0
         and (DTK == "brake" or BackBurnToggle == true) then
         local SBBMinimumSpeed = 1000
         if MM ~= "CRUISE" then
          PreviousMasterMode = "TRAVEL"
          Nav:setMasterMode("CRUISE")
         end
         -- Space BackBurn --
         if xyzSpeedKPH > SBBMinimumSpeed and not inAtmo then 
          BackBurnToggle = true
          if Az == 0 then
           finalYawInput = 1
          else
           local axx, axy, axz, an = getAAR(-1*cWOFx, -1*cWOFy, -1*cWOFz, cWAVx, cWAVy, cWAVz, 0, 0, 0)
           if (BBPID == nil) then
            BBPID = pid.new(0.2, 0, 10)
           end
           BBPID:inject(an)
           local PIDget = BBPID:get()
           tAVx = axx * PIDget
           tAVy = axy * PIDget
           tAVz = axz * PIDget
           ThrottlePos = 0
           oWVx, oWVy, oWVz = cWAVx, cWAVy, cWAVz
          end
         -- Continue BackBurn --
         elseif (DTK == "" and BackBurnToggle == true) or (xyzSpeedKPH < SBBMinimumSpeed and BackBurnToggle == true) then
          local axx, axy, axz, an = getAAR(cWOFx, cWOFy, cWOFz, oWVx, oWVy, oWVz, 0,0,0)
          if (BBPID == nil) then
           BBPID = pid.new(0.2, 0, 10)
          end
          BBPID:inject(an)
          local PIDget = BBPID:get()
          tAVx = axx * PIDget
          tAVy = axy * PIDget
          tAVz = axz * PIDget
          ThrottlePos = 0
         end
        elseif (finalYawInput ~= 0 or finalPitchInput ~= 0 or finalRollInput ~= 0 or DTK ~= "brake")
         and BackBurnToggle == true then
         BackBurnToggle = false
         if PreviousMasterMode == "TRAVEL" then 
          Nav:setMasterMode("TRAVEL") 
         end
         ThrottlePos = 0
         Nav:resetThrottleValue()
        end

        -- Prograde --
        if not inAtmo 
         and finalRotationInput == 0
         and BackBurnToggle == false
         and P.AS.aPG.value == true
         and xyzSpeedKPH > 200
         then
         local axx, axy, axz, an = getAAR(cWOFx, cWOFy, cWOFz, cWAVx, cWAVy, cWAVz, 0, 0, 0)
         if (APGPID == nil) then
          APGPID = pid.new(0.05, 0, 1)
         end
         APGPID:inject(an)
         local PIDget = APGPID:get()
         tAVx = axx * PIDget
         tAVy = axy * PIDget
         tAVz = axz * PIDget
        end
       elseif MM == "PLATFORM" and alt < P.AS.stA.value then
        --Roll stabilisation
        local autoRollRollThreshold = 0.1
        if abs(Ay0) > autoRollRollThreshold then
         local rAVx, rAVy, rAVz = rollAngularVelocity(wVx, wVy, wVz, 0 - P.ES.rAd.value, P.ES.rSF.value)
         tAVx = tAVx + rAVx
         tAVy = tAVy + rAVy
         tAVz = tAVz + rAVz
        end

        --Pitch stabilisation
        local aPA = 90
        if abs(Ax0) < aPA then
         local pAVx, pAVy, pAVz = pitchAngularVelocity(wVx, wVy, wVz, 0 + P.ES.pAd.value, P.ES.pSF.value)
         tAVx = tAVx + pAVx
         tAVy = tAVy + pAVy
         tAVz = tAVz + pAVz
        end
       elseif MM == "DRONE" and modeRocket == true then
        local pitchOffset = 90 + (-upInput * 30)
        if upInput ~= 0 then
        else
         if not prevAltHoldAng then prevAltHoldAng = -4.8 end
         local aAdj = prevAltHoldAng
         if xyzSpeedKPH > 100 and HoldAltitude ~= nil then
          VStabAltLock = floor(HoldAltitude)
          if abs(alt - HoldAltitude) < 50 then aAdj = prevAltHoldAng + clamp(planetVertSpeedMPS,-1,1)/1000 end
          VStabAltLock = floor(HoldAltitude)
          pitchOffset = pitchOffset + clamp(((alt - HoldAltitude)+(planetVertSpeedMPS*4))*0.05,-30,30) + aAdj
         else
          aAdj = prevAltHoldAng + clamp(planetVertSpeedMPS,-1,1)/1000
          pitchOffset = pitchOffset + clamp(planetVertSpeedMPS/10,-30,30) + aAdj
         end
         prevAltHoldAng = aAdj
        end

        local pAVx, pAVy, pAVz = pitchAngularVelocity(wVx, wVy, wVz, pitchOffset + P.ES.pAd.value, P.ES.pSF.value*0.5)
        tAVx = tAVx + pAVx
        tAVy = tAVy + pAVy
        tAVz = tAVz + pAVz
       
        if Ax0 < -45 and Ax0 > -135 then --auto yaw (roll) to stay flat
         local rAVx, rAVy, rAVz = rollAngularVelocity90(wVx, wVy, wVz, 0, 1)
         tAVx = tAVx + rAVx
         tAVy = tAVy + rAVy
         tAVz = tAVz + rAVz
        end
       elseif MM == "DRONE" and modeRocket == false then
        -- BackBurn --
        if finalYawInput == 0 and finalPitchInput == 0 and finalRollInput == 0 and upInput <= 0 and HoldAltitude == nil
         and P.AS.bBu.value == true 
         then
       
         local axx, axy, axz, an = 0,0,0,0
         local nwVx, nwVy, nwVz = norm(wVx, wVy, wVz) -- normalized world vector (negative grav.)
         local ncWAVx, ncWAVy, ncWAVz = norm(cWAVx, cWAVy, cWAVz)
         local vAngle = acos(dotVec(ncWAVx, ncWAVy, ncWAVz, nwVx, nwVy, nwVz) / (vectorLen(ncWAVx, ncWAVy, ncWAVz) * vectorLen(nwVx, nwVy, nwVz)))*rad2deg
         if vAngle < 15 and planetVertSpeedMPS > 9 then 
          local ux, uy, uz = multiplyVec(-gx,-gy,-gz,1)
          axx, axy, axz, an = getAAR(cWOUPx, cWOUPy, cWOUPz, cWAVx+ux, cWAVy+uy, cWAVz+uz, 0, 0, 0)
         else
          local ux, uy, uz = multiplyVec(gx,gy,gz,1.8)
          axx, axy, axz, an = getAAR(-cWOUPx, -cWOUPy, -cWOUPz, cWAVx+ux, cWAVy+uy, cWAVz+uz, 0, 0, 0)
         end
         local aFact = clamp(an*rad2deg/40,-1,1) -- 40 = less sensitive
         tAVx = axx * aFact
         tAVy = axy * aFact
         tAVz = axz * aFact
       
        else
         -- Stabilization & Drone Rolling --
         local angF = SHIFT == true and P.ES.dSA.value or P.ES.dCA.value
         local fRI = 1 * sign(rollInput)
         local fPI = 1 * sign(pitchInput)
         local rAVx, rAVy, rAVz = rollAngularVelocity(wVx, wVy, wVz, 0 + fRI * angF, P.ES.rSF.value)
         local pAVx, pAVy, pAVz = pitchAngularVelocity(wVx, wVy, wVz, 0 - fPI * angF , P.ES.pSF.value)
         tAVx = tAVx + pAVx + rAVx
         tAVy = tAVy + pAVy + rAVy
         tAVz = tAVz + pAVz + rAVz
        end
       end

       -- Longitudinal Translation
       if MM == "PLATFORM" then 
        if pkM then
         if SHIFT == false then 
          strafeSpeed = P.KP.pMS.value
          strafeStep = clamp(100,0,strafeSpeed)
          targetLongSpeed = forwardInput * P.KP.pMS.value
         else
          targetLongSpeed = forwardInput * unitData.maxSpeedkph
         end
        else
         if modeRocket == true then 
          targetLongSpeed = unitData.maxSpeedkph
         else
          targetLongSpeed = forwardInput * unitData.maxSpeedkph
         end
        end
       end

       if MM == "CRUISE" or MM == "TRAVEL" or MM == "PLATFORM" then
        -- Auto Orbit Speed --
        --TODO make orbiting possible for platform mode? and drone Mode?
        if P.AS.atS.value == true and P.AS.aOS.value == true and not inAtmo and ThrottlePos ~= 0 and VStabAltLock ~= nil then
         ThrottlePos = sqrt(currentPlanetGM / (alt + planet.radius))*3.6
        end
       
        if xyzSpeedKPH > 10000 then
         if strafeInput == 0 then
          targetLatSpeed = xSpeedKPH
         end
         if upInput == 0 then
          targetVertSpeed = zSpeedKPH
         end
        else
         local rV = dotVec(cWORx,cWORy,cWORz,cWAVx,cWAVy,cWAVz)*3.6 --right vel
         if abs(rV) < 0.1 or sign(strafeInput) ~= sign(rV) then rV = 0 end
         local uV = dotVec(cWOUPx,cWOUPy,cWOUPz,cWAVx,cWAVy,cWAVz)*3.6 -- up vel
         if abs(uV) < 0.1 or sign(upInput) ~= sign(uV) then uV = 0 end
         targetLatSpeed = clamp(rV + strafeInput*strafeStep,-strafeSpeed,strafeSpeed)
         local extraVertSpeed = MM == "PLATFORM" and HoldAltitude and (HoldAltitude - alt)/1*3.6 or 0
         targetVertSpeed = VStabAltLock ~= nil and VStabAltLock-alt or clamp(uV + upInput*strafeStep + extraVertSpeed,-strafeSpeed,strafeSpeed)
        end
       elseif MM == "DRONE" and modeRocket == true then
        if abs(Ax0) > 85 then rocketWarmup = false end
        if rocketWarmup then
         targetVertSpeed = Nav:burnMaxSpd() * (abs(Ax0)/90)
        else
         targetVertSpeed = Nav:burnMaxSpd()
        end
       elseif MM == "DRONE" and modeRocket == false then
        local wLx, wLy, wLz = cross(nwVx, nwVy, nwVz, cWOUPx, cWOUPy, cWOUPz) -- world left
        local wFx, wFy, wFz = norm(cross(-nwVx, -nwVy, -nwVz, wLx, wLy, wLz)) -- world forward (forward perpendicular to grav.)
        local cFx, cFy, cFz = norm(cross(wLx, wLy, wLz, cWOUPx, cWOUPy, cWOUPz)) -- C forward

        local fGA = dotVec(gx, gy, gz, cFx, cFy, cFz) -- forward grav. acceleration (my forward engine)
        local fAirA = dotVec(WAFAx, WAFAy, WAFAz, cFx, cFy, cFz) -- forward air resistance acceleration
        local fTotA = fGA + fAirA -- forward total acceleration
        local fS = dotVec(cWAVx, cWAVy, cWAVz, cFx, cFy, cFz) -- forward speed

        -- Angle from world vertical (radians)
        local fAngle = acos(dotVec(cWOUPx, cWOUPy, cWOUPz, nwVx, nwVy, nwVz) / (vectorLen(cWOUPx, cWOUPy, cWOUPz) * vectorLen(nwVx, nwVy, nwVz)))
        local adjacent = fTotA + fS
        local hyp = adjacent/math.cos(fAngle)
        local tVx, tVy, tVz = multiplyVec(wFx, wFy, wFz, hyp) -- scale to max grav. thrust

        -- Downinput shifts vector down
        local downInput = upInput < 0 and abs(upInput) or 0 -- downInput
        local dVx, dVy, dVz = multiplyVec(-nwVx, -nwVy, -nwVz, downInput*(abs(planetVertSpeedMPS)+hyp+50))
        local tVx, tVy, tVz = tVx+dVx, tVy+dVy, tVz+dVz -- add downinput vector

        -- Convert back to local coords
        local tLVx, tLVy, tLVz = world2local(tVx, tVy, tVz)
        targetLatSpeed, targetLongSpeed, targetVertSpeed = multiplyVec(tLVx, tLVy, tLVz, 3.6) -- convert to kph

        -- MODIFIERS --
        local ncWAVx, ncWAVy, ncWAVz = norm(cWAVx, cWAVy, cWAVz)
        local VvsNZang = acos(dotVec(-cWOUPx, -cWOUPy, -cWOUPz, ncWAVx, ncWAVy, ncWAVz) / (vectorLen(-cWOUPx, -cWOUPy, -cWOUPz) * vectorLen(ncWAVx, ncWAVy, ncWAVz)))*rad2deg
        --angle between velocity vector and -z axis (when to brake)
        if brakeInput == 1 
         or finalYawInput == 0 and finalPitchInput == 0 and finalRollInput == 0 and upInput == 0 and (
          VvsNZang < 95 or VvsNZang > 165 or xyzSpeedKPH < 0.01
         )
        then
         targetLatSpeed, targetLongSpeed, targetVertSpeed = 0,0,0
        end

        --TODO Remove this
        local targetForwardSpeed = dotVec(tVx, tVy, tVz, cFx, cFy, cFz)
        local targetForwardAcceleration = targetForwardSpeed - fS
        local forwardRemainingAcceleration = fTotA - targetForwardAcceleration
       
        -- only up, not down input --
        local extraVertSpeed = upInput > 0 and upInput*strafeSpeed or HoldAltitude and (HoldAltitude - alt)/4*3.6 or 0
        targetVertSpeed = targetVertSpeed + extraVertSpeed
       end

       --local overRide = false
       if autoLand == true then
        if MM ~= "DRONE" then
         overRide = true
         targetLongSpeed = 0
         ThrottlePos = 0
         Nav:resetThrottleValue()
         Nav:setThrottleValue(0)
         targetLatSpeed = 0
        end

        local minSpd = 3
        -- Calculate Approach Speed --
        if hasGndDet == false then 
         targetVertSpeed = -20 -- crash landing
        else
         if Gnd.height > 0 then --I sense the ground
          if Gnd.height < P.AS.grO.value then -- close
           targetVertSpeed = -minSpd*3.6 * P.AS.aLR.value
          else -- ratio of distance left
           targetVertSpeed = landSpeed * 0.9 * 3.6 * P.AS.aLR.value
          end
         else -- can't detect the ground
          if alt - currentPlanetMaxStatic > 1000 then --accelerate
           targetVertSpeed = -Nav:burnMaxSpd()
          else
           targetVertSpeed = landSpeed * 3.6 * P.AS.aLR.value
          end
         end
        end
        checkLanded()-- turn off Engines when stopped
       elseif autoStart == true then
        overRide = true
        targetLongSpeed = 0
        ThrottlePos = 0
        Nav:resetThrottleValue()
        Nav:setThrottleValue(0)
        targetLatSpeed = 0
        if ArkTime - autoStartTime < 3 then
         targetVertSpeed = 10
        else
         autoStart = false
        end
       end

       if MM == "DRONE" or MM == "PLATFORM" then 
        --ThrottlePos = targetLongSpeed --TODO Change this to better represent target speed
       elseif MM == "TRAVEL" or MM == "CRUISE" then 
        targetLongSpeed = ThrottlePos
       end
      end

      -- Brake Module --
      local hold = false -- Hold Position, No inputs
      if finalPitchInput==0 and finalRollInput==0 and strafeInput==0 and upInput==0 and forwardInput==0 and not modeRocket and not autoLand and ThrottlePos == 0 
      and xyzSpeedKPH < 1 and (HoldAltitude == nil or HoldAltitude and abs(HoldAltitude-alt) < 1)
      then hold = true end

      local b = {la=targetLatSpeed,lo=targetLongSpeed,v=targetVertSpeed,dLa=1,dv=1} --brake matrix

      if brakeInput > 0 or hold then 
       b.la, b.lo, b.v = 0,0,0
      elseif autoLand then
      elseif widgets_overRide == false then
       if P.AS.iAB.value == false then --drift braking turned off
        if MM == "DRONE" and modeRocket == true then
         -- rocket braking slows down max speed
         b.la=nil;b.lo=nil;b.v=nil
        elseif MM == "DRONE" and modeRocket == false then
         local inputs = finalPitchInput~=0 or finalRollInput~=0
         -- drone braking messes up turning
         if inputs then b.la=nil;b.lo=nil;b.v=nil end
        elseif MM == "TRAVEL" then
         b.la=nil;b.v=nil
         if xyzSpeedKPH > P.AS.aBS.value or ThrottlePos ~= 0 then
          b.lo=nil
         end 
        elseif MM == "CRUISE" or widgets_overRide == true then
         b.la=nil;b.v=nil
        elseif MM == "PLATFORM" then
         if xyzSpeedKPH > P.AS.aBS.value then --faster than autoBrakeSpeed
          b.la=nil;b.lo=nil;b.v=nil
         end
        elseif overRide == true then
         --TODO fix this?
         b.la=nil;b.lo=nil;b.v=nil
        end
       elseif P.AS.iAB.value == true then  --inertia dampening
        if MM == "TRAVEL" or MM == "CRUISE" or MM == "PLATFORM" or widgets_overRide == true then
         -- TODO Jeronimo added this, keep following line?
         b.la, b.v = -xSpeedKPH*P.AS.iAI.value, -zSpeedKPH*P.AS.iAI.value
         if clamp(abs(Az),0,179.9) < laDr then b.la=nil end
         if clamp(abs(Ax),0,179.9) < vDr then b.v=nil end
         --TODO fix this below
         if ySpeedKPH < targetLongSpeed or (MM == "TRAVEL" and (ySpeedKPH > P.AS.aBS.value or ThrottlePos ~= 0)) then
          b.lo=nil
         end
        end
       end
      end
      local b_input = v_boosterInput + boosterInput
      if b_input == 0 or (b_input >= 1 and inspace == 0 and P.AS.rMS.value > 0 and xyzSpeedKPH < P.AS.rMS.value) then
       if b.la ~= nil then latBx, latBy, latBz = Nav:composeBrakeAcceleration("lateral",b.la) end
       if b.lo ~= nil then longBx, longBy, longBz = Nav:composeBrakeAcceleration("longitudinal",b.lo) end
       if b.v ~= nil then vertBx, vertBy, vertBz = Nav:composeBrakeAcceleration("vertical",b.v) end
      end
      brakeAx = longBx*LBF*SBF + latBx*lBF*SBF*b.dLa + vertBx*vBF*SBF*b.dv
      brakeAy = longBy*LBF*SBF + latBy*lBF*SBF*b.dLa + vertBy*vBF*SBF*b.dv
      brakeAz = longBz*LBF*SBF + latBz*lBF*SBF*b.dLa + vertBz*vBF*SBF*b.dv

      local maxSpeed = Nav:burnMaxSpd()
      local diff = maxSpeed > 0 and (maxSpeed-xyzSpeedKPH+4) or 0
      if inAtmo and diff < 0 and brakeInput == 0 then
       local bx,by,bz = norm(cWAVx, cWAVy, cWAVz)
       brakeAx, brakeAy, brakeAz = multiplyVec(bx,by,bz,diff*1)
      end
      BrakeAcc = {brakeAx, brakeAy, brakeAz}

      -- Torque
      local vF = 500/(deltaTick*1000) -- 2 frames per sampling resolution
      local aVCF = P.ES.anD.value
      if finalYawInput ~= 0 or finalPitchInput ~= 0 or finalRollInput ~= 0 then aVCF = 1 end
      if (tAVxPID == nil) then tAVxPID = pid.new(1,0,0) end --cMAS*1.2,0.02,2*aVCF
      tAVxPID:inject((tAVx - cWAngVx)*vF*aVCF - wAFAAx)
      if (tAVyPID == nil) then tAVyPID = pid.new(1,0,0) end
      tAVyPID:inject((tAVy - cWAngVy)*vF*aVCF - wAFAAy)
      if (tAVzPID == nil) then tAVzPID = pid.new(1,0,0) end
      tAVzPID:inject((tAVz - cWAngVz)*vF*aVCF - wAFAAz)
      local angAccelx = tAVxPID:get()
      local angAccely = tAVyPID:get()
      local angAccelz = tAVzPID:get()
      unit.setEngineCommand('torque', {0,0,0}, {angAccelx, angAccely, angAccelz}, 1, 1, '', '', '', 1)

      -- Thrust
      if MM == "TRAVEL" and overRide == false and widgets_overRide == false then
       longAx, longAy, longAz = Nav:composeAccelerationFromThrottle()
      else
       longAx, longAy, longAz = Nav:composeAccelerationFromTargetSpeed("longitudinal",targetLongSpeed)
      end
      latAx, latAy, latAz = Nav:composeAccelerationFromTargetSpeed("lateral",targetLatSpeed)
      
      --New experiemental hover height management
      if hasGndDet and withinParkingRange() and upInput == 0 and P.ES.hov.value == "ON" and MM ~= "DRONE" and overRide == false and autoLand == false then
       if P.ES.hoM.value == "STATIC" or (P.ES.hoM.value == "AUTO" and (Gnd.ground > 0 and Gnd.ground or Gnd.height) < P.ES.hoA.value) then
        targetVertSpeed = (Gnd.ground > 0 or Gnd.ground == -1) and Gnd.height > 0 and (P.ES.hoA.value - (Gnd.ground > 0 and Gnd.ground or Gnd.height))*P.ES.hoS.value or targetVertSpeed
       end
      end
      vertAx, vertAy, vertAz = Nav:composeAccelerationFromTargetSpeed("vertical",targetVertSpeed)
      TargetSpeed = {targetLatSpeed,targetLongSpeed,targetVertSpeed}
      
      local allx,ally,allz = longAx + latAx + vertAx, longAy + latAy + vertAy, longAz + latAz + vertAz
      if inspace == 1 and hold then allx,ally,allz = 0, 0, 0 end
      ThrustAcc = {allx,ally,allz}
      
      -- Thrust Composer
      local combinedBrake = false
      if autoLand and xyzSpeedKPH > 50 and Gnd.height < 0 
      or MM == "DRONE" and modeRocket == false and HoldAltitude
      then
       combinedBrake = true
      end
      local tags = "airfoil,not_ground thrust"
      if P.ES.hov.value == "ON" then
       tags = tags..",ground"
      else
       unit.setEngineCommand("ground", {0,0,0}, {0,0,0}, 0, 1, '', '', '', 1)
      end
      if combinedBrake then 
       tags = tags .. ",brake"
      else
       unit.setEngineCommand('brake', BrakeAcc, {0,0,0}, 0, 1, '', '', '', 1)
      end
      unit.setEngineCommand(tags, ThrustAcc, {0,0,0}, 0, 1, 'brake, airfoil', 'hover_engine', 'eco', 0)
      
      if system.getArkTime() - boosterTime > 0.3 then
       --not sure can set 2 setEngineThrust in one tick
       unit.setEngineThrust('v_rocket', (v_boosterInput == 1 and (inspace == 1 or (inspace == 0 and P.AS.rMS.value > 0 and xyzSpeedKPH < P.AS.rMS.value))) and 1 or 0)
       unit.setEngineThrust('rocket', (boosterInput == 1 and (inspace == 1 or (inspace == 0 and P.AS.rMS.value > 0 and xyzSpeedKPH < P.AS.rMS.value))) and 1 or 0)
       boosterTime = system.getArkTime()
      end
     elseif Engines == false or P.ES.fpP.value > 0 then
      fpsWarning = Engines == true and 'Low FPS detected, flush protection engaged, please standby!' or ''
      unit.setEngineCommand('thrust, torque', {0,0,0}, {0, 0, 0}, 1, 1, '', '', '', 1)
      local longBx, longBy, longBz = Nav:composeBrakeAcceleration("longitudinal",0)
      local latBx, latBy, latBz = Nav:composeBrakeAcceleration("lateral",0)
      local vertBx, vertBy, vertBz = Nav:composeBrakeAcceleration("vertical",0)
      local brakeAx, brakeAy, brakeAz = longBx + latBx + vertBx, longBy + latBy + vertBy, longBz + latBz + vertBz
      BrakeAcc = {brakeAx, brakeAy, brakeAz}
      unit.setEngineCommand('brake', BrakeAcc, {0,0,0}, 0, 1, '', '', '', 1)
     end
    end